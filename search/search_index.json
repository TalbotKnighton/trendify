{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Trendify","text":""},{"location":"usage/","title":"Tutorials here","text":""},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>grafana_api<ul> <li>dashboard</li> <li>panels<ul> <li>xy_chart</li> </ul> </li> <li>transformations<ul> <li>transformations</li> </ul> </li> </ul> </li> <li>trendify<ul> <li>cli</li> <li>products</li> <li>server</li> </ul> </li> </ul>"},{"location":"reference/grafana_api/","title":"grafana_api","text":""},{"location":"reference/grafana_api/#grafana_api","title":"grafana_api","text":""},{"location":"reference/grafana_api/#grafana_api.Annotation","title":"Annotation","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/grafana_api/dashboard.py</code> <pre><code>class Annotation(BaseModel):\n    \"\"\"\n    \"\"\"\n    builtIn: int = 1\n    datasource: dict = {\"type\": \"grafana\", \"uid\": \"-- Grafana --\"}\n    enable: bool = True\n    hide: bool = True\n    iconColor: str = 'rgba(0, 211, 255, 1)'\n    name: str = 'Annotation &amp; Alers'\n    type: str = 'dashboard'\n</code></pre>"},{"location":"reference/grafana_api/#grafana_api.Annotations","title":"Annotations","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/grafana_api/dashboard.py</code> <pre><code>class Annotations(BaseModel):\n    \"\"\"\n    \"\"\"\n    list: List[Annotation] = [Annotation()]\n</code></pre>"},{"location":"reference/grafana_api/#grafana_api.Dashboard","title":"Dashboard","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/grafana_api/dashboard.py</code> <pre><code>class Dashboard(BaseModel):\n    \"\"\"\n    \"\"\"\n    annotations: Annotations = Annotations()\n    description: str = \"Try Parsing JSON Data\"\n    editable: bool = True\n    fiscalYearStartMonth: int = 0\n    graphTooltip: int = 0\n    id: int = 1\n    links: list = []\n    panels: list[Panel] = [Panel()]\n    refresh: str = \"\"\n    schemaVersion: int = 39\n    tags: list = []\n    templating: Dict = {'list': []}\n    time: Dict = {'from': 'now-6h', 'to': 'now'}\n    timepicker: Dict = {}\n    timezone: str = 'browser'\n    title: str = 'DemoDashboard'\n    uid: str = 'de1dapkdr47wgf'\n    version: int = 20\n    weekStart: str = ''\n</code></pre>"},{"location":"reference/grafana_api/#grafana_api.DataSource","title":"DataSource","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class DataSource(BaseModel):\n    \"\"\"\n    \"\"\"\n    type: str = 'yesoreyeram-infinity-datasource'\n    uid: str = 'be1d76jvnf668b'\n</code></pre>"},{"location":"reference/grafana_api/#grafana_api.DefaultDataSource","title":"DefaultDataSource","text":"<p>               Bases: <code>DataSource</code></p> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class DefaultDataSource(DataSource):\n    \"\"\"\n    \"\"\"\n    default: bool = True\n</code></pre>"},{"location":"reference/grafana_api/#grafana_api.FieldConfig","title":"FieldConfig","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code> \"fieldConfig\": {\n    \"defaults\": {\n\n        \"fieldMinMax\": false,\n        \"mappings\": [],\n\n    },\n    \"overrides\": []\n},\n</code></pre> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class FieldConfig(BaseModel):\n    \"\"\"\n    ```json\n     \"fieldConfig\": {\n        \"defaults\": {\n\n            \"fieldMinMax\": false,\n            \"mappings\": [],\n\n        },\n        \"overrides\": []\n    },\n    ```\n    \"\"\"\n    defaults: Defaults = Defaults()\n    overrides: list = []\n</code></pre>"},{"location":"reference/grafana_api/#grafana_api.GridPosition","title":"GridPosition","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>\"gridPos\": {\n    \"h\": 8,\n    \"w\": 12,\n    \"x\": 12,\n    \"y\": 16\n}\n</code></pre> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class GridPosition(BaseModel):\n    \"\"\"\n    ```json\n    \"gridPos\": {\n        \"h\": 8,\n        \"w\": 12,\n        \"x\": 12,\n        \"y\": 16\n    }\n    ```\n    \"\"\"\n    h: int = 16\n    w: int = 24\n    x: int = 0\n    y: int = 0\n</code></pre>"},{"location":"reference/grafana_api/#grafana_api.HideFrom","title":"HideFrom","text":"<p>               Bases: <code>BaseModel</code></p> <p>{     \"legend\": false,     \"tooltip\": false,     \"viz\": false }</p> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class HideFrom(BaseModel):\n    \"\"\"\n    {\n        \"legend\": false,\n        \"tooltip\": false,\n        \"viz\": false\n    }\n    \"\"\"\n    legend: bool = False\n    tooltip: bool = False\n    viz: bool = False\n</code></pre>"},{"location":"reference/grafana_api/#grafana_api.Legend","title":"Legend","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class Legend(BaseModel):\n    \"\"\"\n    \"\"\"\n    calcs: list = []\n    displayMode: str = 'list'  # 'list' or 'table'\n    placement: str = 'bottom'\n    showLegend: bool = True\n    sortBy: str = 'Name'\n    sortDesc: bool = False\n</code></pre>"},{"location":"reference/grafana_api/#grafana_api.LineStyle","title":"LineStyle","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>{\n    \"fill\": \"solid\"\n}\n</code></pre> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class LineStyle(BaseModel):\n    \"\"\"\n    ```json\n    {\n        \"fill\": \"solid\"\n    }\n    ```\n    \"\"\"\n    fill: str = 'solid'\n</code></pre>"},{"location":"reference/grafana_api/#grafana_api.Options","title":"Options","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class Options(BaseModel):\n    \"\"\"\n    \"\"\"\n    legend: Legend = Legend()\n    mapping: str = 'auto'\n    series: list[Series] = [Series()]\n    tooltop: ToolTip = ToolTip()\n</code></pre>"},{"location":"reference/grafana_api/#grafana_api.Panel","title":"Panel","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class Panel(BaseModel):\n    \"\"\"\n    \"\"\"\n    datasource: DataSource = DefaultDataSource()\n    fieldConfig: FieldConfig = FieldConfig()\n    gridPos: GridPosition = GridPosition()\n    id: int = 1\n    options: Options = Options()\n    pluginVersion: str = '11.2.2'\n    targets: list[Target] = [Target()]\n    title: str = \"Example XY Chart for Trace2D Data\"\n    transformations: list[Transformation] = []\n    type: str = 'xychart'\n</code></pre>"},{"location":"reference/grafana_api/#grafana_api.PointSize","title":"PointSize","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>{\n    \"fixed\": 3\n}\n</code></pre> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class PointSize(BaseModel):\n    \"\"\"\n    ```json\n    {\n        \"fixed\": 3\n    }\n    ```\n    \"\"\"\n    fixed: int = 3\n</code></pre>"},{"location":"reference/grafana_api/#grafana_api.ScaleDistribution","title":"ScaleDistribution","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>{\n    \"type\": \"linear\"\n}\n</code></pre> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class ScaleDistribution(BaseModel):\n    \"\"\"\n    ```json\n    {\n        \"type\": \"linear\"\n    }\n    ```\n    \"\"\"\n    type: str = 'linear'\n</code></pre>"},{"location":"reference/grafana_api/#grafana_api.Series","title":"Series","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class Series(BaseModel):\n    \"\"\"\n    \"\"\"\n    x: Matcher = Matcher(matcher=MatcherOptions(options='x'))\n    y: Matcher = Matcher(matcher=MatcherOptions(options='y'))\n</code></pre>"},{"location":"reference/grafana_api/#grafana_api.Target","title":"Target","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class Target(BaseModel):\n    \"\"\"\n    \"\"\"\n    columns: list = []\n    datasource: DataSource = DataSource()\n    filters: list = []\n    format: str = 'table'\n    global_query_id: str = ''\n    hide: bool = False\n    parser: str = 'uql'\n    refId: str = 'A'  # Table name\n    root_selector: str = ''\n    source: str = 'url'\n    type: str = 'json'\n    uql: str = \"parse-json\\n| project \\\"elements\\\"\\n| extend \\\"label\\\"=\\\"pen.label\\\"\\n| extend \\\"label1\\\"=substring(\\\"label\\\",0,2)\\n| extend \\\"label2\\\"=substring(\\\"label\\\",3)\\n| mv-expand \\\"points\\\"\\n| extend \\\"x\\\"=\\\"points.x\\\", \\\"y\\\"=\\\"points.y\\\"\\n#| project \\\"label1\\\", \\\"label2\\\", \\\"x\\\", \\\"y\\\", \\\"color\\\"=mul(\\\"label2\\\", 0.1)\\n#| project \\\"label1\\\", \\\"x\\\", \\\"y\\\"\\n| project \\\"label\\\", \\\"x\\\", \\\"y\\\", \\\"metadata\\\"\\n\\n\\n\"\n    url: str = \"http://localhost:8000/data_products/workdir.products/trace_plots/Trace2D\"\n    url_options: URLOptions = URLOptions()\n</code></pre>"},{"location":"reference/grafana_api/#grafana_api.Threshold","title":"Threshold","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>{\n    \"color\": \"green\",\n    \"value\": null\n}\n</code></pre> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class Threshold(BaseModel):\n    \"\"\"\n    ```json\n    {\n        \"color\": \"green\",\n        \"value\": null\n    }\n    ```\n    \"\"\"\n    color: str = 'green'\n    value: float | None = None\n</code></pre>"},{"location":"reference/grafana_api/#grafana_api.Thresholds","title":"Thresholds","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>\"thresholds\": {\n    \"mode\": \"absolute\",\n    \"steps\": [\n\n    ]\n}\n</code></pre> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class Thresholds(BaseModel):\n    \"\"\"\n    ```json\n    \"thresholds\": {\n        \"mode\": \"absolute\",\n        \"steps\": [\n\n        ]\n    }\n    ```\n    \"\"\"\n    mode: str = 'absolute'\n    steps: list[Threshold] = [Threshold()]\n</code></pre>"},{"location":"reference/grafana_api/#grafana_api.ToolTip","title":"ToolTip","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class ToolTip(BaseModel):\n    \"\"\"\n    \"\"\"\n    mode: str = 'single'\n    sort: str = 'none'\n</code></pre>"},{"location":"reference/grafana_api/#grafana_api.Transformation","title":"Transformation","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/grafana_api/transformations/transformations.py</code> <pre><code>class Transformation(BaseModel):\n    \"\"\"\n\n    \"\"\"\n    id: str\n</code></pre>"},{"location":"reference/grafana_api/#grafana_api.URLOptions","title":"URLOptions","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class URLOptions(BaseModel):\n    \"\"\"\n    \"\"\"\n    data: str = ''\n    method: str = 'GET'\n</code></pre>"},{"location":"reference/grafana_api/dashboard/","title":"dashboard","text":""},{"location":"reference/grafana_api/dashboard/#grafana_api.dashboard","title":"grafana_api.dashboard","text":"<p>Dashboard definition</p>"},{"location":"reference/grafana_api/dashboard/#grafana_api.dashboard.Annotation","title":"Annotation","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/grafana_api/dashboard.py</code> <pre><code>class Annotation(BaseModel):\n    \"\"\"\n    \"\"\"\n    builtIn: int = 1\n    datasource: dict = {\"type\": \"grafana\", \"uid\": \"-- Grafana --\"}\n    enable: bool = True\n    hide: bool = True\n    iconColor: str = 'rgba(0, 211, 255, 1)'\n    name: str = 'Annotation &amp; Alers'\n    type: str = 'dashboard'\n</code></pre>"},{"location":"reference/grafana_api/dashboard/#grafana_api.dashboard.Annotations","title":"Annotations","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/grafana_api/dashboard.py</code> <pre><code>class Annotations(BaseModel):\n    \"\"\"\n    \"\"\"\n    list: List[Annotation] = [Annotation()]\n</code></pre>"},{"location":"reference/grafana_api/dashboard/#grafana_api.dashboard.Dashboard","title":"Dashboard","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/grafana_api/dashboard.py</code> <pre><code>class Dashboard(BaseModel):\n    \"\"\"\n    \"\"\"\n    annotations: Annotations = Annotations()\n    description: str = \"Try Parsing JSON Data\"\n    editable: bool = True\n    fiscalYearStartMonth: int = 0\n    graphTooltip: int = 0\n    id: int = 1\n    links: list = []\n    panels: list[Panel] = [Panel()]\n    refresh: str = \"\"\n    schemaVersion: int = 39\n    tags: list = []\n    templating: Dict = {'list': []}\n    time: Dict = {'from': 'now-6h', 'to': 'now'}\n    timepicker: Dict = {}\n    timezone: str = 'browser'\n    title: str = 'DemoDashboard'\n    uid: str = 'de1dapkdr47wgf'\n    version: int = 20\n    weekStart: str = ''\n</code></pre>"},{"location":"reference/grafana_api/panels/","title":"panels","text":""},{"location":"reference/grafana_api/panels/#grafana_api.panels","title":"grafana_api.panels","text":""},{"location":"reference/grafana_api/panels/#grafana_api.panels.DataSource","title":"DataSource","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class DataSource(BaseModel):\n    \"\"\"\n    \"\"\"\n    type: str = 'yesoreyeram-infinity-datasource'\n    uid: str = 'be1d76jvnf668b'\n</code></pre>"},{"location":"reference/grafana_api/panels/#grafana_api.panels.DefaultDataSource","title":"DefaultDataSource","text":"<p>               Bases: <code>DataSource</code></p> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class DefaultDataSource(DataSource):\n    \"\"\"\n    \"\"\"\n    default: bool = True\n</code></pre>"},{"location":"reference/grafana_api/panels/#grafana_api.panels.FieldConfig","title":"FieldConfig","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code> \"fieldConfig\": {\n    \"defaults\": {\n\n        \"fieldMinMax\": false,\n        \"mappings\": [],\n\n    },\n    \"overrides\": []\n},\n</code></pre> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class FieldConfig(BaseModel):\n    \"\"\"\n    ```json\n     \"fieldConfig\": {\n        \"defaults\": {\n\n            \"fieldMinMax\": false,\n            \"mappings\": [],\n\n        },\n        \"overrides\": []\n    },\n    ```\n    \"\"\"\n    defaults: Defaults = Defaults()\n    overrides: list = []\n</code></pre>"},{"location":"reference/grafana_api/panels/#grafana_api.panels.GridPosition","title":"GridPosition","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>\"gridPos\": {\n    \"h\": 8,\n    \"w\": 12,\n    \"x\": 12,\n    \"y\": 16\n}\n</code></pre> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class GridPosition(BaseModel):\n    \"\"\"\n    ```json\n    \"gridPos\": {\n        \"h\": 8,\n        \"w\": 12,\n        \"x\": 12,\n        \"y\": 16\n    }\n    ```\n    \"\"\"\n    h: int = 16\n    w: int = 24\n    x: int = 0\n    y: int = 0\n</code></pre>"},{"location":"reference/grafana_api/panels/#grafana_api.panels.HideFrom","title":"HideFrom","text":"<p>               Bases: <code>BaseModel</code></p> <p>{     \"legend\": false,     \"tooltip\": false,     \"viz\": false }</p> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class HideFrom(BaseModel):\n    \"\"\"\n    {\n        \"legend\": false,\n        \"tooltip\": false,\n        \"viz\": false\n    }\n    \"\"\"\n    legend: bool = False\n    tooltip: bool = False\n    viz: bool = False\n</code></pre>"},{"location":"reference/grafana_api/panels/#grafana_api.panels.Legend","title":"Legend","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class Legend(BaseModel):\n    \"\"\"\n    \"\"\"\n    calcs: list = []\n    displayMode: str = 'list'  # 'list' or 'table'\n    placement: str = 'bottom'\n    showLegend: bool = True\n    sortBy: str = 'Name'\n    sortDesc: bool = False\n</code></pre>"},{"location":"reference/grafana_api/panels/#grafana_api.panels.LineStyle","title":"LineStyle","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>{\n    \"fill\": \"solid\"\n}\n</code></pre> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class LineStyle(BaseModel):\n    \"\"\"\n    ```json\n    {\n        \"fill\": \"solid\"\n    }\n    ```\n    \"\"\"\n    fill: str = 'solid'\n</code></pre>"},{"location":"reference/grafana_api/panels/#grafana_api.panels.Options","title":"Options","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class Options(BaseModel):\n    \"\"\"\n    \"\"\"\n    legend: Legend = Legend()\n    mapping: str = 'auto'\n    series: list[Series] = [Series()]\n    tooltop: ToolTip = ToolTip()\n</code></pre>"},{"location":"reference/grafana_api/panels/#grafana_api.panels.Panel","title":"Panel","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class Panel(BaseModel):\n    \"\"\"\n    \"\"\"\n    datasource: DataSource = DefaultDataSource()\n    fieldConfig: FieldConfig = FieldConfig()\n    gridPos: GridPosition = GridPosition()\n    id: int = 1\n    options: Options = Options()\n    pluginVersion: str = '11.2.2'\n    targets: list[Target] = [Target()]\n    title: str = \"Example XY Chart for Trace2D Data\"\n    transformations: list[Transformation] = []\n    type: str = 'xychart'\n</code></pre>"},{"location":"reference/grafana_api/panels/#grafana_api.panels.PointSize","title":"PointSize","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>{\n    \"fixed\": 3\n}\n</code></pre> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class PointSize(BaseModel):\n    \"\"\"\n    ```json\n    {\n        \"fixed\": 3\n    }\n    ```\n    \"\"\"\n    fixed: int = 3\n</code></pre>"},{"location":"reference/grafana_api/panels/#grafana_api.panels.ScaleDistribution","title":"ScaleDistribution","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>{\n    \"type\": \"linear\"\n}\n</code></pre> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class ScaleDistribution(BaseModel):\n    \"\"\"\n    ```json\n    {\n        \"type\": \"linear\"\n    }\n    ```\n    \"\"\"\n    type: str = 'linear'\n</code></pre>"},{"location":"reference/grafana_api/panels/#grafana_api.panels.Series","title":"Series","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class Series(BaseModel):\n    \"\"\"\n    \"\"\"\n    x: Matcher = Matcher(matcher=MatcherOptions(options='x'))\n    y: Matcher = Matcher(matcher=MatcherOptions(options='y'))\n</code></pre>"},{"location":"reference/grafana_api/panels/#grafana_api.panels.Target","title":"Target","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class Target(BaseModel):\n    \"\"\"\n    \"\"\"\n    columns: list = []\n    datasource: DataSource = DataSource()\n    filters: list = []\n    format: str = 'table'\n    global_query_id: str = ''\n    hide: bool = False\n    parser: str = 'uql'\n    refId: str = 'A'  # Table name\n    root_selector: str = ''\n    source: str = 'url'\n    type: str = 'json'\n    uql: str = \"parse-json\\n| project \\\"elements\\\"\\n| extend \\\"label\\\"=\\\"pen.label\\\"\\n| extend \\\"label1\\\"=substring(\\\"label\\\",0,2)\\n| extend \\\"label2\\\"=substring(\\\"label\\\",3)\\n| mv-expand \\\"points\\\"\\n| extend \\\"x\\\"=\\\"points.x\\\", \\\"y\\\"=\\\"points.y\\\"\\n#| project \\\"label1\\\", \\\"label2\\\", \\\"x\\\", \\\"y\\\", \\\"color\\\"=mul(\\\"label2\\\", 0.1)\\n#| project \\\"label1\\\", \\\"x\\\", \\\"y\\\"\\n| project \\\"label\\\", \\\"x\\\", \\\"y\\\", \\\"metadata\\\"\\n\\n\\n\"\n    url: str = \"http://localhost:8000/data_products/workdir.products/trace_plots/Trace2D\"\n    url_options: URLOptions = URLOptions()\n</code></pre>"},{"location":"reference/grafana_api/panels/#grafana_api.panels.Threshold","title":"Threshold","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>{\n    \"color\": \"green\",\n    \"value\": null\n}\n</code></pre> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class Threshold(BaseModel):\n    \"\"\"\n    ```json\n    {\n        \"color\": \"green\",\n        \"value\": null\n    }\n    ```\n    \"\"\"\n    color: str = 'green'\n    value: float | None = None\n</code></pre>"},{"location":"reference/grafana_api/panels/#grafana_api.panels.Thresholds","title":"Thresholds","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>\"thresholds\": {\n    \"mode\": \"absolute\",\n    \"steps\": [\n\n    ]\n}\n</code></pre> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class Thresholds(BaseModel):\n    \"\"\"\n    ```json\n    \"thresholds\": {\n        \"mode\": \"absolute\",\n        \"steps\": [\n\n        ]\n    }\n    ```\n    \"\"\"\n    mode: str = 'absolute'\n    steps: list[Threshold] = [Threshold()]\n</code></pre>"},{"location":"reference/grafana_api/panels/#grafana_api.panels.ToolTip","title":"ToolTip","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class ToolTip(BaseModel):\n    \"\"\"\n    \"\"\"\n    mode: str = 'single'\n    sort: str = 'none'\n</code></pre>"},{"location":"reference/grafana_api/panels/#grafana_api.panels.URLOptions","title":"URLOptions","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class URLOptions(BaseModel):\n    \"\"\"\n    \"\"\"\n    data: str = ''\n    method: str = 'GET'\n</code></pre>"},{"location":"reference/grafana_api/panels/xy_chart/","title":"xy_chart","text":""},{"location":"reference/grafana_api/panels/xy_chart/#grafana_api.panels.xy_chart","title":"grafana_api.panels.xy_chart","text":"<p>Need to produce a Dashboard ```</p>"},{"location":"reference/grafana_api/panels/xy_chart/#grafana_api.panels.xy_chart.DataSource","title":"DataSource","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class DataSource(BaseModel):\n    \"\"\"\n    \"\"\"\n    type: str = 'yesoreyeram-infinity-datasource'\n    uid: str = 'be1d76jvnf668b'\n</code></pre>"},{"location":"reference/grafana_api/panels/xy_chart/#grafana_api.panels.xy_chart.DefaultDataSource","title":"DefaultDataSource","text":"<p>               Bases: <code>DataSource</code></p> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class DefaultDataSource(DataSource):\n    \"\"\"\n    \"\"\"\n    default: bool = True\n</code></pre>"},{"location":"reference/grafana_api/panels/xy_chart/#grafana_api.panels.xy_chart.FieldConfig","title":"FieldConfig","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code> \"fieldConfig\": {\n    \"defaults\": {\n\n        \"fieldMinMax\": false,\n        \"mappings\": [],\n\n    },\n    \"overrides\": []\n},\n</code></pre> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class FieldConfig(BaseModel):\n    \"\"\"\n    ```json\n     \"fieldConfig\": {\n        \"defaults\": {\n\n            \"fieldMinMax\": false,\n            \"mappings\": [],\n\n        },\n        \"overrides\": []\n    },\n    ```\n    \"\"\"\n    defaults: Defaults = Defaults()\n    overrides: list = []\n</code></pre>"},{"location":"reference/grafana_api/panels/xy_chart/#grafana_api.panels.xy_chart.GridPosition","title":"GridPosition","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>\"gridPos\": {\n    \"h\": 8,\n    \"w\": 12,\n    \"x\": 12,\n    \"y\": 16\n}\n</code></pre> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class GridPosition(BaseModel):\n    \"\"\"\n    ```json\n    \"gridPos\": {\n        \"h\": 8,\n        \"w\": 12,\n        \"x\": 12,\n        \"y\": 16\n    }\n    ```\n    \"\"\"\n    h: int = 16\n    w: int = 24\n    x: int = 0\n    y: int = 0\n</code></pre>"},{"location":"reference/grafana_api/panels/xy_chart/#grafana_api.panels.xy_chart.HideFrom","title":"HideFrom","text":"<p>               Bases: <code>BaseModel</code></p> <p>{     \"legend\": false,     \"tooltip\": false,     \"viz\": false }</p> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class HideFrom(BaseModel):\n    \"\"\"\n    {\n        \"legend\": false,\n        \"tooltip\": false,\n        \"viz\": false\n    }\n    \"\"\"\n    legend: bool = False\n    tooltip: bool = False\n    viz: bool = False\n</code></pre>"},{"location":"reference/grafana_api/panels/xy_chart/#grafana_api.panels.xy_chart.Legend","title":"Legend","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class Legend(BaseModel):\n    \"\"\"\n    \"\"\"\n    calcs: list = []\n    displayMode: str = 'list'  # 'list' or 'table'\n    placement: str = 'bottom'\n    showLegend: bool = True\n    sortBy: str = 'Name'\n    sortDesc: bool = False\n</code></pre>"},{"location":"reference/grafana_api/panels/xy_chart/#grafana_api.panels.xy_chart.LineStyle","title":"LineStyle","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>{\n    \"fill\": \"solid\"\n}\n</code></pre> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class LineStyle(BaseModel):\n    \"\"\"\n    ```json\n    {\n        \"fill\": \"solid\"\n    }\n    ```\n    \"\"\"\n    fill: str = 'solid'\n</code></pre>"},{"location":"reference/grafana_api/panels/xy_chart/#grafana_api.panels.xy_chart.MatcherOptions","title":"MatcherOptions","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class MatcherOptions(BaseModel):\n    \"\"\"\n    \"\"\"\n    options: str  # x or y\n    id: str = 'byName'\n</code></pre>"},{"location":"reference/grafana_api/panels/xy_chart/#grafana_api.panels.xy_chart.Options","title":"Options","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class Options(BaseModel):\n    \"\"\"\n    \"\"\"\n    legend: Legend = Legend()\n    mapping: str = 'auto'\n    series: list[Series] = [Series()]\n    tooltop: ToolTip = ToolTip()\n</code></pre>"},{"location":"reference/grafana_api/panels/xy_chart/#grafana_api.panels.xy_chart.Panel","title":"Panel","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class Panel(BaseModel):\n    \"\"\"\n    \"\"\"\n    datasource: DataSource = DefaultDataSource()\n    fieldConfig: FieldConfig = FieldConfig()\n    gridPos: GridPosition = GridPosition()\n    id: int = 1\n    options: Options = Options()\n    pluginVersion: str = '11.2.2'\n    targets: list[Target] = [Target()]\n    title: str = \"Example XY Chart for Trace2D Data\"\n    transformations: list[Transformation] = []\n    type: str = 'xychart'\n</code></pre>"},{"location":"reference/grafana_api/panels/xy_chart/#grafana_api.panels.xy_chart.PointSize","title":"PointSize","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>{\n    \"fixed\": 3\n}\n</code></pre> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class PointSize(BaseModel):\n    \"\"\"\n    ```json\n    {\n        \"fixed\": 3\n    }\n    ```\n    \"\"\"\n    fixed: int = 3\n</code></pre>"},{"location":"reference/grafana_api/panels/xy_chart/#grafana_api.panels.xy_chart.ScaleDistribution","title":"ScaleDistribution","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>{\n    \"type\": \"linear\"\n}\n</code></pre> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class ScaleDistribution(BaseModel):\n    \"\"\"\n    ```json\n    {\n        \"type\": \"linear\"\n    }\n    ```\n    \"\"\"\n    type: str = 'linear'\n</code></pre>"},{"location":"reference/grafana_api/panels/xy_chart/#grafana_api.panels.xy_chart.Series","title":"Series","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class Series(BaseModel):\n    \"\"\"\n    \"\"\"\n    x: Matcher = Matcher(matcher=MatcherOptions(options='x'))\n    y: Matcher = Matcher(matcher=MatcherOptions(options='y'))\n</code></pre>"},{"location":"reference/grafana_api/panels/xy_chart/#grafana_api.panels.xy_chart.Target","title":"Target","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class Target(BaseModel):\n    \"\"\"\n    \"\"\"\n    columns: list = []\n    datasource: DataSource = DataSource()\n    filters: list = []\n    format: str = 'table'\n    global_query_id: str = ''\n    hide: bool = False\n    parser: str = 'uql'\n    refId: str = 'A'  # Table name\n    root_selector: str = ''\n    source: str = 'url'\n    type: str = 'json'\n    uql: str = \"parse-json\\n| project \\\"elements\\\"\\n| extend \\\"label\\\"=\\\"pen.label\\\"\\n| extend \\\"label1\\\"=substring(\\\"label\\\",0,2)\\n| extend \\\"label2\\\"=substring(\\\"label\\\",3)\\n| mv-expand \\\"points\\\"\\n| extend \\\"x\\\"=\\\"points.x\\\", \\\"y\\\"=\\\"points.y\\\"\\n#| project \\\"label1\\\", \\\"label2\\\", \\\"x\\\", \\\"y\\\", \\\"color\\\"=mul(\\\"label2\\\", 0.1)\\n#| project \\\"label1\\\", \\\"x\\\", \\\"y\\\"\\n| project \\\"label\\\", \\\"x\\\", \\\"y\\\", \\\"metadata\\\"\\n\\n\\n\"\n    url: str = \"http://localhost:8000/data_products/workdir.products/trace_plots/Trace2D\"\n    url_options: URLOptions = URLOptions()\n</code></pre>"},{"location":"reference/grafana_api/panels/xy_chart/#grafana_api.panels.xy_chart.Threshold","title":"Threshold","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>{\n    \"color\": \"green\",\n    \"value\": null\n}\n</code></pre> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class Threshold(BaseModel):\n    \"\"\"\n    ```json\n    {\n        \"color\": \"green\",\n        \"value\": null\n    }\n    ```\n    \"\"\"\n    color: str = 'green'\n    value: float | None = None\n</code></pre>"},{"location":"reference/grafana_api/panels/xy_chart/#grafana_api.panels.xy_chart.Thresholds","title":"Thresholds","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>\"thresholds\": {\n    \"mode\": \"absolute\",\n    \"steps\": [\n\n    ]\n}\n</code></pre> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class Thresholds(BaseModel):\n    \"\"\"\n    ```json\n    \"thresholds\": {\n        \"mode\": \"absolute\",\n        \"steps\": [\n\n        ]\n    }\n    ```\n    \"\"\"\n    mode: str = 'absolute'\n    steps: list[Threshold] = [Threshold()]\n</code></pre>"},{"location":"reference/grafana_api/panels/xy_chart/#grafana_api.panels.xy_chart.ToolTip","title":"ToolTip","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class ToolTip(BaseModel):\n    \"\"\"\n    \"\"\"\n    mode: str = 'single'\n    sort: str = 'none'\n</code></pre>"},{"location":"reference/grafana_api/panels/xy_chart/#grafana_api.panels.xy_chart.URLOptions","title":"URLOptions","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/grafana_api/panels/xy_chart.py</code> <pre><code>class URLOptions(BaseModel):\n    \"\"\"\n    \"\"\"\n    data: str = ''\n    method: str = 'GET'\n</code></pre>"},{"location":"reference/grafana_api/transformations/","title":"transformations","text":""},{"location":"reference/grafana_api/transformations/#grafana_api.transformations","title":"grafana_api.transformations","text":""},{"location":"reference/grafana_api/transformations/#grafana_api.transformations.Transformation","title":"Transformation","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/grafana_api/transformations/transformations.py</code> <pre><code>class Transformation(BaseModel):\n    \"\"\"\n\n    \"\"\"\n    id: str\n</code></pre>"},{"location":"reference/grafana_api/transformations/transformations/","title":"transformations","text":""},{"location":"reference/grafana_api/transformations/transformations/#grafana_api.transformations.transformations","title":"grafana_api.transformations.transformations","text":"<pre><code>{\n    \"id\": \"merge\",\n    \"options\": {}\n},\n{\n    \"id\": \"partitionByValues\",\n    \"options\": {\n        \"fields\": [\n            \"label\"\n        ],\n        \"keepFields\": false,\n        \"naming\": {\n            \"asLabels\": false\n        }\n    }\n}\n</code></pre>"},{"location":"reference/grafana_api/transformations/transformations/#grafana_api.transformations.transformations.Transformation","title":"Transformation","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/grafana_api/transformations/transformations.py</code> <pre><code>class Transformation(BaseModel):\n    \"\"\"\n\n    \"\"\"\n    id: str\n</code></pre>"},{"location":"reference/trendify/","title":"trendify","text":""},{"location":"reference/trendify/#trendify","title":"trendify","text":"<p>Provides top-level imports</p>"},{"location":"reference/trendify/#trendify.DataProduct","title":"DataProduct","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for data products to be generated and handled.</p> <p>Attributes:</p> <ul> <li> <code>product_type</code>               (<code>Hashable</code>)           \u2013            <p>Product type should be the same as the class name. The product type is used to search for products from a DataProductCollection.</p> </li> <li> <code>tags</code>               (<code>Tags</code>)           \u2013            <p>Tags to be used for sorting data.</p> </li> <li> <code>metadata</code>               (<code>dict[str, str]</code>)           \u2013            <p>A dictionary of metadata to be used as a tool tip for mousover in grafana</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>class DataProduct(BaseModel):\n    \"\"\"\n    Base class for data products to be generated and handled.\n\n    Attributes:\n        product_type (Hashable): Product type should be the same as the class name.\n            The product type is used to search for products from a [DataProductCollection][trendify.products.DataProductCollection].\n        tags (Tags): Tags to be used for sorting data.\n        metadata (dict[str, str]): A dictionary of metadata to be used as a tool tip for mousover in grafana\n    \"\"\"\n    product_type: Hashable\n    tags: Tags\n    metadata: dict[str, str] = {}\n\n    def __init_subclass__(cls, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Registers child subclasses to be able to parse them from JSON file using the \n        [deserialize_child_classes][trendify.products.DataProduct.deserialize_child_classes] method\n        \"\"\"\n        super().__init_subclass__(**kwargs)\n        _data_product_subclass_registry[cls.__name__] = cls    \n\n    class Config:\n        \"\"\"\n        Disallows additional attributes\n        \"\"\"\n        extra = \"allow\"  \n\n    def append_to_list(self, l: List):\n        \"\"\"\n        Appends self to list.\n\n        Args:\n            l (List): list to which `self` will be appended\n\n        Returns:\n            (Self): returns instance of `self`\n        \"\"\"\n        l.append(self)\n        return self\n\n    @classmethod\n    def deserialize_child_classes(cls, key: str, **kwargs):\n        \"\"\"\n        Loads json data to pydandic dataclass of whatever DataProduct child time is appropriate\n\n        Args:\n            key (str): json key\n            kwargs (dict): json entries stored under given key\n        \"\"\"\n        type_key = 'product_type'\n        elements = kwargs.get(key, None)\n        if elements:\n            for index in range(len(kwargs[key])):\n                current_duck = kwargs[key][index]\n                if isinstance(current_duck, dict):\n                    item_duck_type = current_duck[type_key]\n                    for _, subclass in _data_product_subclass_registry.items():\n                        registery_duck_type = subclass.__fields__[type_key].default\n                        if item_duck_type == registery_duck_type:\n                            current_duck = subclass(**current_duck) \n                            break\n                    kwargs[key][index] = current_duck\n</code></pre>"},{"location":"reference/trendify/#trendify.DataProduct.Config","title":"Config","text":"<p>Disallows additional attributes</p> Source code in <code>src/trendify/products.py</code> <pre><code>class Config:\n    \"\"\"\n    Disallows additional attributes\n    \"\"\"\n    extra = \"allow\"  \n</code></pre>"},{"location":"reference/trendify/#trendify.DataProduct.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(**kwargs: Any) -&gt; None\n</code></pre> <p>Registers child subclasses to be able to parse them from JSON file using the  deserialize_child_classes method</p> Source code in <code>src/trendify/products.py</code> <pre><code>def __init_subclass__(cls, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Registers child subclasses to be able to parse them from JSON file using the \n    [deserialize_child_classes][trendify.products.DataProduct.deserialize_child_classes] method\n    \"\"\"\n    super().__init_subclass__(**kwargs)\n    _data_product_subclass_registry[cls.__name__] = cls    \n</code></pre>"},{"location":"reference/trendify/#trendify.DataProduct.append_to_list","title":"append_to_list","text":"<pre><code>append_to_list(l: List)\n</code></pre> <p>Appends self to list.</p> <p>Parameters:</p> <ul> <li> <code>l</code>               (<code>List</code>)           \u2013            <p>list to which <code>self</code> will be appended</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>returns instance of <code>self</code></p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def append_to_list(self, l: List):\n    \"\"\"\n    Appends self to list.\n\n    Args:\n        l (List): list to which `self` will be appended\n\n    Returns:\n        (Self): returns instance of `self`\n    \"\"\"\n    l.append(self)\n    return self\n</code></pre>"},{"location":"reference/trendify/#trendify.DataProduct.deserialize_child_classes","title":"deserialize_child_classes  <code>classmethod</code>","text":"<pre><code>deserialize_child_classes(key: str, **kwargs)\n</code></pre> <p>Loads json data to pydandic dataclass of whatever DataProduct child time is appropriate</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>json key</p> </li> <li> <code>kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>json entries stored under given key</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>@classmethod\ndef deserialize_child_classes(cls, key: str, **kwargs):\n    \"\"\"\n    Loads json data to pydandic dataclass of whatever DataProduct child time is appropriate\n\n    Args:\n        key (str): json key\n        kwargs (dict): json entries stored under given key\n    \"\"\"\n    type_key = 'product_type'\n    elements = kwargs.get(key, None)\n    if elements:\n        for index in range(len(kwargs[key])):\n            current_duck = kwargs[key][index]\n            if isinstance(current_duck, dict):\n                item_duck_type = current_duck[type_key]\n                for _, subclass in _data_product_subclass_registry.items():\n                    registery_duck_type = subclass.__fields__[type_key].default\n                    if item_duck_type == registery_duck_type:\n                        current_duck = subclass(**current_duck) \n                        break\n                kwargs[key][index] = current_duck\n</code></pre>"},{"location":"reference/trendify/#trendify.DataProductCollection","title":"DataProductCollection","text":"<p>               Bases: <code>BaseModel</code></p> <p>A collection of data products.</p> <p>Use this class to serialize data products to JSON, de-serialized them from JSON, filter the products, etc.</p> <p>Attributes:</p> <ul> <li> <code>elements</code>               (<code>ProductList</code>)           \u2013            <p>A list of data products.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>class DataProductCollection(BaseModel):\n    \"\"\"\n    A collection of data products.\n\n    Use this class to serialize data products to JSON, de-serialized them from JSON, filter the products, etc.\n\n    Attributes:\n        elements (ProductList): A list of data products.\n    \"\"\"\n    elements: ProductList | None = None\n\n    def __init__(self, **kwargs):\n        DataProduct.deserialize_child_classes(key='elements', **kwargs)                \n        super().__init__(**kwargs)\n\n    @classmethod\n    def from_iterable(cls, *products: Tuple[ProductList, ...]):\n        \"\"\"\n        Returns a new instance containing all of the products provided in the `*products` argument.\n\n        Args:\n            products (Tuple[ProductList, ...]): Lists of data products to combine into a collection\n\n        Returns:\n            (cls): A data product collection containing all of the provided products in the `*products` argument.\n        \"\"\"\n        return cls(elements=list(flatten(products)))\n\n    def get_tags(self, data_product_type: Type[DataProduct] | None = None) -&gt; set:\n        \"\"\"\n        Gets the tags related to a given type of `DataProduct`.  Parent classes will match all child class types.\n\n        Args:\n            data_product_type (Type[DataProduct] | None): type for which you want to get the list of tags\n\n        Returns:\n            (set): set of tags applying to the given `data_product_type`.\n        \"\"\"\n        tags = []\n        for e in flatten(self.elements):\n            if data_product_type is None or isinstance(e, data_product_type):\n                for t in e.tags:\n                    tags.append(t)\n        return set(tags)\n\n    def add_products(self, *products: DataProduct):\n        \"\"\"\n        Args:\n            products (Tuple[DataProduct|ProductList, ...]): Products or lists of products to be\n                appended to collection elements.  \n        \"\"\"\n        self.elements.extend(flatten(products))\n\n    # def convert_traces_to_points(self):\n    #     constructor = type(self)\n    #     unchanged_elements = self.drop_products(object_type=Trace2D).elements\n    #     traces: List[Trace2D] = self.get_products(object_type=Trace2D).elements\n    #     trace_points = [t.propagate_format2d_and_pen for t in traces]\n    #     return constructor(elements=unchanged_elements)\n\n    # @classmethod\n    # def get_tags_from_file(cls, subdir: Path):\n    #     \"\"\"\n    #     DEPRICATED\n\n    #     Reads file and returns the tags in each type of tag set.\n\n    #     Returns:\n    #         (TagSets): a data class holding the tags of each type in set objects.\n    #     \"\"\"\n    #     collection = DataProductCollection.model_validate_json(subdir.joinpath(DATA_PRODUCTS_FNAME).read_text())\n    #     tags = TagSets(\n    #         XYData=collection.get_tags(XYData), \n    #         TableEntry=collection.get_tags(TableEntry),\n    #         HistogramEntry=collection.get_tags(HistogramEntry),\n    #     )\n    #     return tags\n\n    def drop_products(self, tag: Hashable | None = None, object_type: Type[R] | None = None) -&gt; Self[R]:\n        \"\"\"\n        Removes products matching `tag` and/or `object_type` from collection elements.\n\n        Args:\n            tag (Tag | None): Tag for which data products should be dropped\n            object_type (Type | None): Type of data product to drop\n\n        Returns:\n            (DataProductCollection): A new collection from which matching elements have been dropped.\n        \"\"\"\n        match_key = tag is None, object_type is None\n        match match_key:\n            case (True, True):\n                return type(self)(elements=self.elements)\n            case (True, False):\n                return type(self)(elements=[e for e in self.elements if not isinstance(e, object_type)])\n            case (False, True):\n                return type(self)(elements=[e for e in self.elements if not tag in e.tags])\n            case (False, False):\n                return type(self)(elements=[e for e in self.elements if not (tag in e.tags and isinstance(e, object_type))])\n            case _:\n                raise ValueError('Something is wrong with match statement')\n\n    def get_products(self, tag: Hashable | None = None, object_type: Type[R] | None = None) -&gt; Self[R]:\n        \"\"\"\n        Returns a new collection containing products matching `tag` and/or `object_type`.\n        Both `tag` and `object_type` default to `None` which matches all products.\n\n        Args:\n            tag (Tag | None): Tag of data products to be kept.  `None` matches all products.\n            object_type (Type | None): Type of data product to keep.  `None` matches all products.\n\n        Returns:\n            (DataProductCollection): A new collection containing matching elements.\n        \"\"\"\n        match_key = tag is None, object_type is None\n        match match_key:\n            case (True, True):\n                return type(self)(elements=self.elements)\n            case (True, False):\n                return type(self)(elements=[e for e in self.elements if isinstance(e, object_type)])\n            case (False, True):\n                return type(self)(elements=[e for e in self.elements if tag in e.tags])\n            case (False, False):\n                return type(self)(elements=[e for e in self.elements if tag in e.tags and isinstance(e, object_type)])\n            case _:\n                raise ValueError('Something is wrong with match statement')\n\n    @classmethod\n    def union(cls, *collections: DataProductCollection):\n        \"\"\"\n        Aggregates all of the products from multiple collections into a new larger collection.\n\n        Args:\n            collections (Tuple[DataProductCollection, ...]): Data product collections\n                for which the products should be combined into a new collection.\n\n        Returns:\n            (Type[Self]): A new data product collection containing all products from\n                the provided `*collections`.\n        \"\"\"\n        return cls(elements=list(flatten(chain(c.elements for c in collections))))\n\n    @classmethod\n    def collect_from_all_jsons(cls, *dirs: Path, recursive=False):\n        \"\"\"\n        Loads all products from JSONs in the given list of directories.  \n        If recursive is set to `True`, the directories will be searched recursively \n        (this could lead to double counting if you pass in subdirectories of a parent).\n\n        Args:\n            dirs (Tuple[Path, ...]): Directories from which to load data product JSON files.\n            recursive (bool): whether or not to search each of the provided directories recursively for \n                data product json files.\n\n        Returns:\n            (Type[Self] | None): Data product collection if JSON files are found.  \n                Otherwise, returns None if no product JSON files were found.\n        \"\"\"\n        if not recursive:\n            jsons: List[Path] = list(flatten(chain(list(d.glob('*.json')) for d in dirs)))\n        else:\n            jsons: List[Path] = list(flatten(chain(list(d.glob('**/*.json')) for d in dirs)))\n        if jsons:\n            return cls.union(\n                *tuple(\n                    [\n                        cls.model_validate_json(p.read_text())\n                        for p in jsons\n                    ]\n                )\n            )\n        else:\n            return None\n\n    @classmethod\n    def sort_by_tags(cls, dirs_in: List[Path], dir_out: Path):\n        \"\"\"\n        Loads the data product JSON files from `dirs_in` sorts the products.\n        Sorted products are written to smaller files in a nested directory structure under `dir_out`.\n        The nested directory structure is generated accordint to the data tags.\n        Resulting product files are named according to the directory from which they were originally loaded.\n\n        Args:\n            dirs_in (List[Path]): Directories from which the data product JSON files are to be loaded.\n            dir_out (Path): Directory to which the sorted data products will be written into a \n                nested folder structure generated according to the data tags.\n        \"\"\"\n        dirs_in = list(dirs_in)\n        dirs_in.sort()\n        len_dirs = len(dirs_in)\n        for n, d in enumerate(dirs_in):\n            print(f'Collecting tagged data from dir {n}/{len_dirs}', end=f'\\r')\n            collection = DataProductCollection.model_validate_json(\n                d.joinpath(DATA_PRODUCTS_FNAME).read_text()\n            )\n            tags = collection.get_tags()\n            for tag in tags:\n                sub_collection = collection.get_products(tag=tag)\n                save_to = dir_out.joinpath(*atleast_1d(tag))\n                save_to.mkdir(parents=True, exist_ok=True)\n                save_to.joinpath(d.name).with_suffix('.json').write_text(sub_collection.model_dump_json(\n                    indent=4\n                ))\n\n    @classmethod\n    def process_single_tag_collection(\n            cls,\n            dir_in: Path,\n            dir_out: Path,\n            make_tables: bool,\n            make_xy_plots: bool,\n            make_histograms: bool,\n            dpi: int,\n        ):\n        \"\"\"\n        Processes collection of elements corresponding to a single tag.\n        This method should be called on a directory containing jsons for which the products have been\n        sorted.\n\n        Args:\n            dir_in (Path):\n            dir_out (Path):\n            make_tables (bool):\n            make_xy_plots (bool):\n            make_histograms (bool):\n            dpi (int):\n        \"\"\"\n\n        collection = cls.collect_from_all_jsons(dir_in)\n\n        if collection is not None:\n\n            [tag] = collection.get_tags()\n\n            if make_tables:\n\n                table_entries: List[TableEntry] = collection.get_products(tag=tag, object_type=TableEntry).elements\n\n                if table_entries:\n                    print(f'\\n\\nMaking tables for {tag = }\\n')\n                    TableBuilder.process_table_entries(\n                        tag=tag,\n                        table_entries=table_entries,\n                        out_dir=dir_out\n                    )\n                    print(f'\\nFinished tables for {tag = }\\n')\n\n            if make_xy_plots:\n\n                traces: List[Trace2D] = collection.get_products(tag=tag, object_type=Trace2D).elements\n                points: List[Point2D] = collection.get_products(tag=tag, object_type=Point2D).elements\n\n                if points or traces:\n                    print(f'\\n\\nMaking xy plot for {tag = }\\n')\n                    XYDataPlotter.handle_points_and_traces(\n                        tag=tag,\n                        points=points,\n                        traces=traces,\n                        dir_out=dir_out,\n                        dpi=dpi,\n                    )\n                    print(f'\\nFinished xy plot for {tag = }\\n')\n\n            if make_histograms:\n                histogram_entries: List[HistogramEntry] = collection.get_products(tag=tag, object_type=HistogramEntry).elements\n\n                if histogram_entries:\n                    print(f'\\n\\nMaking histogram for {tag = }\\n')\n                    Histogrammer.handle_histogram_entries(\n                        tag=tag,\n                        histogram_entries=histogram_entries,\n                        dir_out=dir_out,\n                        dpi=dpi\n                    )\n                    print(f'\\nFinished histogram for {tag = }\\n')\n\n\n    @classmethod\n    def make_grafana_panels(\n            cls,\n            dir_in: Path,\n            panel_dir: Path,\n        ):\n        \"\"\"\n        Processes collection of elements corresponding to a single tag.\n        This method should be called on a directory containing jsons for which the products have been\n        sorted.\n\n        Args:\n            dir_in (Path): Directory from which to read data products (should be sorted first)\n            panel_dir (Path): Where to put the panel information\n        \"\"\"\n\n        collection = cls.collect_from_all_jsons(dir_in)\n        panel_dir.mkdir(parents=True, exist_ok=True)\n\n        if collection is not None:\n            server_path = 'http://localhost:8000/data_products/workdir.products/'  # [ ] this should not be hard coded\n\n            for tag in collection.get_tags():\n\n\n                dot_tag = '.'.join([str(t) for t in tag]) if should_be_flattened(tag) else tag\n                underscore_tag = '_'.join([str(t) for t in tag]) if should_be_flattened(tag) else tag\n\n                table_entries: List[TableEntry] = collection.get_products(tag=tag, object_type=TableEntry).elements\n\n                if table_entries:\n                    print(f'\\n\\nMaking tables for {tag = }\\n')\n                    panel = gapi.Panel(\n                        targets=[\n                            gapi.Target(\n                                datasource=gapi.DataSource(),\n                                url='/'.join([server_path.strip('/'), dot_tag, 'TableEntry']),\n                                uql=UQL_TableEntry,\n                            )\n                        ],\n                        type='table',\n                    )\n                    panel_dir.joinpath(underscore_tag + '_table_panel.json').write_text(panel.model_dump_json(indent=4))\n                    print(f'\\nFinished tables for {tag = }\\n')\n\n                traces: List[Trace2D] = collection.get_products(tag=tag, object_type=Trace2D).elements\n                points: List[Point2D] = collection.get_products(tag=tag, object_type=Point2D).elements\n\n                if points or traces:\n                    print(f'\\n\\nMaking xy chart for {tag = }\\n')\n                    panel = gapi.Panel(\n                        targets=[\n                            gapi.Target(\n                                datasource=gapi.DataSource(),\n                                url='/'.join([server_path.strip('/'), dot_tag, 'Point2D']),\n                                uql=UQL_Point2D,\n                                refId='A',\n                            ),\n                            gapi.Target(\n                                datasource=gapi.DataSource(),\n                                url='/'.join([server_path.strip('/'), dot_tag, 'Trace2D']),\n                                uql=UQL_Trace2D,\n                                refId='B',\n                            )\n                        ],\n                        transformations=[\n                            gapi.Merge(),\n                            gapi.PartitionByValues.from_fields(\n                                fields='label',\n                                keep_fields=False,\n                                fields_as_labels=False,\n                            )\n                        ],\n                        type='xychart',\n                    )\n                    panel_dir.joinpath(underscore_tag + '_xy_panel.json').write_text(panel.model_dump_json(indent=4))\n                    print(f'\\nFinished xy plot for {tag = }\\n')\n</code></pre>"},{"location":"reference/trendify/#trendify.DataProductCollection.add_products","title":"add_products","text":"<pre><code>add_products(*products: DataProduct)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>products</code>               (<code>Tuple[DataProduct | ProductList, ...]</code>, default:                   <code>()</code> )           \u2013            <p>Products or lists of products to be appended to collection elements.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def add_products(self, *products: DataProduct):\n    \"\"\"\n    Args:\n        products (Tuple[DataProduct|ProductList, ...]): Products or lists of products to be\n            appended to collection elements.  \n    \"\"\"\n    self.elements.extend(flatten(products))\n</code></pre>"},{"location":"reference/trendify/#trendify.DataProductCollection.collect_from_all_jsons","title":"collect_from_all_jsons  <code>classmethod</code>","text":"<pre><code>collect_from_all_jsons(*dirs: Path, recursive=False)\n</code></pre> <p>Loads all products from JSONs in the given list of directories. If recursive is set to <code>True</code>, the directories will be searched recursively  (this could lead to double counting if you pass in subdirectories of a parent).</p> <p>Parameters:</p> <ul> <li> <code>dirs</code>               (<code>Tuple[Path, ...]</code>, default:                   <code>()</code> )           \u2013            <p>Directories from which to load data product JSON files.</p> </li> <li> <code>recursive</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>whether or not to search each of the provided directories recursively for  data product json files.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Type[Self] | None</code>           \u2013            <p>Data product collection if JSON files are found. Otherwise, returns None if no product JSON files were found.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>@classmethod\ndef collect_from_all_jsons(cls, *dirs: Path, recursive=False):\n    \"\"\"\n    Loads all products from JSONs in the given list of directories.  \n    If recursive is set to `True`, the directories will be searched recursively \n    (this could lead to double counting if you pass in subdirectories of a parent).\n\n    Args:\n        dirs (Tuple[Path, ...]): Directories from which to load data product JSON files.\n        recursive (bool): whether or not to search each of the provided directories recursively for \n            data product json files.\n\n    Returns:\n        (Type[Self] | None): Data product collection if JSON files are found.  \n            Otherwise, returns None if no product JSON files were found.\n    \"\"\"\n    if not recursive:\n        jsons: List[Path] = list(flatten(chain(list(d.glob('*.json')) for d in dirs)))\n    else:\n        jsons: List[Path] = list(flatten(chain(list(d.glob('**/*.json')) for d in dirs)))\n    if jsons:\n        return cls.union(\n            *tuple(\n                [\n                    cls.model_validate_json(p.read_text())\n                    for p in jsons\n                ]\n            )\n        )\n    else:\n        return None\n</code></pre>"},{"location":"reference/trendify/#trendify.DataProductCollection.drop_products","title":"drop_products","text":"<pre><code>drop_products(\n    tag: Hashable | None = None,\n    object_type: Type[R] | None = None,\n) -&gt; Self[R]\n</code></pre> <p>Removes products matching <code>tag</code> and/or <code>object_type</code> from collection elements.</p> <p>Parameters:</p> <ul> <li> <code>tag</code>               (<code>Tag | None</code>, default:                   <code>None</code> )           \u2013            <p>Tag for which data products should be dropped</p> </li> <li> <code>object_type</code>               (<code>Type | None</code>, default:                   <code>None</code> )           \u2013            <p>Type of data product to drop</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataProductCollection</code>           \u2013            <p>A new collection from which matching elements have been dropped.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def drop_products(self, tag: Hashable | None = None, object_type: Type[R] | None = None) -&gt; Self[R]:\n    \"\"\"\n    Removes products matching `tag` and/or `object_type` from collection elements.\n\n    Args:\n        tag (Tag | None): Tag for which data products should be dropped\n        object_type (Type | None): Type of data product to drop\n\n    Returns:\n        (DataProductCollection): A new collection from which matching elements have been dropped.\n    \"\"\"\n    match_key = tag is None, object_type is None\n    match match_key:\n        case (True, True):\n            return type(self)(elements=self.elements)\n        case (True, False):\n            return type(self)(elements=[e for e in self.elements if not isinstance(e, object_type)])\n        case (False, True):\n            return type(self)(elements=[e for e in self.elements if not tag in e.tags])\n        case (False, False):\n            return type(self)(elements=[e for e in self.elements if not (tag in e.tags and isinstance(e, object_type))])\n        case _:\n            raise ValueError('Something is wrong with match statement')\n</code></pre>"},{"location":"reference/trendify/#trendify.DataProductCollection.from_iterable","title":"from_iterable  <code>classmethod</code>","text":"<pre><code>from_iterable(*products: Tuple[ProductList, ...])\n</code></pre> <p>Returns a new instance containing all of the products provided in the <code>*products</code> argument.</p> <p>Parameters:</p> <ul> <li> <code>products</code>               (<code>Tuple[ProductList, ...]</code>, default:                   <code>()</code> )           \u2013            <p>Lists of data products to combine into a collection</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>cls</code>           \u2013            <p>A data product collection containing all of the provided products in the <code>*products</code> argument.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>@classmethod\ndef from_iterable(cls, *products: Tuple[ProductList, ...]):\n    \"\"\"\n    Returns a new instance containing all of the products provided in the `*products` argument.\n\n    Args:\n        products (Tuple[ProductList, ...]): Lists of data products to combine into a collection\n\n    Returns:\n        (cls): A data product collection containing all of the provided products in the `*products` argument.\n    \"\"\"\n    return cls(elements=list(flatten(products)))\n</code></pre>"},{"location":"reference/trendify/#trendify.DataProductCollection.get_products","title":"get_products","text":"<pre><code>get_products(\n    tag: Hashable | None = None,\n    object_type: Type[R] | None = None,\n) -&gt; Self[R]\n</code></pre> <p>Returns a new collection containing products matching <code>tag</code> and/or <code>object_type</code>. Both <code>tag</code> and <code>object_type</code> default to <code>None</code> which matches all products.</p> <p>Parameters:</p> <ul> <li> <code>tag</code>               (<code>Tag | None</code>, default:                   <code>None</code> )           \u2013            <p>Tag of data products to be kept.  <code>None</code> matches all products.</p> </li> <li> <code>object_type</code>               (<code>Type | None</code>, default:                   <code>None</code> )           \u2013            <p>Type of data product to keep.  <code>None</code> matches all products.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataProductCollection</code>           \u2013            <p>A new collection containing matching elements.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def get_products(self, tag: Hashable | None = None, object_type: Type[R] | None = None) -&gt; Self[R]:\n    \"\"\"\n    Returns a new collection containing products matching `tag` and/or `object_type`.\n    Both `tag` and `object_type` default to `None` which matches all products.\n\n    Args:\n        tag (Tag | None): Tag of data products to be kept.  `None` matches all products.\n        object_type (Type | None): Type of data product to keep.  `None` matches all products.\n\n    Returns:\n        (DataProductCollection): A new collection containing matching elements.\n    \"\"\"\n    match_key = tag is None, object_type is None\n    match match_key:\n        case (True, True):\n            return type(self)(elements=self.elements)\n        case (True, False):\n            return type(self)(elements=[e for e in self.elements if isinstance(e, object_type)])\n        case (False, True):\n            return type(self)(elements=[e for e in self.elements if tag in e.tags])\n        case (False, False):\n            return type(self)(elements=[e for e in self.elements if tag in e.tags and isinstance(e, object_type)])\n        case _:\n            raise ValueError('Something is wrong with match statement')\n</code></pre>"},{"location":"reference/trendify/#trendify.DataProductCollection.get_tags","title":"get_tags","text":"<pre><code>get_tags(\n    data_product_type: Type[DataProduct] | None = None,\n) -&gt; set\n</code></pre> <p>Gets the tags related to a given type of <code>DataProduct</code>.  Parent classes will match all child class types.</p> <p>Parameters:</p> <ul> <li> <code>data_product_type</code>               (<code>Type[DataProduct] | None</code>, default:                   <code>None</code> )           \u2013            <p>type for which you want to get the list of tags</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>set</code>           \u2013            <p>set of tags applying to the given <code>data_product_type</code>.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def get_tags(self, data_product_type: Type[DataProduct] | None = None) -&gt; set:\n    \"\"\"\n    Gets the tags related to a given type of `DataProduct`.  Parent classes will match all child class types.\n\n    Args:\n        data_product_type (Type[DataProduct] | None): type for which you want to get the list of tags\n\n    Returns:\n        (set): set of tags applying to the given `data_product_type`.\n    \"\"\"\n    tags = []\n    for e in flatten(self.elements):\n        if data_product_type is None or isinstance(e, data_product_type):\n            for t in e.tags:\n                tags.append(t)\n    return set(tags)\n</code></pre>"},{"location":"reference/trendify/#trendify.DataProductCollection.make_grafana_panels","title":"make_grafana_panels  <code>classmethod</code>","text":"<pre><code>make_grafana_panels(dir_in: Path, panel_dir: Path)\n</code></pre> <p>Processes collection of elements corresponding to a single tag. This method should be called on a directory containing jsons for which the products have been sorted.</p> <p>Parameters:</p> <ul> <li> <code>dir_in</code>               (<code>Path</code>)           \u2013            <p>Directory from which to read data products (should be sorted first)</p> </li> <li> <code>panel_dir</code>               (<code>Path</code>)           \u2013            <p>Where to put the panel information</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>@classmethod\ndef make_grafana_panels(\n        cls,\n        dir_in: Path,\n        panel_dir: Path,\n    ):\n    \"\"\"\n    Processes collection of elements corresponding to a single tag.\n    This method should be called on a directory containing jsons for which the products have been\n    sorted.\n\n    Args:\n        dir_in (Path): Directory from which to read data products (should be sorted first)\n        panel_dir (Path): Where to put the panel information\n    \"\"\"\n\n    collection = cls.collect_from_all_jsons(dir_in)\n    panel_dir.mkdir(parents=True, exist_ok=True)\n\n    if collection is not None:\n        server_path = 'http://localhost:8000/data_products/workdir.products/'  # [ ] this should not be hard coded\n\n        for tag in collection.get_tags():\n\n\n            dot_tag = '.'.join([str(t) for t in tag]) if should_be_flattened(tag) else tag\n            underscore_tag = '_'.join([str(t) for t in tag]) if should_be_flattened(tag) else tag\n\n            table_entries: List[TableEntry] = collection.get_products(tag=tag, object_type=TableEntry).elements\n\n            if table_entries:\n                print(f'\\n\\nMaking tables for {tag = }\\n')\n                panel = gapi.Panel(\n                    targets=[\n                        gapi.Target(\n                            datasource=gapi.DataSource(),\n                            url='/'.join([server_path.strip('/'), dot_tag, 'TableEntry']),\n                            uql=UQL_TableEntry,\n                        )\n                    ],\n                    type='table',\n                )\n                panel_dir.joinpath(underscore_tag + '_table_panel.json').write_text(panel.model_dump_json(indent=4))\n                print(f'\\nFinished tables for {tag = }\\n')\n\n            traces: List[Trace2D] = collection.get_products(tag=tag, object_type=Trace2D).elements\n            points: List[Point2D] = collection.get_products(tag=tag, object_type=Point2D).elements\n\n            if points or traces:\n                print(f'\\n\\nMaking xy chart for {tag = }\\n')\n                panel = gapi.Panel(\n                    targets=[\n                        gapi.Target(\n                            datasource=gapi.DataSource(),\n                            url='/'.join([server_path.strip('/'), dot_tag, 'Point2D']),\n                            uql=UQL_Point2D,\n                            refId='A',\n                        ),\n                        gapi.Target(\n                            datasource=gapi.DataSource(),\n                            url='/'.join([server_path.strip('/'), dot_tag, 'Trace2D']),\n                            uql=UQL_Trace2D,\n                            refId='B',\n                        )\n                    ],\n                    transformations=[\n                        gapi.Merge(),\n                        gapi.PartitionByValues.from_fields(\n                            fields='label',\n                            keep_fields=False,\n                            fields_as_labels=False,\n                        )\n                    ],\n                    type='xychart',\n                )\n                panel_dir.joinpath(underscore_tag + '_xy_panel.json').write_text(panel.model_dump_json(indent=4))\n                print(f'\\nFinished xy plot for {tag = }\\n')\n</code></pre>"},{"location":"reference/trendify/#trendify.DataProductCollection.process_single_tag_collection","title":"process_single_tag_collection  <code>classmethod</code>","text":"<pre><code>process_single_tag_collection(\n    dir_in: Path,\n    dir_out: Path,\n    make_tables: bool,\n    make_xy_plots: bool,\n    make_histograms: bool,\n    dpi: int,\n)\n</code></pre> <p>Processes collection of elements corresponding to a single tag. This method should be called on a directory containing jsons for which the products have been sorted.</p> <p>Parameters:</p> <ul> <li> <code>dir_in</code>               (<code>Path</code>)           \u2013            </li> <li> <code>dir_out</code>               (<code>Path</code>)           \u2013            </li> <li> <code>make_tables</code>               (<code>bool</code>)           \u2013            </li> <li> <code>make_xy_plots</code>               (<code>bool</code>)           \u2013            </li> <li> <code>make_histograms</code>               (<code>bool</code>)           \u2013            </li> <li> <code>dpi</code>               (<code>int</code>)           \u2013            </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>@classmethod\ndef process_single_tag_collection(\n        cls,\n        dir_in: Path,\n        dir_out: Path,\n        make_tables: bool,\n        make_xy_plots: bool,\n        make_histograms: bool,\n        dpi: int,\n    ):\n    \"\"\"\n    Processes collection of elements corresponding to a single tag.\n    This method should be called on a directory containing jsons for which the products have been\n    sorted.\n\n    Args:\n        dir_in (Path):\n        dir_out (Path):\n        make_tables (bool):\n        make_xy_plots (bool):\n        make_histograms (bool):\n        dpi (int):\n    \"\"\"\n\n    collection = cls.collect_from_all_jsons(dir_in)\n\n    if collection is not None:\n\n        [tag] = collection.get_tags()\n\n        if make_tables:\n\n            table_entries: List[TableEntry] = collection.get_products(tag=tag, object_type=TableEntry).elements\n\n            if table_entries:\n                print(f'\\n\\nMaking tables for {tag = }\\n')\n                TableBuilder.process_table_entries(\n                    tag=tag,\n                    table_entries=table_entries,\n                    out_dir=dir_out\n                )\n                print(f'\\nFinished tables for {tag = }\\n')\n\n        if make_xy_plots:\n\n            traces: List[Trace2D] = collection.get_products(tag=tag, object_type=Trace2D).elements\n            points: List[Point2D] = collection.get_products(tag=tag, object_type=Point2D).elements\n\n            if points or traces:\n                print(f'\\n\\nMaking xy plot for {tag = }\\n')\n                XYDataPlotter.handle_points_and_traces(\n                    tag=tag,\n                    points=points,\n                    traces=traces,\n                    dir_out=dir_out,\n                    dpi=dpi,\n                )\n                print(f'\\nFinished xy plot for {tag = }\\n')\n\n        if make_histograms:\n            histogram_entries: List[HistogramEntry] = collection.get_products(tag=tag, object_type=HistogramEntry).elements\n\n            if histogram_entries:\n                print(f'\\n\\nMaking histogram for {tag = }\\n')\n                Histogrammer.handle_histogram_entries(\n                    tag=tag,\n                    histogram_entries=histogram_entries,\n                    dir_out=dir_out,\n                    dpi=dpi\n                )\n                print(f'\\nFinished histogram for {tag = }\\n')\n</code></pre>"},{"location":"reference/trendify/#trendify.DataProductCollection.sort_by_tags","title":"sort_by_tags  <code>classmethod</code>","text":"<pre><code>sort_by_tags(dirs_in: List[Path], dir_out: Path)\n</code></pre> <p>Loads the data product JSON files from <code>dirs_in</code> sorts the products. Sorted products are written to smaller files in a nested directory structure under <code>dir_out</code>. The nested directory structure is generated accordint to the data tags. Resulting product files are named according to the directory from which they were originally loaded.</p> <p>Parameters:</p> <ul> <li> <code>dirs_in</code>               (<code>List[Path]</code>)           \u2013            <p>Directories from which the data product JSON files are to be loaded.</p> </li> <li> <code>dir_out</code>               (<code>Path</code>)           \u2013            <p>Directory to which the sorted data products will be written into a  nested folder structure generated according to the data tags.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>@classmethod\ndef sort_by_tags(cls, dirs_in: List[Path], dir_out: Path):\n    \"\"\"\n    Loads the data product JSON files from `dirs_in` sorts the products.\n    Sorted products are written to smaller files in a nested directory structure under `dir_out`.\n    The nested directory structure is generated accordint to the data tags.\n    Resulting product files are named according to the directory from which they were originally loaded.\n\n    Args:\n        dirs_in (List[Path]): Directories from which the data product JSON files are to be loaded.\n        dir_out (Path): Directory to which the sorted data products will be written into a \n            nested folder structure generated according to the data tags.\n    \"\"\"\n    dirs_in = list(dirs_in)\n    dirs_in.sort()\n    len_dirs = len(dirs_in)\n    for n, d in enumerate(dirs_in):\n        print(f'Collecting tagged data from dir {n}/{len_dirs}', end=f'\\r')\n        collection = DataProductCollection.model_validate_json(\n            d.joinpath(DATA_PRODUCTS_FNAME).read_text()\n        )\n        tags = collection.get_tags()\n        for tag in tags:\n            sub_collection = collection.get_products(tag=tag)\n            save_to = dir_out.joinpath(*atleast_1d(tag))\n            save_to.mkdir(parents=True, exist_ok=True)\n            save_to.joinpath(d.name).with_suffix('.json').write_text(sub_collection.model_dump_json(\n                indent=4\n            ))\n</code></pre>"},{"location":"reference/trendify/#trendify.DataProductCollection.union","title":"union  <code>classmethod</code>","text":"<pre><code>union(*collections: DataProductCollection)\n</code></pre> <p>Aggregates all of the products from multiple collections into a new larger collection.</p> <p>Parameters:</p> <ul> <li> <code>collections</code>               (<code>Tuple[DataProductCollection, ...]</code>, default:                   <code>()</code> )           \u2013            <p>Data product collections for which the products should be combined into a new collection.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Type[Self]</code>           \u2013            <p>A new data product collection containing all products from the provided <code>*collections</code>.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>@classmethod\ndef union(cls, *collections: DataProductCollection):\n    \"\"\"\n    Aggregates all of the products from multiple collections into a new larger collection.\n\n    Args:\n        collections (Tuple[DataProductCollection, ...]): Data product collections\n            for which the products should be combined into a new collection.\n\n    Returns:\n        (Type[Self]): A new data product collection containing all products from\n            the provided `*collections`.\n    \"\"\"\n    return cls(elements=list(flatten(chain(c.elements for c in collections))))\n</code></pre>"},{"location":"reference/trendify/#trendify.Format2D","title":"Format2D","text":"<p>               Bases: <code>HashableBase</code></p> <p>Formatting data for matplotlib figure and axes</p> Source code in <code>src/trendify/products.py</code> <pre><code>class Format2D(HashableBase):\n    \"\"\"\n    Formatting data for matplotlib figure and axes\n    \"\"\"\n    title_fig: Optional[str] = None\n    title_legend: Optional[str] = None\n    title_ax: Optional[str] = None\n    label_x: Optional[str] = None\n    label_y: Optional[str] = None\n    lim_x_min: float | str | None = None\n    lim_x_max: float | str | None = None\n    lim_y_min: float | str | None = None\n    lim_y_max: float | str | None = None\n\n    class Config:\n        \"\"\"\n        Forbids extra arguments\n        \"\"\"\n        extra = \"forbid\"  \n\n    @classmethod\n    def union_from_iterable(cls, format2ds: Iterable[Format2D]):\n        \"\"\"\n        Gets the most inclusive format object (in terms of limits) from a list of `Format2D` objects.\n        Requires that the label and title fields are identical for all format objects in the list.\n\n        Args:\n            format2ds (Iterable[Format2D]): Iterable of `Format2D` objects.\n\n        Returns:\n            (Format2D): Single format object from list of objects.\n\n        \"\"\"\n        formats = list(set(format2ds) - {None})\n        [title_fig] = set(i.title_fig for i in formats)\n        [title_legend] = set(i.title_legend for i in formats)\n        [title_ax] = set(i.title_ax for i in formats)\n        [label_x] = set(i.label_x for i in formats)\n        [label_y] = set(i.label_y for i in formats)\n        x_min = [i.lim_x_min for i in formats if i.lim_x_min is not None]\n        x_max = [i.lim_x_max for i in formats if i.lim_x_max is not None]\n        y_min = [i.lim_y_min for i in formats if i.lim_y_min is not None]\n        y_max = [i.lim_y_max for i in formats if i.lim_y_max is not None]\n        lim_x_min = np.min(x_min) if len(x_min) &gt; 0 else None\n        lim_x_max = np.max(x_max) if len(x_max) &gt; 0 else None\n        lim_y_min = np.min(y_min) if len(y_min) &gt; 0 else None\n        lim_y_max = np.max(y_max) if len(y_max) &gt; 0 else None\n\n        return cls(\n            title_fig=title_fig,\n            title_legend=title_legend,\n            title_ax=title_ax,\n            label_x=label_x,\n            label_y=label_y,\n            lim_x_min=lim_x_min,\n            lim_x_max=lim_x_max,\n            lim_y_min=lim_y_min,\n            lim_y_max=lim_y_max,\n        )\n</code></pre>"},{"location":"reference/trendify/#trendify.Format2D.Config","title":"Config","text":"<p>Forbids extra arguments</p> Source code in <code>src/trendify/products.py</code> <pre><code>class Config:\n    \"\"\"\n    Forbids extra arguments\n    \"\"\"\n    extra = \"forbid\"  \n</code></pre>"},{"location":"reference/trendify/#trendify.Format2D.union_from_iterable","title":"union_from_iterable  <code>classmethod</code>","text":"<pre><code>union_from_iterable(format2ds: Iterable[Format2D])\n</code></pre> <p>Gets the most inclusive format object (in terms of limits) from a list of <code>Format2D</code> objects. Requires that the label and title fields are identical for all format objects in the list.</p> <p>Parameters:</p> <ul> <li> <code>format2ds</code>               (<code>Iterable[Format2D]</code>)           \u2013            <p>Iterable of <code>Format2D</code> objects.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Format2D</code>           \u2013            <p>Single format object from list of objects.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>@classmethod\ndef union_from_iterable(cls, format2ds: Iterable[Format2D]):\n    \"\"\"\n    Gets the most inclusive format object (in terms of limits) from a list of `Format2D` objects.\n    Requires that the label and title fields are identical for all format objects in the list.\n\n    Args:\n        format2ds (Iterable[Format2D]): Iterable of `Format2D` objects.\n\n    Returns:\n        (Format2D): Single format object from list of objects.\n\n    \"\"\"\n    formats = list(set(format2ds) - {None})\n    [title_fig] = set(i.title_fig for i in formats)\n    [title_legend] = set(i.title_legend for i in formats)\n    [title_ax] = set(i.title_ax for i in formats)\n    [label_x] = set(i.label_x for i in formats)\n    [label_y] = set(i.label_y for i in formats)\n    x_min = [i.lim_x_min for i in formats if i.lim_x_min is not None]\n    x_max = [i.lim_x_max for i in formats if i.lim_x_max is not None]\n    y_min = [i.lim_y_min for i in formats if i.lim_y_min is not None]\n    y_max = [i.lim_y_max for i in formats if i.lim_y_max is not None]\n    lim_x_min = np.min(x_min) if len(x_min) &gt; 0 else None\n    lim_x_max = np.max(x_max) if len(x_max) &gt; 0 else None\n    lim_y_min = np.min(y_min) if len(y_min) &gt; 0 else None\n    lim_y_max = np.max(y_max) if len(y_max) &gt; 0 else None\n\n    return cls(\n        title_fig=title_fig,\n        title_legend=title_legend,\n        title_ax=title_ax,\n        label_x=label_x,\n        label_y=label_y,\n        lim_x_min=lim_x_min,\n        lim_x_max=lim_x_max,\n        lim_y_min=lim_y_min,\n        lim_y_max=lim_y_max,\n    )\n</code></pre>"},{"location":"reference/trendify/#trendify.HistogramEntry","title":"HistogramEntry","text":"<p>               Bases: <code>DataProduct</code></p> <p>Use this class to specify a value to be collected into a matplotlib histogram.</p> <p>Attributes:</p> <ul> <li> <code>product_type</code>               (<code>Literal['Trace2D']</code>)           \u2013            <p>Name of class type to be used as a constructor.</p> </li> <li> <code>value</code>               (<code>float | str</code>)           \u2013            <p>Value to be binned</p> </li> <li> <code>tags</code>               (<code>Tags</code>)           \u2013            <p>Hashable tags used to sort data products</p> </li> <li> <code>style</code>               (<code>HistogramStyle</code>)           \u2013            <p>Style of histogram display</p> </li> <li> <code>format2d</code>               (<code>Format2D</code>)           \u2013            <p>Format to apply to single axis figure</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>class HistogramEntry(DataProduct):\n    \"\"\"\n    Use this class to specify a value to be collected into a matplotlib histogram.\n\n    Attributes:\n        product_type (Literal['Trace2D']): Name of class type to be used as a constructor.\n        value (float | str): Value to be binned\n        tags (Tags): Hashable tags used to sort data products\n        style (HistogramStyle): Style of histogram display\n        format2d (Format2D): Format to apply to single axis figure\n    \"\"\"\n    product_type: Literal['HistogramEntry'] = 'HistogramEntry'\n    value: float | str\n    tags: Tags\n    style: HistogramStyle\n    format2d: Format2D\n\n    class Config:\n        \"\"\"\n        Forbids extra attributes\n        \"\"\"\n        extra = \"forbid\"\n</code></pre>"},{"location":"reference/trendify/#trendify.HistogramEntry.Config","title":"Config","text":"<p>Forbids extra attributes</p> Source code in <code>src/trendify/products.py</code> <pre><code>class Config:\n    \"\"\"\n    Forbids extra attributes\n    \"\"\"\n    extra = \"forbid\"\n</code></pre>"},{"location":"reference/trendify/#trendify.HistogramStyle","title":"HistogramStyle","text":"<p>               Bases: <code>HashableBase</code></p> <p>Label and style data for generating histogram bars</p> <p>Attributes:</p> <ul> <li> <code>color</code>               (<code>str</code>)           \u2013            <p>Color of bars</p> </li> <li> <code>label</code>               (<code>str | None</code>)           \u2013            <p>Legend entry</p> </li> <li> <code>histtype</code>               (<code>str</code>)           \u2013            <p>Histogram type corresponding to matplotlib argument of same name</p> </li> <li> <code>alpha_edge</code>               (<code>float</code>)           \u2013            <p>Opacity of bar edge</p> </li> <li> <code>alpha_face</code>               (<code>float</code>)           \u2013            <p>Opacity of bar face</p> </li> <li> <code>linewidth</code>               (<code>float</code>)           \u2013            <p>Line width of bar outline</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>class HistogramStyle(HashableBase):\n    \"\"\"\n    Label and style data for generating histogram bars\n\n    Attributes:\n        color (str): Color of bars\n        label (str|None): Legend entry\n        histtype (str): Histogram type corresponding to matplotlib argument of same name\n        alpha_edge (float): Opacity of bar edge\n        alpha_face (float): Opacity of bar face\n        linewidth (float): Line width of bar outline\n    \"\"\"\n    color: str = 'k'\n    label: str | None = None\n    histtype: str = 'stepfilled'\n    alpha_edge: float = 1\n    alpha_face: float = 0.3\n    linewidth: float = 2\n\n    def as_plot_kwargs(self):\n        \"\"\"\n        Returns:\n            (dict): kwargs for matplotlib `hist` method\n        \"\"\"\n        return {\n            'facecolor': (self.color, self.alpha_face),\n            'edgecolor': (self.color, self.alpha_edge),\n            'linewidth': self.linewidth,\n            'label': self.label,\n            'histtype': self.histtype\n        }\n</code></pre>"},{"location":"reference/trendify/#trendify.HistogramStyle.as_plot_kwargs","title":"as_plot_kwargs","text":"<pre><code>as_plot_kwargs()\n</code></pre> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>kwargs for matplotlib <code>hist</code> method</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def as_plot_kwargs(self):\n    \"\"\"\n    Returns:\n        (dict): kwargs for matplotlib `hist` method\n    \"\"\"\n    return {\n        'facecolor': (self.color, self.alpha_face),\n        'edgecolor': (self.color, self.alpha_edge),\n        'linewidth': self.linewidth,\n        'label': self.label,\n        'histtype': self.histtype\n    }\n</code></pre>"},{"location":"reference/trendify/#trendify.Marker","title":"Marker","text":"<p>               Bases: <code>HashableBase</code></p> <p>Defines marker for scattering to matplotlib</p> <p>Attributes:</p> <ul> <li> <code>color</code>               (<code>str</code>)           \u2013            <p>Color of line</p> </li> <li> <code>size</code>               (<code>float</code>)           \u2013            <p>Line width</p> </li> <li> <code>alpha</code>               (<code>float</code>)           \u2013            <p>Opacity from 0 to 1 (inclusive)</p> </li> <li> <code>zorder</code>               (<code>float</code>)           \u2013            <p>Prioritization </p> </li> <li> <code>label</code>               (<code>Union[str, None]</code>)           \u2013            <p>Legend label</p> </li> <li> <code>symbol</code>               (<code>str</code>)           \u2013            <p>Matplotlib symbol string</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>class Marker(HashableBase):\n    \"\"\"\n    Defines marker for scattering to matplotlib\n\n    Attributes:\n        color (str): Color of line\n        size (float): Line width\n        alpha (float): Opacity from 0 to 1 (inclusive)\n        zorder (float): Prioritization \n        label (Union[str, None]): Legend label\n        symbol (str): Matplotlib symbol string\n    \"\"\"\n    color: str = 'k'\n    size: float = 5\n    alpha: float = 1\n    zorder: float = 0\n    label: Union[str, None] = None\n    symbol: str = '.'\n\n    @classmethod\n    def from_pen(\n            cls,\n            pen: Pen,\n            symbol: str = '.',\n        ):\n        \"\"\"\n        Converts Pen to marker with the option to specify a symbol\n        \"\"\"\n        return cls(symbol=symbol, **pen.model_dump())\n\n    class Config:\n        \"\"\"\n        Forbids extra attributes\n        \"\"\"\n        extra = \"forbid\"  \n\n    def as_scatter_plot_kwargs(self):\n        \"\"\"\n        Returns:\n            (dict): dictionary of `kwargs` for [matplotlib scatter][matplotlib.axes.Axes.scatter]\n        \"\"\"\n        return {\n            'marker': self.symbol,\n            'c': self.color,\n            's': self.size,\n            'alpha': self.alpha,\n            'zorder': self.zorder,\n            'label': self.label,\n            'marker': self.symbol,\n        }\n</code></pre>"},{"location":"reference/trendify/#trendify.Marker.Config","title":"Config","text":"<p>Forbids extra attributes</p> Source code in <code>src/trendify/products.py</code> <pre><code>class Config:\n    \"\"\"\n    Forbids extra attributes\n    \"\"\"\n    extra = \"forbid\"  \n</code></pre>"},{"location":"reference/trendify/#trendify.Marker.as_scatter_plot_kwargs","title":"as_scatter_plot_kwargs","text":"<pre><code>as_scatter_plot_kwargs()\n</code></pre> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>dictionary of <code>kwargs</code> for matplotlib scatter</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def as_scatter_plot_kwargs(self):\n    \"\"\"\n    Returns:\n        (dict): dictionary of `kwargs` for [matplotlib scatter][matplotlib.axes.Axes.scatter]\n    \"\"\"\n    return {\n        'marker': self.symbol,\n        'c': self.color,\n        's': self.size,\n        'alpha': self.alpha,\n        'zorder': self.zorder,\n        'label': self.label,\n        'marker': self.symbol,\n    }\n</code></pre>"},{"location":"reference/trendify/#trendify.Marker.from_pen","title":"from_pen  <code>classmethod</code>","text":"<pre><code>from_pen(pen: Pen, symbol: str = '.')\n</code></pre> <p>Converts Pen to marker with the option to specify a symbol</p> Source code in <code>src/trendify/products.py</code> <pre><code>@classmethod\ndef from_pen(\n        cls,\n        pen: Pen,\n        symbol: str = '.',\n    ):\n    \"\"\"\n    Converts Pen to marker with the option to specify a symbol\n    \"\"\"\n    return cls(symbol=symbol, **pen.model_dump())\n</code></pre>"},{"location":"reference/trendify/#trendify.Pen","title":"Pen","text":"<p>               Bases: <code>HashableBase</code></p> <p>Defines the pen drawing to matplotlib.</p> <p>Attributes:</p> <ul> <li> <code>color</code>               (<code>str</code>)           \u2013            <p>Color of line</p> </li> <li> <code>size</code>               (<code>float</code>)           \u2013            <p>Line width</p> </li> <li> <code>alpha</code>               (<code>float</code>)           \u2013            <p>Opacity from 0 to 1 (inclusive)</p> </li> <li> <code>zorder</code>               (<code>float</code>)           \u2013            <p>Prioritization </p> </li> <li> <code>label</code>               (<code>Union[str, None]</code>)           \u2013            <p>Legend label</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>class Pen(HashableBase):\n    \"\"\"\n    Defines the pen drawing to matplotlib.\n\n    Attributes:\n        color (str): Color of line\n        size (float): Line width\n        alpha (float): Opacity from 0 to 1 (inclusive)\n        zorder (float): Prioritization \n        label (Union[str, None]): Legend label\n    \"\"\"\n    color: str = 'k'\n    size: float = 1\n    alpha: float = 1\n    zorder: float = 0\n    label: Union[str, None] = None\n\n    class Config:\n        \"\"\"\n        Forbids extra attributes\n        \"\"\"\n        extra = \"forbid\"  \n\n    def as_scatter_plot_kwargs(self):\n        \"\"\"\n        Returns kwargs dictionary for passing to [matplotlib plot][matplotlib.axes.Axes.plot] method\n        \"\"\"\n        return {\n            'color': self.color,\n            'linewidth': self.size,\n            'alpha': self.alpha,\n            'zorder': self.zorder,\n            'label': self.label,\n        }\n</code></pre>"},{"location":"reference/trendify/#trendify.Pen.Config","title":"Config","text":"<p>Forbids extra attributes</p> Source code in <code>src/trendify/products.py</code> <pre><code>class Config:\n    \"\"\"\n    Forbids extra attributes\n    \"\"\"\n    extra = \"forbid\"  \n</code></pre>"},{"location":"reference/trendify/#trendify.Pen.as_scatter_plot_kwargs","title":"as_scatter_plot_kwargs","text":"<pre><code>as_scatter_plot_kwargs()\n</code></pre> <p>Returns kwargs dictionary for passing to matplotlib plot method</p> Source code in <code>src/trendify/products.py</code> <pre><code>def as_scatter_plot_kwargs(self):\n    \"\"\"\n    Returns kwargs dictionary for passing to [matplotlib plot][matplotlib.axes.Axes.plot] method\n    \"\"\"\n    return {\n        'color': self.color,\n        'linewidth': self.size,\n        'alpha': self.alpha,\n        'zorder': self.zorder,\n        'label': self.label,\n    }\n</code></pre>"},{"location":"reference/trendify/#trendify.Point2D","title":"Point2D","text":"<p>               Bases: <code>XYData</code></p> <p>Defines a point to be scattered onto xy plot.</p> <p>Attributes:</p> <ul> <li> <code>product_type</code>               (<code>Literal['Trace2D']</code>)           \u2013            <p>Name of class type to be used as a constructor.</p> </li> <li> <code>points</code>               (<code>List[Point2D]</code>)           \u2013            <p>List of points.  Usually the points would have null values  for <code>marker</code> and <code>format2d</code> fields to save space.</p> </li> <li> <code>marker</code>               (<code>Marker</code>)           \u2013            <p>Style and label information for scattering points to matplotlib axes. Only the label information is used in Grafana. Eventually style information will be used in grafana.</p> </li> <li> <code>format2d</code>               (<code>Format2D</code>)           \u2013            <p>Formatting information for matplotlib figure.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>class Point2D(XYData):\n    \"\"\"\n    Defines a point to be scattered onto xy plot.\n\n    Attributes:\n        product_type (Literal['Trace2D']): Name of class type to be used as a constructor.\n        points (List[Point2D]): List of points.  Usually the points would have null values \n            for `marker` and `format2d` fields to save space.\n        marker (Marker): Style and label information for scattering points to matplotlib axes.\n            Only the label information is used in Grafana.\n            Eventually style information will be used in grafana.\n        format2d (Format2D): Formatting information for matplotlib figure.\n    \"\"\"\n    product_type: Literal['Point2D'] = 'Point2D'\n    x: float | str\n    y: float | str\n    marker: Marker | None = Marker()\n    format2d: Format2D | None = Format2D()\n\n    class Config:\n        \"\"\"\n        Forbids extra attributes\n        \"\"\"\n        extra = \"forbid\"\n</code></pre>"},{"location":"reference/trendify/#trendify.Point2D.Config","title":"Config","text":"<p>Forbids extra attributes</p> Source code in <code>src/trendify/products.py</code> <pre><code>class Config:\n    \"\"\"\n    Forbids extra attributes\n    \"\"\"\n    extra = \"forbid\"\n</code></pre>"},{"location":"reference/trendify/#trendify.TableEntry","title":"TableEntry","text":"<p>               Bases: <code>DataProduct</code></p> <p>Defines an entry to be collected into a table.</p> <p>Collected table entries will be printed in three forms when possible: melted, pivot (when possible), and stats (on pivot columns, when possible).</p> <p>Attributes:</p> <ul> <li> <code>product_type</code>               (<code>Literal['Trace2D']</code>)           \u2013            <p>Name of class type to be used as a constructor.</p> </li> <li> <code>row</code>               (<code>float | str</code>)           \u2013            <p>Value to be binned</p> </li> <li> <code>col</code>               (<code>float | str</code>)           \u2013            <p>Hashable tags used to sort data products</p> </li> <li> <code>value</code>               (<code>float | str</code>)           \u2013            <p>Style of histogram display</p> </li> <li> <code>unit</code>               (<code>str | None</code>)           \u2013            <p>Format to apply to single axis figure</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>class TableEntry(DataProduct):\n    \"\"\"\n    Defines an entry to be collected into a table.\n\n    Collected table entries will be printed in three forms when possible: melted, pivot (when possible), and stats (on pivot columns, when possible).\n\n    Attributes:\n        product_type (Literal['Trace2D']): Name of class type to be used as a constructor.\n        row (float | str): Value to be binned\n        col (float | str): Hashable tags used to sort data products\n        value (float | str): Style of histogram display\n        unit (str | None): Format to apply to single axis figure\n    \"\"\"\n    product_type: Literal['TableEntry'] = 'TableEntry'\n    row: float | str\n    col: float | str\n    value: float | str | bool\n    unit: str | None\n\n    class Config:\n        extra = \"forbid\"\n\n    def get_entry_dict(self):\n        \"\"\"\n        Returns a dictionary of entries to be used in creating a table.\n\n        Returns:\n            (dict[str, str | float]): Dictionary of entries to be used in creating a melted [DataFrame][pandas.DataFrame]\n        \"\"\"\n        return {'row': self.row, 'col': self.col, 'value': self.value, 'unit': self.unit}\n\n    @classmethod\n    def pivot_table(cls, melted: pd.DataFrame):\n        \"\"\"\n        Attempts to pivot melted row, col, value DataFrame into a wide form DataFrame\n\n        Args:\n            melted (pd.DataFrame): Melted data frame having columns named `'row'`, `'col'`, `'value'`.\n\n        Returns:\n            (pd.DataFrame | None): pivoted DataFrame if pivot works else `None`. Pivot operation fails if \n                row or column index pairs are repeated.\n        \"\"\"\n        try:\n            result = melted.pivot(index='row', columns='col', values='value')\n        except ValueError:\n            result = None\n        return result\n\n    @classmethod\n    def load_and_pivot(cls, path: Path):\n        \"\"\"\n        Loads melted table from csv and pivots to wide form.\n        csv should have columns named `'row'`, `'col'`, and `'value'`.\n\n        Args:\n            path (Path): path to CSV file\n\n        Returns:\n            (pd.DataFrame | None): Pivoted data frame or elese `None` if pivot operation fails.\n        \"\"\"\n        return cls.pivot_table(melted=pd.read_csv(path))\n</code></pre>"},{"location":"reference/trendify/#trendify.TableEntry.get_entry_dict","title":"get_entry_dict","text":"<pre><code>get_entry_dict()\n</code></pre> <p>Returns a dictionary of entries to be used in creating a table.</p> <p>Returns:</p> <ul> <li> <code>dict[str, str | float]</code>           \u2013            <p>Dictionary of entries to be used in creating a melted DataFrame</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def get_entry_dict(self):\n    \"\"\"\n    Returns a dictionary of entries to be used in creating a table.\n\n    Returns:\n        (dict[str, str | float]): Dictionary of entries to be used in creating a melted [DataFrame][pandas.DataFrame]\n    \"\"\"\n    return {'row': self.row, 'col': self.col, 'value': self.value, 'unit': self.unit}\n</code></pre>"},{"location":"reference/trendify/#trendify.TableEntry.load_and_pivot","title":"load_and_pivot  <code>classmethod</code>","text":"<pre><code>load_and_pivot(path: Path)\n</code></pre> <p>Loads melted table from csv and pivots to wide form. csv should have columns named <code>'row'</code>, <code>'col'</code>, and <code>'value'</code>.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>Path</code>)           \u2013            <p>path to CSV file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame | None</code>           \u2013            <p>Pivoted data frame or elese <code>None</code> if pivot operation fails.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>@classmethod\ndef load_and_pivot(cls, path: Path):\n    \"\"\"\n    Loads melted table from csv and pivots to wide form.\n    csv should have columns named `'row'`, `'col'`, and `'value'`.\n\n    Args:\n        path (Path): path to CSV file\n\n    Returns:\n        (pd.DataFrame | None): Pivoted data frame or elese `None` if pivot operation fails.\n    \"\"\"\n    return cls.pivot_table(melted=pd.read_csv(path))\n</code></pre>"},{"location":"reference/trendify/#trendify.TableEntry.pivot_table","title":"pivot_table  <code>classmethod</code>","text":"<pre><code>pivot_table(melted: DataFrame)\n</code></pre> <p>Attempts to pivot melted row, col, value DataFrame into a wide form DataFrame</p> <p>Parameters:</p> <ul> <li> <code>melted</code>               (<code>DataFrame</code>)           \u2013            <p>Melted data frame having columns named <code>'row'</code>, <code>'col'</code>, <code>'value'</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame | None</code>           \u2013            <p>pivoted DataFrame if pivot works else <code>None</code>. Pivot operation fails if  row or column index pairs are repeated.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>@classmethod\ndef pivot_table(cls, melted: pd.DataFrame):\n    \"\"\"\n    Attempts to pivot melted row, col, value DataFrame into a wide form DataFrame\n\n    Args:\n        melted (pd.DataFrame): Melted data frame having columns named `'row'`, `'col'`, `'value'`.\n\n    Returns:\n        (pd.DataFrame | None): pivoted DataFrame if pivot works else `None`. Pivot operation fails if \n            row or column index pairs are repeated.\n    \"\"\"\n    try:\n        result = melted.pivot(index='row', columns='col', values='value')\n    except ValueError:\n        result = None\n    return result\n</code></pre>"},{"location":"reference/trendify/#trendify.Trace2D","title":"Trace2D","text":"<p>               Bases: <code>XYData</code></p> <p>A collection of points comprising a trace. Use the Trace2D.from_xy constructor.</p> <p>Attributes:</p> <ul> <li> <code>product_type</code>               (<code>Literal['Trace2D']</code>)           \u2013            <p>Name of class type to be used as a constructor.</p> </li> <li> <code>points</code>               (<code>List[Point2D]</code>)           \u2013            <p>List of points.  Usually the points would have null values  for <code>marker</code> and <code>format2d</code> fields to save space.</p> </li> <li> <code>pen</code>               (<code>Pen</code>)           \u2013            <p>Style and label information for drawing to matplotlib axes. Only the label information is used in Grafana. Eventually style information will be used in grafana.</p> </li> <li> <code>format2d</code>               (<code>Format2D</code>)           \u2013            <p>Formatting information for matplotlib figure.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>class Trace2D(XYData):\n    \"\"\"\n    A collection of points comprising a trace.\n    Use the [Trace2D.from_xy][trendify.products.Trace2D.from_xy] constructor.\n\n    Attributes:\n        product_type (Literal['Trace2D']): Name of class type to be used as a constructor.\n        points (List[Point2D]): List of points.  Usually the points would have null values \n            for `marker` and `format2d` fields to save space.\n        pen (Pen): Style and label information for drawing to matplotlib axes.\n            Only the label information is used in Grafana.\n            Eventually style information will be used in grafana.\n        format2d (Format2D): Formatting information for matplotlib figure.\n    \"\"\"\n    product_type: Literal['Trace2D'] = 'Trace2D'\n    points: List[Point2D]\n    # x: NDArray[Shape[\"*\"], float]\n    # y: NDArray[Shape[\"*\"], float]\n    pen: Pen = Pen()\n    format2d: Format2D = Format2D()\n\n    class Config:\n        \"\"\"\n        Forbids extra attributes\n        \"\"\"\n        extra = \"forbid\"  \n\n    @property\n    def x(self):\n        \"\"\"\n        Returns an array of x values from `self.points`\n\n        Returns:\n            (NDArray[Shape[\"*\"], float]): array of x values from `self.points`\n        '\"\"\"\n        return np.array([p.x for p in self.points])\n\n    @property\n    def y(self):\n        \"\"\"\n        Returns an array of y values from `self.points`\n\n        Returns:\n            (NDArray[Shape[\"*\"], float]): array of y values from `self.points`\n        \"\"\"\n        return np.array([p.y for p in self.points])\n\n    def propagate_format2d_and_pen(self, marker_symbol='.') -&gt; None:\n        \"\"\"\n        Propagates format and style info to all `self.points` (in-place).\n        I thought this would  be useful for grafana before I learned better methods for propagating the data.\n        It still may end up being useful if my plotting method changes.  Keeping for potential future use case.\n\n        Args:\n            marker_symbol (str): Valid matplotlib marker symbol\n        \"\"\"\n        self.points = [\n            p.model_copy(\n                update={\n                    'tags': self.tags,\n                    'format2d': self.format2d,\n                    'marker': Marker.from_pen(self.pen, symbol=marker_symbol)\n                }\n            ) \n            for p \n            in self.points\n        ]\n\n    @classmethod\n    def from_xy(\n            cls,\n            tags: Tags,\n            x: NDArray[Shape[\"*\"], float],\n            y: NDArray[Shape[\"*\"], float],\n            pen: Pen = Pen(),\n            format2d: Format2D = Format2D(),\n        ):\n        \"\"\"\n        Creates a list of [Point2D][trendify.products.Point2D]s from xy data and returns a new [Trace2D][trendify.products.Trace2D] product.\n\n        Args:\n            tags (Tags): Hashable tags used to sort data products\n            x (NDArray[Shape[\"*\"], float]): x values\n            y (NDArray[Shape[\"*\"], float]): y values\n            pen (Pen): Style and label for trace\n            format2d (Format2D): format to apply to matplotlib\n        \"\"\"\n        return cls(\n            tags = tags,\n            points = [\n                Point2D(\n                    tags=[None],\n                    x=x_,\n                    y=y_,\n                    marker=None,\n                    format2d=None,\n                )\n                for x_, y_\n                in zip(x, y)\n            ],\n            pen=pen,\n            format2d=format2d,\n        )\n\n    def plot_to_ax(self, ax: plt.Axes):\n        \"\"\"\n        Plots xy data from trace to a matplotlib axes object.\n\n        Args:\n            ax (plt.Axes): axes to which xy data should be plotted\n        \"\"\"\n        ax.plot(self.x, self.y, **self.pen.as_scatter_plot_kwargs())\n</code></pre>"},{"location":"reference/trendify/#trendify.Trace2D.x","title":"x  <code>property</code>","text":"<pre><code>x\n</code></pre> <p>Returns an array of x values from <code>self.points</code></p> <p>Returns:</p> <ul> <li> <code>NDArray[Shape['*'], float]</code>           \u2013            <p>array of x values from <code>self.points</code></p> </li> </ul> <p>'</p>"},{"location":"reference/trendify/#trendify.Trace2D.y","title":"y  <code>property</code>","text":"<pre><code>y\n</code></pre> <p>Returns an array of y values from <code>self.points</code></p> <p>Returns:</p> <ul> <li> <code>NDArray[Shape['*'], float]</code>           \u2013            <p>array of y values from <code>self.points</code></p> </li> </ul>"},{"location":"reference/trendify/#trendify.Trace2D.Config","title":"Config","text":"<p>Forbids extra attributes</p> Source code in <code>src/trendify/products.py</code> <pre><code>class Config:\n    \"\"\"\n    Forbids extra attributes\n    \"\"\"\n    extra = \"forbid\"  \n</code></pre>"},{"location":"reference/trendify/#trendify.Trace2D.from_xy","title":"from_xy  <code>classmethod</code>","text":"<pre><code>from_xy(\n    tags: Tags,\n    x: NDArray[Shape[\"*\"], float],\n    y: NDArray[Shape[\"*\"], float],\n    pen: Pen = Pen(),\n    format2d: Format2D = Format2D(),\n)\n</code></pre> <p>Creates a list of Point2Ds from xy data and returns a new Trace2D product.</p> <p>Parameters:</p> <ul> <li> <code>tags</code>               (<code>Tags</code>)           \u2013            <p>Hashable tags used to sort data products</p> </li> <li> <code>x</code>               (<code>NDArray[Shape['*'], float]</code>)           \u2013            <p>x values</p> </li> <li> <code>y</code>               (<code>NDArray[Shape['*'], float]</code>)           \u2013            <p>y values</p> </li> <li> <code>pen</code>               (<code>Pen</code>, default:                   <code>Pen()</code> )           \u2013            <p>Style and label for trace</p> </li> <li> <code>format2d</code>               (<code>Format2D</code>, default:                   <code>Format2D()</code> )           \u2013            <p>format to apply to matplotlib</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>@classmethod\ndef from_xy(\n        cls,\n        tags: Tags,\n        x: NDArray[Shape[\"*\"], float],\n        y: NDArray[Shape[\"*\"], float],\n        pen: Pen = Pen(),\n        format2d: Format2D = Format2D(),\n    ):\n    \"\"\"\n    Creates a list of [Point2D][trendify.products.Point2D]s from xy data and returns a new [Trace2D][trendify.products.Trace2D] product.\n\n    Args:\n        tags (Tags): Hashable tags used to sort data products\n        x (NDArray[Shape[\"*\"], float]): x values\n        y (NDArray[Shape[\"*\"], float]): y values\n        pen (Pen): Style and label for trace\n        format2d (Format2D): format to apply to matplotlib\n    \"\"\"\n    return cls(\n        tags = tags,\n        points = [\n            Point2D(\n                tags=[None],\n                x=x_,\n                y=y_,\n                marker=None,\n                format2d=None,\n            )\n            for x_, y_\n            in zip(x, y)\n        ],\n        pen=pen,\n        format2d=format2d,\n    )\n</code></pre>"},{"location":"reference/trendify/#trendify.Trace2D.plot_to_ax","title":"plot_to_ax","text":"<pre><code>plot_to_ax(ax: Axes)\n</code></pre> <p>Plots xy data from trace to a matplotlib axes object.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Axes</code>)           \u2013            <p>axes to which xy data should be plotted</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def plot_to_ax(self, ax: plt.Axes):\n    \"\"\"\n    Plots xy data from trace to a matplotlib axes object.\n\n    Args:\n        ax (plt.Axes): axes to which xy data should be plotted\n    \"\"\"\n    ax.plot(self.x, self.y, **self.pen.as_scatter_plot_kwargs())\n</code></pre>"},{"location":"reference/trendify/#trendify.Trace2D.propagate_format2d_and_pen","title":"propagate_format2d_and_pen","text":"<pre><code>propagate_format2d_and_pen(marker_symbol='.') -&gt; None\n</code></pre> <p>Propagates format and style info to all <code>self.points</code> (in-place). I thought this would  be useful for grafana before I learned better methods for propagating the data. It still may end up being useful if my plotting method changes.  Keeping for potential future use case.</p> <p>Parameters:</p> <ul> <li> <code>marker_symbol</code>               (<code>str</code>, default:                   <code>'.'</code> )           \u2013            <p>Valid matplotlib marker symbol</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def propagate_format2d_and_pen(self, marker_symbol='.') -&gt; None:\n    \"\"\"\n    Propagates format and style info to all `self.points` (in-place).\n    I thought this would  be useful for grafana before I learned better methods for propagating the data.\n    It still may end up being useful if my plotting method changes.  Keeping for potential future use case.\n\n    Args:\n        marker_symbol (str): Valid matplotlib marker symbol\n    \"\"\"\n    self.points = [\n        p.model_copy(\n            update={\n                'tags': self.tags,\n                'format2d': self.format2d,\n                'marker': Marker.from_pen(self.pen, symbol=marker_symbol)\n            }\n        ) \n        for p \n        in self.points\n    ]\n</code></pre>"},{"location":"reference/trendify/#trendify.XYData","title":"XYData","text":"<p>               Bases: <code>DataProduct</code></p> <p>Base class for children of DataProduct to be plotted ax xy data on a 2D plot</p> Source code in <code>src/trendify/products.py</code> <pre><code>class XYData(DataProduct):\n    \"\"\"\n    Base class for children of DataProduct to be plotted ax xy data on a 2D plot\n    \"\"\"\n</code></pre>"},{"location":"reference/trendify/#trendify.get_data_products","title":"get_data_products","text":"<pre><code>get_data_products(\n    analysis: str = \"workdir.products\",\n    tag: str = \"trace_plots\",\n    product_type: str = \"DataProduct\",\n)\n</code></pre> Traces <p>parse-json | project \"elements\" | extend \"label\"=\"pen.label\" | mv-expand \"points\" | extend \"x\"=\"points.x\", \"y\"=\"points.y\" | project \"label\", \"x\", \"y\" | pivot sum(\"y\"), \"x\", \"label\" | project \"label\", \"x\", \"y\"</p> Source code in <code>src/trendify/server.py</code> <pre><code>@app.route('/data_products/&lt;analysis&gt;/&lt;tag&gt;')\n@app.route('/data_products/&lt;analysis&gt;/&lt;tag&gt;/')\n@app.route('/data_products/&lt;analysis&gt;/&lt;tag&gt;/&lt;product_type&gt;')\n@app.route('/data_products/&lt;analysis&gt;/&lt;tag&gt;/&lt;product_type&gt;/')\ndef get_data_products(\n        analysis: str = 'workdir.products',\n        tag: str = 'trace_plots',\n        product_type: str = 'DataProduct',\n    ):\n    \"\"\"\n    Example: Traces\n        parse-json\n        | project \"elements\"\n        | extend \"label\"=\"pen.label\"\n        | mv-expand \"points\"\n        | extend \"x\"=\"points.x\", \"y\"=\"points.y\"\n        | project \"label\", \"x\", \"y\"\n        | pivot sum(\"y\"), \"x\", \"label\"\n        | project \"label\", \"x\", \"y\"\n    \"\"\"\n    FAILED_RETURN_VALUE = None\n    query_return = FAILED_RETURN_VALUE\n    product_type = str(product_type)\n\n    match product_type:\n        case DataProduct.__name__:\n            filter_type = DataProduct\n        case XYData.__name__:\n            filter_type = XYData\n        case Trace2D.__name__:\n            filter_type = Trace2D,\n        case Point2D.__name__:\n            filter_type = Point2D\n        case TableEntry.__name__:\n            filter_type = TableEntry\n        case HistogramEntry.__name__:\n            filter_type = HistogramEntry\n        case _:\n            query_return = f'{product_type = } should be in {valid_types_names_list}'\n            return query_return\n\n    try:\n        analysis = str(analysis)\n        analysis_path_components = analysis.split('.') if '.' in analysis else [analysis]\n        tag = str(tag)\n        tag_path_components = tag.split('.') if '.' in tag else [tag]\n        collection_path_components = analysis_path_components + tag_path_components\n        data_dir = DATABASE_ROOT.joinpath(*tuple(analysis_path_components))\n        collection_dir = data_dir.joinpath(*tuple(tag_path_components))\n        assert not any(('.' in x) for x in collection_path_components)\n        assert collection_dir.is_relative_to(data_dir)\n    except AssertionError:\n        query_return = f'Do not try to access stuff outside of {data_dir = }'\n        print(f'Do not try to access stuff outside of {data_dir = }')\n        return query_return\n\n    data: DataProductCollection = DataProductCollection.collect_from_all_jsons(collection_dir)\n    if data is None:\n        return f'Did not find data product jsons in {collection_dir}'\n    formatted_tag = (\n        tag_path_components[0] \n        if len(tag_path_components) == 1 \n        else tuple(tag_path_components)\n    )\n    filtered_data = data.get_products(\n        tag=formatted_tag,\n        object_type=filter_type,\n    )\n    query_return = filtered_data.model_dump_json()\n    return query_return\n</code></pre>"},{"location":"reference/trendify/#trendify.make_grafana_dashboard","title":"make_grafana_dashboard","text":"<pre><code>make_grafana_dashboard(\n    sorted_products_dir: Path,\n    output_dir: Path,\n    n_procs: int = 1,\n)\n</code></pre> <p>Makes a JSON file to import to Grafana for displaying tagged data tables, histograms and XY plots.</p> <p>Parameters:</p> <ul> <li> <code>sorted_products_dir</code>               (<code>Path</code>)           \u2013            <p>Root directory into which products have been sorted by tag</p> </li> <li> <code>output_dir</code>               (<code>Path</code>)           \u2013            <p>Root directory into which Grafana dashboard and panal definitions will be written</p> </li> <li> <code>n_procs</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Number of parallel tasks used for processing data product tags</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def make_grafana_dashboard(\n        sorted_products_dir: Path,\n        output_dir: Path,\n        n_procs: int = 1,\n    ):\n    \"\"\"\n    Makes a JSON file to import to Grafana for displaying tagged data tables, histograms and XY plots.\n\n    Args:\n        sorted_products_dir (Path): Root directory into which products have been sorted by tag\n        output_dir (Path): Root directory into which Grafana dashboard and panal definitions will be written\n        n_procs (int): Number of parallel tasks used for processing data product tags\n    \"\"\"\n    print(f'\\n\\n\\nGenerating Grafana Dashboard JSON Spec in {output_dir} based on products in {sorted_products_dir}')\n    output_dir.mkdir(parents=True, exist_ok=True)\n\n    product_dirs = list(sorted_products_dir.glob('**/*/'))\n    panel_dir = output_dir.joinpath('panels')\n    map_callable(\n        DataProductCollection.make_grafana_panels,\n        product_dirs,\n        [panel_dir] * len(product_dirs),\n        n_procs=n_procs,\n    )\n    panels = [gapi.Panel.model_validate_json(p.read_text()) for p in panel_dir.glob('*.json')]\n    dashboard = gapi.Dashboard(panels=panels)\n    output_dir.joinpath('dashboard.json').write_text(dashboard.model_dump_json())\n    print('\\nFinished Generating Grafana Dashboard JSON Spec')\n</code></pre>"},{"location":"reference/trendify/#trendify.make_products","title":"make_products","text":"<pre><code>make_products(\n    product_generator: (\n        Callable[[Path], DataProductCollection] | None\n    ),\n    dirs: List[Path],\n    n_procs: int = 1,\n)\n</code></pre> <p>Maps <code>product_generator</code> over <code>dirs_in</code> to produce data product JSON files in those directories. Sorts the generated data products into a nested file structure starting from <code>dir_products</code>. Nested folders are generated for tags that are Tuples.  Sorted data files are named according to the directory from which they were loaded.</p> <p>Parameters:</p> <ul> <li> <code>product_generator</code>               (<code>Callable[[Path], ProductList] | None</code>)           \u2013            <p>A callable function that returns a list of data products given a working directory.</p> </li> <li> <code>dirs</code>               (<code>List[Path]</code>)           \u2013            <p>Directories over which to map the <code>product_generator</code></p> </li> <li> <code>n_procs</code>               (<code>int = 1</code>, default:                   <code>1</code> )           \u2013            <p>Number of processes to run in parallel.  If <code>n_procs==1</code>, directories will be processed sequentially (easier for debugging since the full traceback will be provided). If <code>n_procs &gt; 1</code>, a ProcessPoolExecutor will be used to load and process directories and/or tags in parallel.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def make_products(\n        product_generator: Callable[[Path], DataProductCollection] | None,\n        dirs: List[Path],\n        n_procs: int = 1,\n    ):\n    \"\"\"\n    Maps `product_generator` over `dirs_in` to produce data product JSON files in those directories.\n    Sorts the generated data products into a nested file structure starting from `dir_products`.\n    Nested folders are generated for tags that are Tuples.  Sorted data files are named according to the\n    directory from which they were loaded.\n\n    Args:\n        product_generator (Callable[[Path], ProductList] | None): A callable function that returns\n            a list of data products given a working directory.\n        dirs (List[Path]): Directories over which to map the `product_generator`\n        n_procs (int = 1): Number of processes to run in parallel.  If `n_procs==1`, directories will be\n            processed sequentially (easier for debugging since the full traceback will be provided).\n            If `n_procs &gt; 1`, a [ProcessPoolExecutor][concurrent.futures.ProcessPoolExecutor] will\n            be used to load and process directories and/or tags in parallel.\n    \"\"\"\n    sorted_dirs = get_sorted_dirs(dirs=dirs)\n\n    if product_generator is None:\n        print('No data product generator provided')\n    else:\n        print('\\n\\n\\nGenerating tagged DataProducts and writing to JSON files...\\n')\n        map_callable(\n            DataProductGenerator(processor=product_generator).process_and_save,\n            sorted_dirs,\n            n_procs=n_procs,\n        )\n        print('\\nFinished generating tagged DataProducts and writing to JSON files')\n</code></pre>"},{"location":"reference/trendify/#trendify.make_tables_and_figures","title":"make_tables_and_figures","text":"<pre><code>make_tables_and_figures(\n    products_dir: Path,\n    output_dir: Path,\n    dpi: int = 500,\n    n_procs: int = 1,\n    make_tables: bool = True,\n    make_xy_plots: bool = True,\n    make_histograms: bool = True,\n)\n</code></pre> <p>Makes CSV tables and creates plots (using matplotlib).</p> <p>Tags will be processed in parallel and output in nested directory structure under <code>output_dir</code>.</p> <p>Parameters:</p> <ul> <li> <code>products_dir</code>               (<code>Path</code>)           \u2013            <p>Directory to which the sorted data products will be written</p> </li> <li> <code>output_dir</code>               (<code>Path</code>)           \u2013            <p>Directory to which tables and matplotlib histograms and plots will be written if the appropriate boolean variables <code>make_tables</code>, <code>make_xy_plots</code>, <code>make_histograms</code> are true.</p> </li> <li> <code>n_procs</code>               (<code>int = 1</code>, default:                   <code>1</code> )           \u2013            <p>Number of processes to run in parallel.  If <code>n_procs==1</code>, directories will be processed sequentially (easier for debugging since the full traceback will be provided). If <code>n_procs &gt; 1</code>, a ProcessPoolExecutor will be used to load and process directories and/or tags in parallel.</p> </li> <li> <code>dpi</code>               (<code>int = 500</code>, default:                   <code>500</code> )           \u2013            <p>Resolution of output plots when using matplotlib  (for <code>make_xy_plots==True</code> and/or <code>make_histograms==True</code>)</p> </li> <li> <code>make_tables</code>               (<code>bool = True</code>, default:                   <code>True</code> )           \u2013            <p>Whether or not to collect the  <code>TableEntry</code> products and write them to CSV files (<code>&lt;tag&gt;_melted.csv</code> with <code>&lt;tag&gt;_pivot.csv</code> and <code>&lt;tag&gt;_stats.csv</code> when possible).</p> </li> <li> <code>make_xy_plots</code>               (<code>bool = True</code>, default:                   <code>True</code> )           \u2013            <p>Whether or not to plot the <code>XYData</code> products using matplotlib</p> </li> <li> <code>make_histograms</code>               (<code>bool = True</code>, default:                   <code>True</code> )           \u2013            <p>Whether or not to generate histograms of the  <code>HistogramEntry</code> products using matplotlib.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def make_tables_and_figures(\n        products_dir: Path,\n        output_dir: Path,\n        dpi: int = 500,\n        n_procs: int = 1,\n        make_tables: bool = True,\n        make_xy_plots: bool = True,\n        make_histograms: bool = True,\n    ):\n    \"\"\"\n    Makes CSV tables and creates plots (using matplotlib).\n\n    Tags will be processed in parallel and output in nested directory structure under `output_dir`.\n\n    Args:\n        products_dir (Path): Directory to which the sorted data products will be written\n        output_dir (Path): Directory to which tables and matplotlib histograms and plots will be written if\n            the appropriate boolean variables `make_tables`, `make_xy_plots`, `make_histograms` are true.\n        n_procs (int = 1): Number of processes to run in parallel.  If `n_procs==1`, directories will be\n            processed sequentially (easier for debugging since the full traceback will be provided).\n            If `n_procs &gt; 1`, a [ProcessPoolExecutor][concurrent.futures.ProcessPoolExecutor] will\n            be used to load and process directories and/or tags in parallel.\n        dpi (int = 500): Resolution of output plots when using matplotlib \n            (for `make_xy_plots==True` and/or `make_histograms==True`)\n        make_tables (bool = True): Whether or not to collect the \n            [`TableEntry`][trendify.products.TableEntry] products and write them\n            to CSV files (`&lt;tag&gt;_melted.csv` with `&lt;tag&gt;_pivot.csv` and `&lt;tag&gt;_stats.csv` when possible).\n        make_xy_plots (bool = True): Whether or not to plot the [`XYData`][trendify.products.XYData] products using matplotlib\n        make_histograms (bool = True): Whether or not to generate histograms of the \n            [`HistogramEntry`][trendify.products.HistogramEntry] products\n            using matplotlib.\n    \"\"\"\n    if make_tables or make_xy_plots or make_histograms:\n        product_dirs = list(products_dir.glob('**/*/'))\n        out_dirs = [output_dir]*len(product_dirs)\n        table_makes = [make_tables]*len(product_dirs)\n        xy_plot_makes = [make_xy_plots]*len(product_dirs)\n        histogram_makes = [make_histograms]*len(product_dirs)\n        dpis = [dpi]*len(product_dirs)\n        map_callable(\n            DataProductCollection.process_single_tag_collection,\n            product_dirs,\n            out_dirs,\n            table_makes,\n            xy_plot_makes,\n            histogram_makes,\n            dpis,\n            n_procs=n_procs,\n        )\n</code></pre>"},{"location":"reference/trendify/#trendify.sort_products","title":"sort_products","text":"<pre><code>sort_products(data_dirs: List[Path], output_dir: Path)\n</code></pre> <p>Loads the tagged data products from <code>data_dirs</code> and sorts them (by tag) into a nested folder structure rooted at <code>output_dir</code>.</p> <p>Parameters:</p> <ul> <li> <code>data_dirs</code>               (<code>List[Path]</code>)           \u2013            <p>Directories containing JSON data product files</p> </li> <li> <code>output_dir</code>               (<code>Path</code>)           \u2013            <p>Directory to which sorted products will be written</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def sort_products(\n        data_dirs: List[Path],\n        output_dir: Path,\n    ):\n    \"\"\"\n    Loads the tagged data products from `data_dirs` and sorts them (by tag) into a nested folder structure rooted at `output_dir`.\n\n    Args:\n        data_dirs (List[Path]): Directories containing JSON data product files\n        output_dir (Path): Directory to which sorted products will be written\n    \"\"\"\n    sorted_data_dirs = get_sorted_dirs(dirs=data_dirs)\n\n    print('\\n\\n\\nSorting data by tags')\n    output_dir.mkdir(parents=True, exist_ok=True)\n\n    DataProductCollection.sort_by_tags(\n        dirs_in=sorted_data_dirs,\n        dir_out=output_dir,\n    )\n    print('\\nFinished sorting by tags')\n</code></pre>"},{"location":"reference/trendify/cli/","title":"cli","text":""},{"location":"reference/trendify/cli/#trendify.cli","title":"trendify.cli","text":""},{"location":"reference/trendify/products/","title":"products","text":""},{"location":"reference/trendify/products/#trendify.products","title":"trendify.products","text":"<p>Module for generating, sorting, and plotting data products. This uses pydantic dataclasses for JSON serialization to avoid overloading system memory.</p> <p>Some important learning material for pydantic classes and JSON (de)serialization:</p> <ul> <li>Nested Pydantic Models</li> <li>Deserializing Child Classes</li> </ul> <p>Attributes:</p> <ul> <li> <code>DATA_PRODUCTS_FNAME</code>               (<code>str</code>)           \u2013            <p>Hard-coded json file name 'data_products.json'</p> </li> </ul>"},{"location":"reference/trendify/products/#trendify.products.DATA_PRODUCTS_FNAME","title":"DATA_PRODUCTS_FNAME  <code>module-attribute</code>","text":"<pre><code>DATA_PRODUCTS_FNAME = 'data_products.json'\n</code></pre> <p>Hard-coded file name for storing data products in batch-processed input directories.</p>"},{"location":"reference/trendify/products/#trendify.products.Tag","title":"Tag  <code>module-attribute</code>","text":"<pre><code>Tag = Union[Tuple[Hashable, ...], Hashable]\n</code></pre> <p>Determines what types can be used to define a tag</p>"},{"location":"reference/trendify/products/#trendify.products.Tags","title":"Tags  <code>module-attribute</code>","text":"<pre><code>Tags = List[Tag]\n</code></pre> <p>List of tags</p>"},{"location":"reference/trendify/products/#trendify.products.DataProduct","title":"DataProduct","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for data products to be generated and handled.</p> <p>Attributes:</p> <ul> <li> <code>product_type</code>               (<code>Hashable</code>)           \u2013            <p>Product type should be the same as the class name. The product type is used to search for products from a DataProductCollection.</p> </li> <li> <code>tags</code>               (<code>Tags</code>)           \u2013            <p>Tags to be used for sorting data.</p> </li> <li> <code>metadata</code>               (<code>dict[str, str]</code>)           \u2013            <p>A dictionary of metadata to be used as a tool tip for mousover in grafana</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>class DataProduct(BaseModel):\n    \"\"\"\n    Base class for data products to be generated and handled.\n\n    Attributes:\n        product_type (Hashable): Product type should be the same as the class name.\n            The product type is used to search for products from a [DataProductCollection][trendify.products.DataProductCollection].\n        tags (Tags): Tags to be used for sorting data.\n        metadata (dict[str, str]): A dictionary of metadata to be used as a tool tip for mousover in grafana\n    \"\"\"\n    product_type: Hashable\n    tags: Tags\n    metadata: dict[str, str] = {}\n\n    def __init_subclass__(cls, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Registers child subclasses to be able to parse them from JSON file using the \n        [deserialize_child_classes][trendify.products.DataProduct.deserialize_child_classes] method\n        \"\"\"\n        super().__init_subclass__(**kwargs)\n        _data_product_subclass_registry[cls.__name__] = cls    \n\n    class Config:\n        \"\"\"\n        Disallows additional attributes\n        \"\"\"\n        extra = \"allow\"  \n\n    def append_to_list(self, l: List):\n        \"\"\"\n        Appends self to list.\n\n        Args:\n            l (List): list to which `self` will be appended\n\n        Returns:\n            (Self): returns instance of `self`\n        \"\"\"\n        l.append(self)\n        return self\n\n    @classmethod\n    def deserialize_child_classes(cls, key: str, **kwargs):\n        \"\"\"\n        Loads json data to pydandic dataclass of whatever DataProduct child time is appropriate\n\n        Args:\n            key (str): json key\n            kwargs (dict): json entries stored under given key\n        \"\"\"\n        type_key = 'product_type'\n        elements = kwargs.get(key, None)\n        if elements:\n            for index in range(len(kwargs[key])):\n                current_duck = kwargs[key][index]\n                if isinstance(current_duck, dict):\n                    item_duck_type = current_duck[type_key]\n                    for _, subclass in _data_product_subclass_registry.items():\n                        registery_duck_type = subclass.__fields__[type_key].default\n                        if item_duck_type == registery_duck_type:\n                            current_duck = subclass(**current_duck) \n                            break\n                    kwargs[key][index] = current_duck\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.DataProduct.Config","title":"Config","text":"<p>Disallows additional attributes</p> Source code in <code>src/trendify/products.py</code> <pre><code>class Config:\n    \"\"\"\n    Disallows additional attributes\n    \"\"\"\n    extra = \"allow\"  \n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.DataProduct.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(**kwargs: Any) -&gt; None\n</code></pre> <p>Registers child subclasses to be able to parse them from JSON file using the  deserialize_child_classes method</p> Source code in <code>src/trendify/products.py</code> <pre><code>def __init_subclass__(cls, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Registers child subclasses to be able to parse them from JSON file using the \n    [deserialize_child_classes][trendify.products.DataProduct.deserialize_child_classes] method\n    \"\"\"\n    super().__init_subclass__(**kwargs)\n    _data_product_subclass_registry[cls.__name__] = cls    \n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.DataProduct.append_to_list","title":"append_to_list","text":"<pre><code>append_to_list(l: List)\n</code></pre> <p>Appends self to list.</p> <p>Parameters:</p> <ul> <li> <code>l</code>               (<code>List</code>)           \u2013            <p>list to which <code>self</code> will be appended</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>returns instance of <code>self</code></p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def append_to_list(self, l: List):\n    \"\"\"\n    Appends self to list.\n\n    Args:\n        l (List): list to which `self` will be appended\n\n    Returns:\n        (Self): returns instance of `self`\n    \"\"\"\n    l.append(self)\n    return self\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.DataProduct.deserialize_child_classes","title":"deserialize_child_classes  <code>classmethod</code>","text":"<pre><code>deserialize_child_classes(key: str, **kwargs)\n</code></pre> <p>Loads json data to pydandic dataclass of whatever DataProduct child time is appropriate</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>json key</p> </li> <li> <code>kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>json entries stored under given key</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>@classmethod\ndef deserialize_child_classes(cls, key: str, **kwargs):\n    \"\"\"\n    Loads json data to pydandic dataclass of whatever DataProduct child time is appropriate\n\n    Args:\n        key (str): json key\n        kwargs (dict): json entries stored under given key\n    \"\"\"\n    type_key = 'product_type'\n    elements = kwargs.get(key, None)\n    if elements:\n        for index in range(len(kwargs[key])):\n            current_duck = kwargs[key][index]\n            if isinstance(current_duck, dict):\n                item_duck_type = current_duck[type_key]\n                for _, subclass in _data_product_subclass_registry.items():\n                    registery_duck_type = subclass.__fields__[type_key].default\n                    if item_duck_type == registery_duck_type:\n                        current_duck = subclass(**current_duck) \n                        break\n                kwargs[key][index] = current_duck\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.DataProductCollection","title":"DataProductCollection","text":"<p>               Bases: <code>BaseModel</code></p> <p>A collection of data products.</p> <p>Use this class to serialize data products to JSON, de-serialized them from JSON, filter the products, etc.</p> <p>Attributes:</p> <ul> <li> <code>elements</code>               (<code>ProductList</code>)           \u2013            <p>A list of data products.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>class DataProductCollection(BaseModel):\n    \"\"\"\n    A collection of data products.\n\n    Use this class to serialize data products to JSON, de-serialized them from JSON, filter the products, etc.\n\n    Attributes:\n        elements (ProductList): A list of data products.\n    \"\"\"\n    elements: ProductList | None = None\n\n    def __init__(self, **kwargs):\n        DataProduct.deserialize_child_classes(key='elements', **kwargs)                \n        super().__init__(**kwargs)\n\n    @classmethod\n    def from_iterable(cls, *products: Tuple[ProductList, ...]):\n        \"\"\"\n        Returns a new instance containing all of the products provided in the `*products` argument.\n\n        Args:\n            products (Tuple[ProductList, ...]): Lists of data products to combine into a collection\n\n        Returns:\n            (cls): A data product collection containing all of the provided products in the `*products` argument.\n        \"\"\"\n        return cls(elements=list(flatten(products)))\n\n    def get_tags(self, data_product_type: Type[DataProduct] | None = None) -&gt; set:\n        \"\"\"\n        Gets the tags related to a given type of `DataProduct`.  Parent classes will match all child class types.\n\n        Args:\n            data_product_type (Type[DataProduct] | None): type for which you want to get the list of tags\n\n        Returns:\n            (set): set of tags applying to the given `data_product_type`.\n        \"\"\"\n        tags = []\n        for e in flatten(self.elements):\n            if data_product_type is None or isinstance(e, data_product_type):\n                for t in e.tags:\n                    tags.append(t)\n        return set(tags)\n\n    def add_products(self, *products: DataProduct):\n        \"\"\"\n        Args:\n            products (Tuple[DataProduct|ProductList, ...]): Products or lists of products to be\n                appended to collection elements.  \n        \"\"\"\n        self.elements.extend(flatten(products))\n\n    # def convert_traces_to_points(self):\n    #     constructor = type(self)\n    #     unchanged_elements = self.drop_products(object_type=Trace2D).elements\n    #     traces: List[Trace2D] = self.get_products(object_type=Trace2D).elements\n    #     trace_points = [t.propagate_format2d_and_pen for t in traces]\n    #     return constructor(elements=unchanged_elements)\n\n    # @classmethod\n    # def get_tags_from_file(cls, subdir: Path):\n    #     \"\"\"\n    #     DEPRICATED\n\n    #     Reads file and returns the tags in each type of tag set.\n\n    #     Returns:\n    #         (TagSets): a data class holding the tags of each type in set objects.\n    #     \"\"\"\n    #     collection = DataProductCollection.model_validate_json(subdir.joinpath(DATA_PRODUCTS_FNAME).read_text())\n    #     tags = TagSets(\n    #         XYData=collection.get_tags(XYData), \n    #         TableEntry=collection.get_tags(TableEntry),\n    #         HistogramEntry=collection.get_tags(HistogramEntry),\n    #     )\n    #     return tags\n\n    def drop_products(self, tag: Hashable | None = None, object_type: Type[R] | None = None) -&gt; Self[R]:\n        \"\"\"\n        Removes products matching `tag` and/or `object_type` from collection elements.\n\n        Args:\n            tag (Tag | None): Tag for which data products should be dropped\n            object_type (Type | None): Type of data product to drop\n\n        Returns:\n            (DataProductCollection): A new collection from which matching elements have been dropped.\n        \"\"\"\n        match_key = tag is None, object_type is None\n        match match_key:\n            case (True, True):\n                return type(self)(elements=self.elements)\n            case (True, False):\n                return type(self)(elements=[e for e in self.elements if not isinstance(e, object_type)])\n            case (False, True):\n                return type(self)(elements=[e for e in self.elements if not tag in e.tags])\n            case (False, False):\n                return type(self)(elements=[e for e in self.elements if not (tag in e.tags and isinstance(e, object_type))])\n            case _:\n                raise ValueError('Something is wrong with match statement')\n\n    def get_products(self, tag: Hashable | None = None, object_type: Type[R] | None = None) -&gt; Self[R]:\n        \"\"\"\n        Returns a new collection containing products matching `tag` and/or `object_type`.\n        Both `tag` and `object_type` default to `None` which matches all products.\n\n        Args:\n            tag (Tag | None): Tag of data products to be kept.  `None` matches all products.\n            object_type (Type | None): Type of data product to keep.  `None` matches all products.\n\n        Returns:\n            (DataProductCollection): A new collection containing matching elements.\n        \"\"\"\n        match_key = tag is None, object_type is None\n        match match_key:\n            case (True, True):\n                return type(self)(elements=self.elements)\n            case (True, False):\n                return type(self)(elements=[e for e in self.elements if isinstance(e, object_type)])\n            case (False, True):\n                return type(self)(elements=[e for e in self.elements if tag in e.tags])\n            case (False, False):\n                return type(self)(elements=[e for e in self.elements if tag in e.tags and isinstance(e, object_type)])\n            case _:\n                raise ValueError('Something is wrong with match statement')\n\n    @classmethod\n    def union(cls, *collections: DataProductCollection):\n        \"\"\"\n        Aggregates all of the products from multiple collections into a new larger collection.\n\n        Args:\n            collections (Tuple[DataProductCollection, ...]): Data product collections\n                for which the products should be combined into a new collection.\n\n        Returns:\n            (Type[Self]): A new data product collection containing all products from\n                the provided `*collections`.\n        \"\"\"\n        return cls(elements=list(flatten(chain(c.elements for c in collections))))\n\n    @classmethod\n    def collect_from_all_jsons(cls, *dirs: Path, recursive=False):\n        \"\"\"\n        Loads all products from JSONs in the given list of directories.  \n        If recursive is set to `True`, the directories will be searched recursively \n        (this could lead to double counting if you pass in subdirectories of a parent).\n\n        Args:\n            dirs (Tuple[Path, ...]): Directories from which to load data product JSON files.\n            recursive (bool): whether or not to search each of the provided directories recursively for \n                data product json files.\n\n        Returns:\n            (Type[Self] | None): Data product collection if JSON files are found.  \n                Otherwise, returns None if no product JSON files were found.\n        \"\"\"\n        if not recursive:\n            jsons: List[Path] = list(flatten(chain(list(d.glob('*.json')) for d in dirs)))\n        else:\n            jsons: List[Path] = list(flatten(chain(list(d.glob('**/*.json')) for d in dirs)))\n        if jsons:\n            return cls.union(\n                *tuple(\n                    [\n                        cls.model_validate_json(p.read_text())\n                        for p in jsons\n                    ]\n                )\n            )\n        else:\n            return None\n\n    @classmethod\n    def sort_by_tags(cls, dirs_in: List[Path], dir_out: Path):\n        \"\"\"\n        Loads the data product JSON files from `dirs_in` sorts the products.\n        Sorted products are written to smaller files in a nested directory structure under `dir_out`.\n        The nested directory structure is generated accordint to the data tags.\n        Resulting product files are named according to the directory from which they were originally loaded.\n\n        Args:\n            dirs_in (List[Path]): Directories from which the data product JSON files are to be loaded.\n            dir_out (Path): Directory to which the sorted data products will be written into a \n                nested folder structure generated according to the data tags.\n        \"\"\"\n        dirs_in = list(dirs_in)\n        dirs_in.sort()\n        len_dirs = len(dirs_in)\n        for n, d in enumerate(dirs_in):\n            print(f'Collecting tagged data from dir {n}/{len_dirs}', end=f'\\r')\n            collection = DataProductCollection.model_validate_json(\n                d.joinpath(DATA_PRODUCTS_FNAME).read_text()\n            )\n            tags = collection.get_tags()\n            for tag in tags:\n                sub_collection = collection.get_products(tag=tag)\n                save_to = dir_out.joinpath(*atleast_1d(tag))\n                save_to.mkdir(parents=True, exist_ok=True)\n                save_to.joinpath(d.name).with_suffix('.json').write_text(sub_collection.model_dump_json(\n                    indent=4\n                ))\n\n    @classmethod\n    def process_single_tag_collection(\n            cls,\n            dir_in: Path,\n            dir_out: Path,\n            make_tables: bool,\n            make_xy_plots: bool,\n            make_histograms: bool,\n            dpi: int,\n        ):\n        \"\"\"\n        Processes collection of elements corresponding to a single tag.\n        This method should be called on a directory containing jsons for which the products have been\n        sorted.\n\n        Args:\n            dir_in (Path):\n            dir_out (Path):\n            make_tables (bool):\n            make_xy_plots (bool):\n            make_histograms (bool):\n            dpi (int):\n        \"\"\"\n\n        collection = cls.collect_from_all_jsons(dir_in)\n\n        if collection is not None:\n\n            [tag] = collection.get_tags()\n\n            if make_tables:\n\n                table_entries: List[TableEntry] = collection.get_products(tag=tag, object_type=TableEntry).elements\n\n                if table_entries:\n                    print(f'\\n\\nMaking tables for {tag = }\\n')\n                    TableBuilder.process_table_entries(\n                        tag=tag,\n                        table_entries=table_entries,\n                        out_dir=dir_out\n                    )\n                    print(f'\\nFinished tables for {tag = }\\n')\n\n            if make_xy_plots:\n\n                traces: List[Trace2D] = collection.get_products(tag=tag, object_type=Trace2D).elements\n                points: List[Point2D] = collection.get_products(tag=tag, object_type=Point2D).elements\n\n                if points or traces:\n                    print(f'\\n\\nMaking xy plot for {tag = }\\n')\n                    XYDataPlotter.handle_points_and_traces(\n                        tag=tag,\n                        points=points,\n                        traces=traces,\n                        dir_out=dir_out,\n                        dpi=dpi,\n                    )\n                    print(f'\\nFinished xy plot for {tag = }\\n')\n\n            if make_histograms:\n                histogram_entries: List[HistogramEntry] = collection.get_products(tag=tag, object_type=HistogramEntry).elements\n\n                if histogram_entries:\n                    print(f'\\n\\nMaking histogram for {tag = }\\n')\n                    Histogrammer.handle_histogram_entries(\n                        tag=tag,\n                        histogram_entries=histogram_entries,\n                        dir_out=dir_out,\n                        dpi=dpi\n                    )\n                    print(f'\\nFinished histogram for {tag = }\\n')\n\n\n    @classmethod\n    def make_grafana_panels(\n            cls,\n            dir_in: Path,\n            panel_dir: Path,\n        ):\n        \"\"\"\n        Processes collection of elements corresponding to a single tag.\n        This method should be called on a directory containing jsons for which the products have been\n        sorted.\n\n        Args:\n            dir_in (Path): Directory from which to read data products (should be sorted first)\n            panel_dir (Path): Where to put the panel information\n        \"\"\"\n\n        collection = cls.collect_from_all_jsons(dir_in)\n        panel_dir.mkdir(parents=True, exist_ok=True)\n\n        if collection is not None:\n            server_path = 'http://localhost:8000/data_products/workdir.products/'  # [ ] this should not be hard coded\n\n            for tag in collection.get_tags():\n\n\n                dot_tag = '.'.join([str(t) for t in tag]) if should_be_flattened(tag) else tag\n                underscore_tag = '_'.join([str(t) for t in tag]) if should_be_flattened(tag) else tag\n\n                table_entries: List[TableEntry] = collection.get_products(tag=tag, object_type=TableEntry).elements\n\n                if table_entries:\n                    print(f'\\n\\nMaking tables for {tag = }\\n')\n                    panel = gapi.Panel(\n                        targets=[\n                            gapi.Target(\n                                datasource=gapi.DataSource(),\n                                url='/'.join([server_path.strip('/'), dot_tag, 'TableEntry']),\n                                uql=UQL_TableEntry,\n                            )\n                        ],\n                        type='table',\n                    )\n                    panel_dir.joinpath(underscore_tag + '_table_panel.json').write_text(panel.model_dump_json(indent=4))\n                    print(f'\\nFinished tables for {tag = }\\n')\n\n                traces: List[Trace2D] = collection.get_products(tag=tag, object_type=Trace2D).elements\n                points: List[Point2D] = collection.get_products(tag=tag, object_type=Point2D).elements\n\n                if points or traces:\n                    print(f'\\n\\nMaking xy chart for {tag = }\\n')\n                    panel = gapi.Panel(\n                        targets=[\n                            gapi.Target(\n                                datasource=gapi.DataSource(),\n                                url='/'.join([server_path.strip('/'), dot_tag, 'Point2D']),\n                                uql=UQL_Point2D,\n                                refId='A',\n                            ),\n                            gapi.Target(\n                                datasource=gapi.DataSource(),\n                                url='/'.join([server_path.strip('/'), dot_tag, 'Trace2D']),\n                                uql=UQL_Trace2D,\n                                refId='B',\n                            )\n                        ],\n                        transformations=[\n                            gapi.Merge(),\n                            gapi.PartitionByValues.from_fields(\n                                fields='label',\n                                keep_fields=False,\n                                fields_as_labels=False,\n                            )\n                        ],\n                        type='xychart',\n                    )\n                    panel_dir.joinpath(underscore_tag + '_xy_panel.json').write_text(panel.model_dump_json(indent=4))\n                    print(f'\\nFinished xy plot for {tag = }\\n')\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.DataProductCollection.add_products","title":"add_products","text":"<pre><code>add_products(*products: DataProduct)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>products</code>               (<code>Tuple[DataProduct | ProductList, ...]</code>, default:                   <code>()</code> )           \u2013            <p>Products or lists of products to be appended to collection elements.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def add_products(self, *products: DataProduct):\n    \"\"\"\n    Args:\n        products (Tuple[DataProduct|ProductList, ...]): Products or lists of products to be\n            appended to collection elements.  \n    \"\"\"\n    self.elements.extend(flatten(products))\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.DataProductCollection.collect_from_all_jsons","title":"collect_from_all_jsons  <code>classmethod</code>","text":"<pre><code>collect_from_all_jsons(*dirs: Path, recursive=False)\n</code></pre> <p>Loads all products from JSONs in the given list of directories. If recursive is set to <code>True</code>, the directories will be searched recursively  (this could lead to double counting if you pass in subdirectories of a parent).</p> <p>Parameters:</p> <ul> <li> <code>dirs</code>               (<code>Tuple[Path, ...]</code>, default:                   <code>()</code> )           \u2013            <p>Directories from which to load data product JSON files.</p> </li> <li> <code>recursive</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>whether or not to search each of the provided directories recursively for  data product json files.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Type[Self] | None</code>           \u2013            <p>Data product collection if JSON files are found. Otherwise, returns None if no product JSON files were found.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>@classmethod\ndef collect_from_all_jsons(cls, *dirs: Path, recursive=False):\n    \"\"\"\n    Loads all products from JSONs in the given list of directories.  \n    If recursive is set to `True`, the directories will be searched recursively \n    (this could lead to double counting if you pass in subdirectories of a parent).\n\n    Args:\n        dirs (Tuple[Path, ...]): Directories from which to load data product JSON files.\n        recursive (bool): whether or not to search each of the provided directories recursively for \n            data product json files.\n\n    Returns:\n        (Type[Self] | None): Data product collection if JSON files are found.  \n            Otherwise, returns None if no product JSON files were found.\n    \"\"\"\n    if not recursive:\n        jsons: List[Path] = list(flatten(chain(list(d.glob('*.json')) for d in dirs)))\n    else:\n        jsons: List[Path] = list(flatten(chain(list(d.glob('**/*.json')) for d in dirs)))\n    if jsons:\n        return cls.union(\n            *tuple(\n                [\n                    cls.model_validate_json(p.read_text())\n                    for p in jsons\n                ]\n            )\n        )\n    else:\n        return None\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.DataProductCollection.drop_products","title":"drop_products","text":"<pre><code>drop_products(\n    tag: Hashable | None = None,\n    object_type: Type[R] | None = None,\n) -&gt; Self[R]\n</code></pre> <p>Removes products matching <code>tag</code> and/or <code>object_type</code> from collection elements.</p> <p>Parameters:</p> <ul> <li> <code>tag</code>               (<code>Tag | None</code>, default:                   <code>None</code> )           \u2013            <p>Tag for which data products should be dropped</p> </li> <li> <code>object_type</code>               (<code>Type | None</code>, default:                   <code>None</code> )           \u2013            <p>Type of data product to drop</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataProductCollection</code>           \u2013            <p>A new collection from which matching elements have been dropped.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def drop_products(self, tag: Hashable | None = None, object_type: Type[R] | None = None) -&gt; Self[R]:\n    \"\"\"\n    Removes products matching `tag` and/or `object_type` from collection elements.\n\n    Args:\n        tag (Tag | None): Tag for which data products should be dropped\n        object_type (Type | None): Type of data product to drop\n\n    Returns:\n        (DataProductCollection): A new collection from which matching elements have been dropped.\n    \"\"\"\n    match_key = tag is None, object_type is None\n    match match_key:\n        case (True, True):\n            return type(self)(elements=self.elements)\n        case (True, False):\n            return type(self)(elements=[e for e in self.elements if not isinstance(e, object_type)])\n        case (False, True):\n            return type(self)(elements=[e for e in self.elements if not tag in e.tags])\n        case (False, False):\n            return type(self)(elements=[e for e in self.elements if not (tag in e.tags and isinstance(e, object_type))])\n        case _:\n            raise ValueError('Something is wrong with match statement')\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.DataProductCollection.from_iterable","title":"from_iterable  <code>classmethod</code>","text":"<pre><code>from_iterable(*products: Tuple[ProductList, ...])\n</code></pre> <p>Returns a new instance containing all of the products provided in the <code>*products</code> argument.</p> <p>Parameters:</p> <ul> <li> <code>products</code>               (<code>Tuple[ProductList, ...]</code>, default:                   <code>()</code> )           \u2013            <p>Lists of data products to combine into a collection</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>cls</code>           \u2013            <p>A data product collection containing all of the provided products in the <code>*products</code> argument.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>@classmethod\ndef from_iterable(cls, *products: Tuple[ProductList, ...]):\n    \"\"\"\n    Returns a new instance containing all of the products provided in the `*products` argument.\n\n    Args:\n        products (Tuple[ProductList, ...]): Lists of data products to combine into a collection\n\n    Returns:\n        (cls): A data product collection containing all of the provided products in the `*products` argument.\n    \"\"\"\n    return cls(elements=list(flatten(products)))\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.DataProductCollection.get_products","title":"get_products","text":"<pre><code>get_products(\n    tag: Hashable | None = None,\n    object_type: Type[R] | None = None,\n) -&gt; Self[R]\n</code></pre> <p>Returns a new collection containing products matching <code>tag</code> and/or <code>object_type</code>. Both <code>tag</code> and <code>object_type</code> default to <code>None</code> which matches all products.</p> <p>Parameters:</p> <ul> <li> <code>tag</code>               (<code>Tag | None</code>, default:                   <code>None</code> )           \u2013            <p>Tag of data products to be kept.  <code>None</code> matches all products.</p> </li> <li> <code>object_type</code>               (<code>Type | None</code>, default:                   <code>None</code> )           \u2013            <p>Type of data product to keep.  <code>None</code> matches all products.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataProductCollection</code>           \u2013            <p>A new collection containing matching elements.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def get_products(self, tag: Hashable | None = None, object_type: Type[R] | None = None) -&gt; Self[R]:\n    \"\"\"\n    Returns a new collection containing products matching `tag` and/or `object_type`.\n    Both `tag` and `object_type` default to `None` which matches all products.\n\n    Args:\n        tag (Tag | None): Tag of data products to be kept.  `None` matches all products.\n        object_type (Type | None): Type of data product to keep.  `None` matches all products.\n\n    Returns:\n        (DataProductCollection): A new collection containing matching elements.\n    \"\"\"\n    match_key = tag is None, object_type is None\n    match match_key:\n        case (True, True):\n            return type(self)(elements=self.elements)\n        case (True, False):\n            return type(self)(elements=[e for e in self.elements if isinstance(e, object_type)])\n        case (False, True):\n            return type(self)(elements=[e for e in self.elements if tag in e.tags])\n        case (False, False):\n            return type(self)(elements=[e for e in self.elements if tag in e.tags and isinstance(e, object_type)])\n        case _:\n            raise ValueError('Something is wrong with match statement')\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.DataProductCollection.get_tags","title":"get_tags","text":"<pre><code>get_tags(\n    data_product_type: Type[DataProduct] | None = None,\n) -&gt; set\n</code></pre> <p>Gets the tags related to a given type of <code>DataProduct</code>.  Parent classes will match all child class types.</p> <p>Parameters:</p> <ul> <li> <code>data_product_type</code>               (<code>Type[DataProduct] | None</code>, default:                   <code>None</code> )           \u2013            <p>type for which you want to get the list of tags</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>set</code>           \u2013            <p>set of tags applying to the given <code>data_product_type</code>.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def get_tags(self, data_product_type: Type[DataProduct] | None = None) -&gt; set:\n    \"\"\"\n    Gets the tags related to a given type of `DataProduct`.  Parent classes will match all child class types.\n\n    Args:\n        data_product_type (Type[DataProduct] | None): type for which you want to get the list of tags\n\n    Returns:\n        (set): set of tags applying to the given `data_product_type`.\n    \"\"\"\n    tags = []\n    for e in flatten(self.elements):\n        if data_product_type is None or isinstance(e, data_product_type):\n            for t in e.tags:\n                tags.append(t)\n    return set(tags)\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.DataProductCollection.make_grafana_panels","title":"make_grafana_panels  <code>classmethod</code>","text":"<pre><code>make_grafana_panels(dir_in: Path, panel_dir: Path)\n</code></pre> <p>Processes collection of elements corresponding to a single tag. This method should be called on a directory containing jsons for which the products have been sorted.</p> <p>Parameters:</p> <ul> <li> <code>dir_in</code>               (<code>Path</code>)           \u2013            <p>Directory from which to read data products (should be sorted first)</p> </li> <li> <code>panel_dir</code>               (<code>Path</code>)           \u2013            <p>Where to put the panel information</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>@classmethod\ndef make_grafana_panels(\n        cls,\n        dir_in: Path,\n        panel_dir: Path,\n    ):\n    \"\"\"\n    Processes collection of elements corresponding to a single tag.\n    This method should be called on a directory containing jsons for which the products have been\n    sorted.\n\n    Args:\n        dir_in (Path): Directory from which to read data products (should be sorted first)\n        panel_dir (Path): Where to put the panel information\n    \"\"\"\n\n    collection = cls.collect_from_all_jsons(dir_in)\n    panel_dir.mkdir(parents=True, exist_ok=True)\n\n    if collection is not None:\n        server_path = 'http://localhost:8000/data_products/workdir.products/'  # [ ] this should not be hard coded\n\n        for tag in collection.get_tags():\n\n\n            dot_tag = '.'.join([str(t) for t in tag]) if should_be_flattened(tag) else tag\n            underscore_tag = '_'.join([str(t) for t in tag]) if should_be_flattened(tag) else tag\n\n            table_entries: List[TableEntry] = collection.get_products(tag=tag, object_type=TableEntry).elements\n\n            if table_entries:\n                print(f'\\n\\nMaking tables for {tag = }\\n')\n                panel = gapi.Panel(\n                    targets=[\n                        gapi.Target(\n                            datasource=gapi.DataSource(),\n                            url='/'.join([server_path.strip('/'), dot_tag, 'TableEntry']),\n                            uql=UQL_TableEntry,\n                        )\n                    ],\n                    type='table',\n                )\n                panel_dir.joinpath(underscore_tag + '_table_panel.json').write_text(panel.model_dump_json(indent=4))\n                print(f'\\nFinished tables for {tag = }\\n')\n\n            traces: List[Trace2D] = collection.get_products(tag=tag, object_type=Trace2D).elements\n            points: List[Point2D] = collection.get_products(tag=tag, object_type=Point2D).elements\n\n            if points or traces:\n                print(f'\\n\\nMaking xy chart for {tag = }\\n')\n                panel = gapi.Panel(\n                    targets=[\n                        gapi.Target(\n                            datasource=gapi.DataSource(),\n                            url='/'.join([server_path.strip('/'), dot_tag, 'Point2D']),\n                            uql=UQL_Point2D,\n                            refId='A',\n                        ),\n                        gapi.Target(\n                            datasource=gapi.DataSource(),\n                            url='/'.join([server_path.strip('/'), dot_tag, 'Trace2D']),\n                            uql=UQL_Trace2D,\n                            refId='B',\n                        )\n                    ],\n                    transformations=[\n                        gapi.Merge(),\n                        gapi.PartitionByValues.from_fields(\n                            fields='label',\n                            keep_fields=False,\n                            fields_as_labels=False,\n                        )\n                    ],\n                    type='xychart',\n                )\n                panel_dir.joinpath(underscore_tag + '_xy_panel.json').write_text(panel.model_dump_json(indent=4))\n                print(f'\\nFinished xy plot for {tag = }\\n')\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.DataProductCollection.process_single_tag_collection","title":"process_single_tag_collection  <code>classmethod</code>","text":"<pre><code>process_single_tag_collection(\n    dir_in: Path,\n    dir_out: Path,\n    make_tables: bool,\n    make_xy_plots: bool,\n    make_histograms: bool,\n    dpi: int,\n)\n</code></pre> <p>Processes collection of elements corresponding to a single tag. This method should be called on a directory containing jsons for which the products have been sorted.</p> <p>Parameters:</p> <ul> <li> <code>dir_in</code>               (<code>Path</code>)           \u2013            </li> <li> <code>dir_out</code>               (<code>Path</code>)           \u2013            </li> <li> <code>make_tables</code>               (<code>bool</code>)           \u2013            </li> <li> <code>make_xy_plots</code>               (<code>bool</code>)           \u2013            </li> <li> <code>make_histograms</code>               (<code>bool</code>)           \u2013            </li> <li> <code>dpi</code>               (<code>int</code>)           \u2013            </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>@classmethod\ndef process_single_tag_collection(\n        cls,\n        dir_in: Path,\n        dir_out: Path,\n        make_tables: bool,\n        make_xy_plots: bool,\n        make_histograms: bool,\n        dpi: int,\n    ):\n    \"\"\"\n    Processes collection of elements corresponding to a single tag.\n    This method should be called on a directory containing jsons for which the products have been\n    sorted.\n\n    Args:\n        dir_in (Path):\n        dir_out (Path):\n        make_tables (bool):\n        make_xy_plots (bool):\n        make_histograms (bool):\n        dpi (int):\n    \"\"\"\n\n    collection = cls.collect_from_all_jsons(dir_in)\n\n    if collection is not None:\n\n        [tag] = collection.get_tags()\n\n        if make_tables:\n\n            table_entries: List[TableEntry] = collection.get_products(tag=tag, object_type=TableEntry).elements\n\n            if table_entries:\n                print(f'\\n\\nMaking tables for {tag = }\\n')\n                TableBuilder.process_table_entries(\n                    tag=tag,\n                    table_entries=table_entries,\n                    out_dir=dir_out\n                )\n                print(f'\\nFinished tables for {tag = }\\n')\n\n        if make_xy_plots:\n\n            traces: List[Trace2D] = collection.get_products(tag=tag, object_type=Trace2D).elements\n            points: List[Point2D] = collection.get_products(tag=tag, object_type=Point2D).elements\n\n            if points or traces:\n                print(f'\\n\\nMaking xy plot for {tag = }\\n')\n                XYDataPlotter.handle_points_and_traces(\n                    tag=tag,\n                    points=points,\n                    traces=traces,\n                    dir_out=dir_out,\n                    dpi=dpi,\n                )\n                print(f'\\nFinished xy plot for {tag = }\\n')\n\n        if make_histograms:\n            histogram_entries: List[HistogramEntry] = collection.get_products(tag=tag, object_type=HistogramEntry).elements\n\n            if histogram_entries:\n                print(f'\\n\\nMaking histogram for {tag = }\\n')\n                Histogrammer.handle_histogram_entries(\n                    tag=tag,\n                    histogram_entries=histogram_entries,\n                    dir_out=dir_out,\n                    dpi=dpi\n                )\n                print(f'\\nFinished histogram for {tag = }\\n')\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.DataProductCollection.sort_by_tags","title":"sort_by_tags  <code>classmethod</code>","text":"<pre><code>sort_by_tags(dirs_in: List[Path], dir_out: Path)\n</code></pre> <p>Loads the data product JSON files from <code>dirs_in</code> sorts the products. Sorted products are written to smaller files in a nested directory structure under <code>dir_out</code>. The nested directory structure is generated accordint to the data tags. Resulting product files are named according to the directory from which they were originally loaded.</p> <p>Parameters:</p> <ul> <li> <code>dirs_in</code>               (<code>List[Path]</code>)           \u2013            <p>Directories from which the data product JSON files are to be loaded.</p> </li> <li> <code>dir_out</code>               (<code>Path</code>)           \u2013            <p>Directory to which the sorted data products will be written into a  nested folder structure generated according to the data tags.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>@classmethod\ndef sort_by_tags(cls, dirs_in: List[Path], dir_out: Path):\n    \"\"\"\n    Loads the data product JSON files from `dirs_in` sorts the products.\n    Sorted products are written to smaller files in a nested directory structure under `dir_out`.\n    The nested directory structure is generated accordint to the data tags.\n    Resulting product files are named according to the directory from which they were originally loaded.\n\n    Args:\n        dirs_in (List[Path]): Directories from which the data product JSON files are to be loaded.\n        dir_out (Path): Directory to which the sorted data products will be written into a \n            nested folder structure generated according to the data tags.\n    \"\"\"\n    dirs_in = list(dirs_in)\n    dirs_in.sort()\n    len_dirs = len(dirs_in)\n    for n, d in enumerate(dirs_in):\n        print(f'Collecting tagged data from dir {n}/{len_dirs}', end=f'\\r')\n        collection = DataProductCollection.model_validate_json(\n            d.joinpath(DATA_PRODUCTS_FNAME).read_text()\n        )\n        tags = collection.get_tags()\n        for tag in tags:\n            sub_collection = collection.get_products(tag=tag)\n            save_to = dir_out.joinpath(*atleast_1d(tag))\n            save_to.mkdir(parents=True, exist_ok=True)\n            save_to.joinpath(d.name).with_suffix('.json').write_text(sub_collection.model_dump_json(\n                indent=4\n            ))\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.DataProductCollection.union","title":"union  <code>classmethod</code>","text":"<pre><code>union(*collections: DataProductCollection)\n</code></pre> <p>Aggregates all of the products from multiple collections into a new larger collection.</p> <p>Parameters:</p> <ul> <li> <code>collections</code>               (<code>Tuple[DataProductCollection, ...]</code>, default:                   <code>()</code> )           \u2013            <p>Data product collections for which the products should be combined into a new collection.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Type[Self]</code>           \u2013            <p>A new data product collection containing all products from the provided <code>*collections</code>.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>@classmethod\ndef union(cls, *collections: DataProductCollection):\n    \"\"\"\n    Aggregates all of the products from multiple collections into a new larger collection.\n\n    Args:\n        collections (Tuple[DataProductCollection, ...]): Data product collections\n            for which the products should be combined into a new collection.\n\n    Returns:\n        (Type[Self]): A new data product collection containing all products from\n            the provided `*collections`.\n    \"\"\"\n    return cls(elements=list(flatten(chain(c.elements for c in collections))))\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.DataProductGenerator","title":"DataProductGenerator","text":"<p>A wrapper for saving the data products generated by a user defined function</p> <p>Parameters:</p> <ul> <li> <code>processor</code>               (<code>Callable[[Path], ProductList]</code>)           \u2013            <p>A callable that receives a working directory and returns a list of data products.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>class DataProductGenerator:\n    \"\"\"\n    A wrapper for saving the data products generated by a user defined function\n\n    Args:\n        processor (Callable[[Path], ProductList]): A callable that receives a working directory\n            and returns a list of data products.\n    \"\"\"\n    def __init__(self, processor: Callable[[Path], ProductList]):\n        self._processor = processor\n\n    def process_and_save(self, workdir: Path):\n        \"\"\"\n        Runs the user-defined processor method stored at instantiation.\n\n        Saves the returned products to a JSON file in the same directory.\n\n        Args:\n            workdir (Path): working directory on which to run the processor method.\n        \"\"\"\n\n        print(f'Processing {workdir = } with {self._processor = }')\n        collection = DataProductCollection.from_iterable(self._processor(workdir))\n        workdir.mkdir(exist_ok=True, parents=True)\n        workdir.joinpath(DATA_PRODUCTS_FNAME).write_text(collection.model_dump_json())\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.DataProductGenerator.process_and_save","title":"process_and_save","text":"<pre><code>process_and_save(workdir: Path)\n</code></pre> <p>Runs the user-defined processor method stored at instantiation.</p> <p>Saves the returned products to a JSON file in the same directory.</p> <p>Parameters:</p> <ul> <li> <code>workdir</code>               (<code>Path</code>)           \u2013            <p>working directory on which to run the processor method.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def process_and_save(self, workdir: Path):\n    \"\"\"\n    Runs the user-defined processor method stored at instantiation.\n\n    Saves the returned products to a JSON file in the same directory.\n\n    Args:\n        workdir (Path): working directory on which to run the processor method.\n    \"\"\"\n\n    print(f'Processing {workdir = } with {self._processor = }')\n    collection = DataProductCollection.from_iterable(self._processor(workdir))\n    workdir.mkdir(exist_ok=True, parents=True)\n    workdir.joinpath(DATA_PRODUCTS_FNAME).write_text(collection.model_dump_json())\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.Format2D","title":"Format2D","text":"<p>               Bases: <code>HashableBase</code></p> <p>Formatting data for matplotlib figure and axes</p> Source code in <code>src/trendify/products.py</code> <pre><code>class Format2D(HashableBase):\n    \"\"\"\n    Formatting data for matplotlib figure and axes\n    \"\"\"\n    title_fig: Optional[str] = None\n    title_legend: Optional[str] = None\n    title_ax: Optional[str] = None\n    label_x: Optional[str] = None\n    label_y: Optional[str] = None\n    lim_x_min: float | str | None = None\n    lim_x_max: float | str | None = None\n    lim_y_min: float | str | None = None\n    lim_y_max: float | str | None = None\n\n    class Config:\n        \"\"\"\n        Forbids extra arguments\n        \"\"\"\n        extra = \"forbid\"  \n\n    @classmethod\n    def union_from_iterable(cls, format2ds: Iterable[Format2D]):\n        \"\"\"\n        Gets the most inclusive format object (in terms of limits) from a list of `Format2D` objects.\n        Requires that the label and title fields are identical for all format objects in the list.\n\n        Args:\n            format2ds (Iterable[Format2D]): Iterable of `Format2D` objects.\n\n        Returns:\n            (Format2D): Single format object from list of objects.\n\n        \"\"\"\n        formats = list(set(format2ds) - {None})\n        [title_fig] = set(i.title_fig for i in formats)\n        [title_legend] = set(i.title_legend for i in formats)\n        [title_ax] = set(i.title_ax for i in formats)\n        [label_x] = set(i.label_x for i in formats)\n        [label_y] = set(i.label_y for i in formats)\n        x_min = [i.lim_x_min for i in formats if i.lim_x_min is not None]\n        x_max = [i.lim_x_max for i in formats if i.lim_x_max is not None]\n        y_min = [i.lim_y_min for i in formats if i.lim_y_min is not None]\n        y_max = [i.lim_y_max for i in formats if i.lim_y_max is not None]\n        lim_x_min = np.min(x_min) if len(x_min) &gt; 0 else None\n        lim_x_max = np.max(x_max) if len(x_max) &gt; 0 else None\n        lim_y_min = np.min(y_min) if len(y_min) &gt; 0 else None\n        lim_y_max = np.max(y_max) if len(y_max) &gt; 0 else None\n\n        return cls(\n            title_fig=title_fig,\n            title_legend=title_legend,\n            title_ax=title_ax,\n            label_x=label_x,\n            label_y=label_y,\n            lim_x_min=lim_x_min,\n            lim_x_max=lim_x_max,\n            lim_y_min=lim_y_min,\n            lim_y_max=lim_y_max,\n        )\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.Format2D.Config","title":"Config","text":"<p>Forbids extra arguments</p> Source code in <code>src/trendify/products.py</code> <pre><code>class Config:\n    \"\"\"\n    Forbids extra arguments\n    \"\"\"\n    extra = \"forbid\"  \n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.Format2D.union_from_iterable","title":"union_from_iterable  <code>classmethod</code>","text":"<pre><code>union_from_iterable(format2ds: Iterable[Format2D])\n</code></pre> <p>Gets the most inclusive format object (in terms of limits) from a list of <code>Format2D</code> objects. Requires that the label and title fields are identical for all format objects in the list.</p> <p>Parameters:</p> <ul> <li> <code>format2ds</code>               (<code>Iterable[Format2D]</code>)           \u2013            <p>Iterable of <code>Format2D</code> objects.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Format2D</code>           \u2013            <p>Single format object from list of objects.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>@classmethod\ndef union_from_iterable(cls, format2ds: Iterable[Format2D]):\n    \"\"\"\n    Gets the most inclusive format object (in terms of limits) from a list of `Format2D` objects.\n    Requires that the label and title fields are identical for all format objects in the list.\n\n    Args:\n        format2ds (Iterable[Format2D]): Iterable of `Format2D` objects.\n\n    Returns:\n        (Format2D): Single format object from list of objects.\n\n    \"\"\"\n    formats = list(set(format2ds) - {None})\n    [title_fig] = set(i.title_fig for i in formats)\n    [title_legend] = set(i.title_legend for i in formats)\n    [title_ax] = set(i.title_ax for i in formats)\n    [label_x] = set(i.label_x for i in formats)\n    [label_y] = set(i.label_y for i in formats)\n    x_min = [i.lim_x_min for i in formats if i.lim_x_min is not None]\n    x_max = [i.lim_x_max for i in formats if i.lim_x_max is not None]\n    y_min = [i.lim_y_min for i in formats if i.lim_y_min is not None]\n    y_max = [i.lim_y_max for i in formats if i.lim_y_max is not None]\n    lim_x_min = np.min(x_min) if len(x_min) &gt; 0 else None\n    lim_x_max = np.max(x_max) if len(x_max) &gt; 0 else None\n    lim_y_min = np.min(y_min) if len(y_min) &gt; 0 else None\n    lim_y_max = np.max(y_max) if len(y_max) &gt; 0 else None\n\n    return cls(\n        title_fig=title_fig,\n        title_legend=title_legend,\n        title_ax=title_ax,\n        label_x=label_x,\n        label_y=label_y,\n        lim_x_min=lim_x_min,\n        lim_x_max=lim_x_max,\n        lim_y_min=lim_y_min,\n        lim_y_max=lim_y_max,\n    )\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.HashableBase","title":"HashableBase","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines a base for hashable pydantic data classes so that they can be reduced to a minimal set through type-casting.</p> Source code in <code>src/trendify/products.py</code> <pre><code>class HashableBase(BaseModel):\n    \"\"\"\n    Defines a base for hashable pydantic data classes so that they can be reduced to a minimal set through type-casting.\n    \"\"\"\n    def __hash__(self):\n        \"\"\"\n        Defines hash function\n        \"\"\"\n        return hash((type(self),) + tuple(self.__dict__.values()))\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.HashableBase.__hash__","title":"__hash__","text":"<pre><code>__hash__()\n</code></pre> <p>Defines hash function</p> Source code in <code>src/trendify/products.py</code> <pre><code>def __hash__(self):\n    \"\"\"\n    Defines hash function\n    \"\"\"\n    return hash((type(self),) + tuple(self.__dict__.values()))\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.HistogramEntry","title":"HistogramEntry","text":"<p>               Bases: <code>DataProduct</code></p> <p>Use this class to specify a value to be collected into a matplotlib histogram.</p> <p>Attributes:</p> <ul> <li> <code>product_type</code>               (<code>Literal['Trace2D']</code>)           \u2013            <p>Name of class type to be used as a constructor.</p> </li> <li> <code>value</code>               (<code>float | str</code>)           \u2013            <p>Value to be binned</p> </li> <li> <code>tags</code>               (<code>Tags</code>)           \u2013            <p>Hashable tags used to sort data products</p> </li> <li> <code>style</code>               (<code>HistogramStyle</code>)           \u2013            <p>Style of histogram display</p> </li> <li> <code>format2d</code>               (<code>Format2D</code>)           \u2013            <p>Format to apply to single axis figure</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>class HistogramEntry(DataProduct):\n    \"\"\"\n    Use this class to specify a value to be collected into a matplotlib histogram.\n\n    Attributes:\n        product_type (Literal['Trace2D']): Name of class type to be used as a constructor.\n        value (float | str): Value to be binned\n        tags (Tags): Hashable tags used to sort data products\n        style (HistogramStyle): Style of histogram display\n        format2d (Format2D): Format to apply to single axis figure\n    \"\"\"\n    product_type: Literal['HistogramEntry'] = 'HistogramEntry'\n    value: float | str\n    tags: Tags\n    style: HistogramStyle\n    format2d: Format2D\n\n    class Config:\n        \"\"\"\n        Forbids extra attributes\n        \"\"\"\n        extra = \"forbid\"\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.HistogramEntry.Config","title":"Config","text":"<p>Forbids extra attributes</p> Source code in <code>src/trendify/products.py</code> <pre><code>class Config:\n    \"\"\"\n    Forbids extra attributes\n    \"\"\"\n    extra = \"forbid\"\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.HistogramStyle","title":"HistogramStyle","text":"<p>               Bases: <code>HashableBase</code></p> <p>Label and style data for generating histogram bars</p> <p>Attributes:</p> <ul> <li> <code>color</code>               (<code>str</code>)           \u2013            <p>Color of bars</p> </li> <li> <code>label</code>               (<code>str | None</code>)           \u2013            <p>Legend entry</p> </li> <li> <code>histtype</code>               (<code>str</code>)           \u2013            <p>Histogram type corresponding to matplotlib argument of same name</p> </li> <li> <code>alpha_edge</code>               (<code>float</code>)           \u2013            <p>Opacity of bar edge</p> </li> <li> <code>alpha_face</code>               (<code>float</code>)           \u2013            <p>Opacity of bar face</p> </li> <li> <code>linewidth</code>               (<code>float</code>)           \u2013            <p>Line width of bar outline</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>class HistogramStyle(HashableBase):\n    \"\"\"\n    Label and style data for generating histogram bars\n\n    Attributes:\n        color (str): Color of bars\n        label (str|None): Legend entry\n        histtype (str): Histogram type corresponding to matplotlib argument of same name\n        alpha_edge (float): Opacity of bar edge\n        alpha_face (float): Opacity of bar face\n        linewidth (float): Line width of bar outline\n    \"\"\"\n    color: str = 'k'\n    label: str | None = None\n    histtype: str = 'stepfilled'\n    alpha_edge: float = 1\n    alpha_face: float = 0.3\n    linewidth: float = 2\n\n    def as_plot_kwargs(self):\n        \"\"\"\n        Returns:\n            (dict): kwargs for matplotlib `hist` method\n        \"\"\"\n        return {\n            'facecolor': (self.color, self.alpha_face),\n            'edgecolor': (self.color, self.alpha_edge),\n            'linewidth': self.linewidth,\n            'label': self.label,\n            'histtype': self.histtype\n        }\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.HistogramStyle.as_plot_kwargs","title":"as_plot_kwargs","text":"<pre><code>as_plot_kwargs()\n</code></pre> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>kwargs for matplotlib <code>hist</code> method</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def as_plot_kwargs(self):\n    \"\"\"\n    Returns:\n        (dict): kwargs for matplotlib `hist` method\n    \"\"\"\n    return {\n        'facecolor': (self.color, self.alpha_face),\n        'edgecolor': (self.color, self.alpha_edge),\n        'linewidth': self.linewidth,\n        'label': self.label,\n        'histtype': self.histtype\n    }\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.Histogrammer","title":"Histogrammer","text":"<p>Class for loading data products and histogramming the <code>HistogramEntry</code>s</p> <p>Parameters:</p> <ul> <li> <code>in_dirs</code>               (<code>List[Path]</code>)           \u2013            <p>Directories from which the data products are to be loaded.</p> </li> <li> <code>out_dir</code>               (<code>Path</code>)           \u2013            <p>Directory to which the generated histogram will be stored</p> </li> <li> <code>dpi</code>               (<code>int</code>)           \u2013            <p>resolution of plot</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>class Histogrammer:\n    \"\"\"\n    Class for loading data products and histogramming the [`HistogramEntry`][trendify.products.HistogramEntry]s\n\n    Args:\n        in_dirs (List[Path]): Directories from which the data products are to be loaded.\n        out_dir (Path): Directory to which the generated histogram will be stored\n        dpi (int): resolution of plot\n    \"\"\"\n    def __init__(\n            self,\n            in_dirs: List[Path],\n            out_dir: Path,\n            dpi: int,\n        ):\n        self.in_dirs = in_dirs\n        self.out_dir = out_dir\n        self.dpi = dpi\n\n    def plot(\n            self,\n            tag: Hashable,\n        ):\n        \"\"\"\n        Generates a histogram by loading data from stored `in_dirs` and saves the plot to `out_dir` directory.\n        A nested folder structure will be created if the provided `tag` is a tuple.  \n        In that case, the last tag item (with an appropriate suffix) will be used for the file name.\n\n        Args:\n            tag (Hashable): Tag used to filter the loaded data products\n        \"\"\"\n        print(f'Making histogram plot for {tag = }')\n\n        histogram_entries: List[HistogramEntry] = []\n        for directory in self.in_dirs:\n            collection = DataProductCollection.model_validate_json(directory.joinpath(DATA_PRODUCTS_FNAME).read_text())\n            histogram_entries.extend(collection.get_products(tag=tag, object_type=HistogramEntry).elements)\n\n        self.handle_histogram_entries(\n            tag=tag,\n            histogram_entries=histogram_entries,\n            dir_out=self.out_dir,\n            dpi=self.dpi,\n        )\n\n    @classmethod\n    def handle_histogram_entries(\n            cls, \n            tag: Hashable, \n            histogram_entries: List[HistogramEntry],\n            dir_out: Path,\n            dpi: int,\n        ):\n        \"\"\"\n        Histograms the provided entries. Formats and saves the figure.  Closes the figure.\n\n        Args:\n            tag (Hashable): Tag used to filter the loaded data products\n            histogram_entries (List[HistogramEntry]): A list of [`HistogramEntry`][trendify.products.HistogramEntry]s\n            dir_out (Path): Directory to which the generated histogram will be stored\n            dpi (int): resolution of plot\n        \"\"\"\n        saf = SingleAxisFigure.new(tag=tag)\n\n        histogram_styles = set([h.style for h in histogram_entries])\n        for s in histogram_styles:\n            matching_entries = [e for e in histogram_entries if e.style == s]\n            values = [e.value for e in matching_entries]\n            if s is not None:\n                saf.ax.hist(values, **s.as_plot_kwargs())\n            else:\n                saf.ax.hist(values)\n\n        [format2d] = set([h.format2d for h in histogram_entries]) - {None}\n        saf.apply_format(format2d=format2d)\n\n        save_path = dir_out.joinpath(*tuple(atleast_1d(tag))).with_suffix('.jpg')\n        save_path.parent.mkdir(exist_ok=True, parents=True)\n        print(f'Saving to {save_path}')\n        saf.savefig(save_path, dpi=dpi)\n        del saf\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.Histogrammer.handle_histogram_entries","title":"handle_histogram_entries  <code>classmethod</code>","text":"<pre><code>handle_histogram_entries(\n    tag: Hashable,\n    histogram_entries: List[HistogramEntry],\n    dir_out: Path,\n    dpi: int,\n)\n</code></pre> <p>Histograms the provided entries. Formats and saves the figure.  Closes the figure.</p> <p>Parameters:</p> <ul> <li> <code>tag</code>               (<code>Hashable</code>)           \u2013            <p>Tag used to filter the loaded data products</p> </li> <li> <code>histogram_entries</code>               (<code>List[HistogramEntry]</code>)           \u2013            <p>A list of <code>HistogramEntry</code>s</p> </li> <li> <code>dir_out</code>               (<code>Path</code>)           \u2013            <p>Directory to which the generated histogram will be stored</p> </li> <li> <code>dpi</code>               (<code>int</code>)           \u2013            <p>resolution of plot</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>@classmethod\ndef handle_histogram_entries(\n        cls, \n        tag: Hashable, \n        histogram_entries: List[HistogramEntry],\n        dir_out: Path,\n        dpi: int,\n    ):\n    \"\"\"\n    Histograms the provided entries. Formats and saves the figure.  Closes the figure.\n\n    Args:\n        tag (Hashable): Tag used to filter the loaded data products\n        histogram_entries (List[HistogramEntry]): A list of [`HistogramEntry`][trendify.products.HistogramEntry]s\n        dir_out (Path): Directory to which the generated histogram will be stored\n        dpi (int): resolution of plot\n    \"\"\"\n    saf = SingleAxisFigure.new(tag=tag)\n\n    histogram_styles = set([h.style for h in histogram_entries])\n    for s in histogram_styles:\n        matching_entries = [e for e in histogram_entries if e.style == s]\n        values = [e.value for e in matching_entries]\n        if s is not None:\n            saf.ax.hist(values, **s.as_plot_kwargs())\n        else:\n            saf.ax.hist(values)\n\n    [format2d] = set([h.format2d for h in histogram_entries]) - {None}\n    saf.apply_format(format2d=format2d)\n\n    save_path = dir_out.joinpath(*tuple(atleast_1d(tag))).with_suffix('.jpg')\n    save_path.parent.mkdir(exist_ok=True, parents=True)\n    print(f'Saving to {save_path}')\n    saf.savefig(save_path, dpi=dpi)\n    del saf\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.Histogrammer.plot","title":"plot","text":"<pre><code>plot(tag: Hashable)\n</code></pre> <p>Generates a histogram by loading data from stored <code>in_dirs</code> and saves the plot to <code>out_dir</code> directory. A nested folder structure will be created if the provided <code>tag</code> is a tuple. In that case, the last tag item (with an appropriate suffix) will be used for the file name.</p> <p>Parameters:</p> <ul> <li> <code>tag</code>               (<code>Hashable</code>)           \u2013            <p>Tag used to filter the loaded data products</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def plot(\n        self,\n        tag: Hashable,\n    ):\n    \"\"\"\n    Generates a histogram by loading data from stored `in_dirs` and saves the plot to `out_dir` directory.\n    A nested folder structure will be created if the provided `tag` is a tuple.  \n    In that case, the last tag item (with an appropriate suffix) will be used for the file name.\n\n    Args:\n        tag (Hashable): Tag used to filter the loaded data products\n    \"\"\"\n    print(f'Making histogram plot for {tag = }')\n\n    histogram_entries: List[HistogramEntry] = []\n    for directory in self.in_dirs:\n        collection = DataProductCollection.model_validate_json(directory.joinpath(DATA_PRODUCTS_FNAME).read_text())\n        histogram_entries.extend(collection.get_products(tag=tag, object_type=HistogramEntry).elements)\n\n    self.handle_histogram_entries(\n        tag=tag,\n        histogram_entries=histogram_entries,\n        dir_out=self.out_dir,\n        dpi=self.dpi,\n    )\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.Marker","title":"Marker","text":"<p>               Bases: <code>HashableBase</code></p> <p>Defines marker for scattering to matplotlib</p> <p>Attributes:</p> <ul> <li> <code>color</code>               (<code>str</code>)           \u2013            <p>Color of line</p> </li> <li> <code>size</code>               (<code>float</code>)           \u2013            <p>Line width</p> </li> <li> <code>alpha</code>               (<code>float</code>)           \u2013            <p>Opacity from 0 to 1 (inclusive)</p> </li> <li> <code>zorder</code>               (<code>float</code>)           \u2013            <p>Prioritization </p> </li> <li> <code>label</code>               (<code>Union[str, None]</code>)           \u2013            <p>Legend label</p> </li> <li> <code>symbol</code>               (<code>str</code>)           \u2013            <p>Matplotlib symbol string</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>class Marker(HashableBase):\n    \"\"\"\n    Defines marker for scattering to matplotlib\n\n    Attributes:\n        color (str): Color of line\n        size (float): Line width\n        alpha (float): Opacity from 0 to 1 (inclusive)\n        zorder (float): Prioritization \n        label (Union[str, None]): Legend label\n        symbol (str): Matplotlib symbol string\n    \"\"\"\n    color: str = 'k'\n    size: float = 5\n    alpha: float = 1\n    zorder: float = 0\n    label: Union[str, None] = None\n    symbol: str = '.'\n\n    @classmethod\n    def from_pen(\n            cls,\n            pen: Pen,\n            symbol: str = '.',\n        ):\n        \"\"\"\n        Converts Pen to marker with the option to specify a symbol\n        \"\"\"\n        return cls(symbol=symbol, **pen.model_dump())\n\n    class Config:\n        \"\"\"\n        Forbids extra attributes\n        \"\"\"\n        extra = \"forbid\"  \n\n    def as_scatter_plot_kwargs(self):\n        \"\"\"\n        Returns:\n            (dict): dictionary of `kwargs` for [matplotlib scatter][matplotlib.axes.Axes.scatter]\n        \"\"\"\n        return {\n            'marker': self.symbol,\n            'c': self.color,\n            's': self.size,\n            'alpha': self.alpha,\n            'zorder': self.zorder,\n            'label': self.label,\n            'marker': self.symbol,\n        }\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.Marker.Config","title":"Config","text":"<p>Forbids extra attributes</p> Source code in <code>src/trendify/products.py</code> <pre><code>class Config:\n    \"\"\"\n    Forbids extra attributes\n    \"\"\"\n    extra = \"forbid\"  \n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.Marker.as_scatter_plot_kwargs","title":"as_scatter_plot_kwargs","text":"<pre><code>as_scatter_plot_kwargs()\n</code></pre> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>dictionary of <code>kwargs</code> for matplotlib scatter</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def as_scatter_plot_kwargs(self):\n    \"\"\"\n    Returns:\n        (dict): dictionary of `kwargs` for [matplotlib scatter][matplotlib.axes.Axes.scatter]\n    \"\"\"\n    return {\n        'marker': self.symbol,\n        'c': self.color,\n        's': self.size,\n        'alpha': self.alpha,\n        'zorder': self.zorder,\n        'label': self.label,\n        'marker': self.symbol,\n    }\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.Marker.from_pen","title":"from_pen  <code>classmethod</code>","text":"<pre><code>from_pen(pen: Pen, symbol: str = '.')\n</code></pre> <p>Converts Pen to marker with the option to specify a symbol</p> Source code in <code>src/trendify/products.py</code> <pre><code>@classmethod\ndef from_pen(\n        cls,\n        pen: Pen,\n        symbol: str = '.',\n    ):\n    \"\"\"\n    Converts Pen to marker with the option to specify a symbol\n    \"\"\"\n    return cls(symbol=symbol, **pen.model_dump())\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.Pen","title":"Pen","text":"<p>               Bases: <code>HashableBase</code></p> <p>Defines the pen drawing to matplotlib.</p> <p>Attributes:</p> <ul> <li> <code>color</code>               (<code>str</code>)           \u2013            <p>Color of line</p> </li> <li> <code>size</code>               (<code>float</code>)           \u2013            <p>Line width</p> </li> <li> <code>alpha</code>               (<code>float</code>)           \u2013            <p>Opacity from 0 to 1 (inclusive)</p> </li> <li> <code>zorder</code>               (<code>float</code>)           \u2013            <p>Prioritization </p> </li> <li> <code>label</code>               (<code>Union[str, None]</code>)           \u2013            <p>Legend label</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>class Pen(HashableBase):\n    \"\"\"\n    Defines the pen drawing to matplotlib.\n\n    Attributes:\n        color (str): Color of line\n        size (float): Line width\n        alpha (float): Opacity from 0 to 1 (inclusive)\n        zorder (float): Prioritization \n        label (Union[str, None]): Legend label\n    \"\"\"\n    color: str = 'k'\n    size: float = 1\n    alpha: float = 1\n    zorder: float = 0\n    label: Union[str, None] = None\n\n    class Config:\n        \"\"\"\n        Forbids extra attributes\n        \"\"\"\n        extra = \"forbid\"  \n\n    def as_scatter_plot_kwargs(self):\n        \"\"\"\n        Returns kwargs dictionary for passing to [matplotlib plot][matplotlib.axes.Axes.plot] method\n        \"\"\"\n        return {\n            'color': self.color,\n            'linewidth': self.size,\n            'alpha': self.alpha,\n            'zorder': self.zorder,\n            'label': self.label,\n        }\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.Pen.Config","title":"Config","text":"<p>Forbids extra attributes</p> Source code in <code>src/trendify/products.py</code> <pre><code>class Config:\n    \"\"\"\n    Forbids extra attributes\n    \"\"\"\n    extra = \"forbid\"  \n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.Pen.as_scatter_plot_kwargs","title":"as_scatter_plot_kwargs","text":"<pre><code>as_scatter_plot_kwargs()\n</code></pre> <p>Returns kwargs dictionary for passing to matplotlib plot method</p> Source code in <code>src/trendify/products.py</code> <pre><code>def as_scatter_plot_kwargs(self):\n    \"\"\"\n    Returns kwargs dictionary for passing to [matplotlib plot][matplotlib.axes.Axes.plot] method\n    \"\"\"\n    return {\n        'color': self.color,\n        'linewidth': self.size,\n        'alpha': self.alpha,\n        'zorder': self.zorder,\n        'label': self.label,\n    }\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.Point2D","title":"Point2D","text":"<p>               Bases: <code>XYData</code></p> <p>Defines a point to be scattered onto xy plot.</p> <p>Attributes:</p> <ul> <li> <code>product_type</code>               (<code>Literal['Trace2D']</code>)           \u2013            <p>Name of class type to be used as a constructor.</p> </li> <li> <code>points</code>               (<code>List[Point2D]</code>)           \u2013            <p>List of points.  Usually the points would have null values  for <code>marker</code> and <code>format2d</code> fields to save space.</p> </li> <li> <code>marker</code>               (<code>Marker</code>)           \u2013            <p>Style and label information for scattering points to matplotlib axes. Only the label information is used in Grafana. Eventually style information will be used in grafana.</p> </li> <li> <code>format2d</code>               (<code>Format2D</code>)           \u2013            <p>Formatting information for matplotlib figure.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>class Point2D(XYData):\n    \"\"\"\n    Defines a point to be scattered onto xy plot.\n\n    Attributes:\n        product_type (Literal['Trace2D']): Name of class type to be used as a constructor.\n        points (List[Point2D]): List of points.  Usually the points would have null values \n            for `marker` and `format2d` fields to save space.\n        marker (Marker): Style and label information for scattering points to matplotlib axes.\n            Only the label information is used in Grafana.\n            Eventually style information will be used in grafana.\n        format2d (Format2D): Formatting information for matplotlib figure.\n    \"\"\"\n    product_type: Literal['Point2D'] = 'Point2D'\n    x: float | str\n    y: float | str\n    marker: Marker | None = Marker()\n    format2d: Format2D | None = Format2D()\n\n    class Config:\n        \"\"\"\n        Forbids extra attributes\n        \"\"\"\n        extra = \"forbid\"\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.Point2D.Config","title":"Config","text":"<p>Forbids extra attributes</p> Source code in <code>src/trendify/products.py</code> <pre><code>class Config:\n    \"\"\"\n    Forbids extra attributes\n    \"\"\"\n    extra = \"forbid\"\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.SingleAxisFigure","title":"SingleAxisFigure","text":"<p>               Bases: <code>BaseModel</code></p> <p>Data class storing a matlab figure and axis.  The stored tag data in this class is so-far unused.</p> <p>Attributes:</p> <ul> <li> <code>ax</code>               (<code>Axes</code>)           \u2013            <p>Matplotlib axis to which data will be plotted</p> </li> <li> <code>fig</code>               (<code>Figure</code>)           \u2013            <p>Matplotlib figure.</p> </li> <li> <code>tag</code>               (<code>Hashable</code>)           \u2013            <p>Figure tag.  Not yet used.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>class SingleAxisFigure(BaseModel):\n    \"\"\"\n    Data class storing a matlab figure and axis.  The stored tag data in this class is so-far unused.\n\n    Attributes:\n        ax (plt.Axes): Matplotlib axis to which data will be plotted\n        fig (plt.Figure): Matplotlib figure.\n        tag (Hashable): Figure tag.  Not yet used.\n    \"\"\"\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n    tag: Hashable\n    fig: plt.Figure\n    ax: plt.Axes\n\n    @classmethod\n    def new(cls, tag: Hashable):\n        \"\"\"\n        Creates new figure and axis.  Returns new instance of this class.\n\n        Args:\n            tag (Hashable): tag (not yet used)\n\n        Returns:\n            (Type[Self]): New single axis figure\n        \"\"\"\n        fig: plt.Figure = plt.figure()\n        ax: plt.Axes = fig.add_subplot(1, 1, 1)\n        return cls(\n            tag=tag,\n            fig=fig,\n            ax=ax,\n        )\n\n    def apply_format(self, format2d: Format2D):\n        \"\"\"\n        Applies format to figure and axes labels and limits\n\n        Args:\n            format2d (Format2D): format information to apply to the single axis figure\n        \"\"\"\n        self.ax.set_title(format2d.title_ax)\n        self.fig.suptitle(format2d.title_fig)\n        with warnings.catch_warnings(action='ignore', category=UserWarning):\n            handles, labels = self.ax.get_legend_handles_labels()\n            by_label = dict(zip(labels, handles))\n            if by_label:\n                self.ax.legend(by_label.values(), by_label.keys(), title=format2d.title_legend)\n        self.ax.set_xlabel(format2d.label_x)\n        self.ax.set_ylabel(format2d.label_y)\n        self.ax.set_xlim(format2d.lim_x_min, format2d.lim_x_max)\n        self.ax.set_ylim(format2d.lim_y_min, format2d.lim_y_max)\n        return self\n\n    def savefig(self, path: Path, dpi: int = 500):\n        \"\"\"\n        Wrapper on matplotlib savefig method.  Saves figure to given path with given dpi resolution.\n\n        Returns:\n            (Self): Returns self\n        \"\"\"\n        self.fig.savefig(path, dpi=dpi)\n        return self\n\n    def __del__(self):\n        \"\"\"\n        Closes stored matplotlib figure before deleting reference to object.\n        \"\"\"\n        plt.close(self.fig)\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.SingleAxisFigure.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Closes stored matplotlib figure before deleting reference to object.</p> Source code in <code>src/trendify/products.py</code> <pre><code>def __del__(self):\n    \"\"\"\n    Closes stored matplotlib figure before deleting reference to object.\n    \"\"\"\n    plt.close(self.fig)\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.SingleAxisFigure.apply_format","title":"apply_format","text":"<pre><code>apply_format(format2d: Format2D)\n</code></pre> <p>Applies format to figure and axes labels and limits</p> <p>Parameters:</p> <ul> <li> <code>format2d</code>               (<code>Format2D</code>)           \u2013            <p>format information to apply to the single axis figure</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def apply_format(self, format2d: Format2D):\n    \"\"\"\n    Applies format to figure and axes labels and limits\n\n    Args:\n        format2d (Format2D): format information to apply to the single axis figure\n    \"\"\"\n    self.ax.set_title(format2d.title_ax)\n    self.fig.suptitle(format2d.title_fig)\n    with warnings.catch_warnings(action='ignore', category=UserWarning):\n        handles, labels = self.ax.get_legend_handles_labels()\n        by_label = dict(zip(labels, handles))\n        if by_label:\n            self.ax.legend(by_label.values(), by_label.keys(), title=format2d.title_legend)\n    self.ax.set_xlabel(format2d.label_x)\n    self.ax.set_ylabel(format2d.label_y)\n    self.ax.set_xlim(format2d.lim_x_min, format2d.lim_x_max)\n    self.ax.set_ylim(format2d.lim_y_min, format2d.lim_y_max)\n    return self\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.SingleAxisFigure.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(tag: Hashable)\n</code></pre> <p>Creates new figure and axis.  Returns new instance of this class.</p> <p>Parameters:</p> <ul> <li> <code>tag</code>               (<code>Hashable</code>)           \u2013            <p>tag (not yet used)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Type[Self]</code>           \u2013            <p>New single axis figure</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>@classmethod\ndef new(cls, tag: Hashable):\n    \"\"\"\n    Creates new figure and axis.  Returns new instance of this class.\n\n    Args:\n        tag (Hashable): tag (not yet used)\n\n    Returns:\n        (Type[Self]): New single axis figure\n    \"\"\"\n    fig: plt.Figure = plt.figure()\n    ax: plt.Axes = fig.add_subplot(1, 1, 1)\n    return cls(\n        tag=tag,\n        fig=fig,\n        ax=ax,\n    )\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.SingleAxisFigure.savefig","title":"savefig","text":"<pre><code>savefig(path: Path, dpi: int = 500)\n</code></pre> <p>Wrapper on matplotlib savefig method.  Saves figure to given path with given dpi resolution.</p> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>Returns self</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def savefig(self, path: Path, dpi: int = 500):\n    \"\"\"\n    Wrapper on matplotlib savefig method.  Saves figure to given path with given dpi resolution.\n\n    Returns:\n        (Self): Returns self\n    \"\"\"\n    self.fig.savefig(path, dpi=dpi)\n    return self\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.TableBuilder","title":"TableBuilder","text":"<p>Builds tables (melted, pivot, and stats) for histogramming and including in a report or Grafana dashboard.</p> <p>Parameters:</p> <ul> <li> <code>in_dirs</code>               (<code>List[Path]</code>)           \u2013            <p>directories from which to load data products</p> </li> <li> <code>out_dir</code>               (<code>Path</code>)           \u2013            <p>directory in which tables should be saved</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>class TableBuilder:\n    \"\"\"\n    Builds tables (melted, pivot, and stats) for histogramming and including in a report or Grafana dashboard.\n\n    Args:\n        in_dirs (List[Path]): directories from which to load data products\n        out_dir (Path): directory in which tables should be saved\n    \"\"\"\n    def __init__(\n            self,\n            in_dirs: List[Path],\n            out_dir: Path,\n        ):\n        self.in_dirs = in_dirs\n        self.out_dir = out_dir\n\n    def load_table(\n            self,\n            tag: Hashable,\n        ):\n        \"\"\"\n        Collects table entries from JSON files corresponding to given tag and processes them.\n\n        Saves CSV files for the melted data frame, pivot dataframe, and pivot dataframe stats.\n\n        File names will all use the tag with different suffixes \n        `'tag_melted.csv'`, `'tag_pivot.csv'`, `'name_stats.csv'`.\n\n        Args:\n            tag (Hashable): product tag for which to collect and process.\n        \"\"\"\n        print(f'Making table for {tag = }')\n\n        table_entries: List[TableEntry] = []\n        for subdir in self.in_dirs:\n            collection = DataProductCollection.model_validate_json(subdir.joinpath(DATA_PRODUCTS_FNAME).read_text())\n            table_entries.extend(collection.get_products(tag=tag, object_type=TableEntry).elements)\n\n        self.process_table_entries(tag=tag, table_entries=table_entries, out_dir=self.out_dir)\n\n    @classmethod\n    def process_table_entries(\n            cls,\n            tag: Hashable,\n            table_entries: List[TableEntry],\n            out_dir: Path,\n        ):\n        \"\"\"\n\n        Saves CSV files for the melted data frame, pivot dataframe, and pivot dataframe stats.\n\n        File names will all use the tag with different suffixes \n        `'tag_melted.csv'`, `'tag_pivot.csv'`, `'name_stats.csv'`.\n\n        Args:\n            tag (Hashable): product tag for which to collect and process.\n            table_entries (List[TableEntry]): List of table entries\n            out_dir (Path): Directory to which table CSV files should be saved\n        \"\"\"\n        melted = pd.DataFrame([t.get_entry_dict() for t in table_entries])\n        pivot = TableEntry.pivot_table(melted=melted)\n        if pivot is None:\n            print(f'Could not generate pivot table for {tag = }')\n        else:\n            stats = cls.get_stats_table(df=pivot)\n\n        save_path_partial = out_dir.joinpath(*tuple(atleast_1d(tag)))\n        save_path_partial.parent.mkdir(exist_ok=True, parents=True)\n        print(f'Saving to {str(save_path_partial)}_*.csv')\n\n        melted.to_csv(save_path_partial.with_stem(save_path_partial.stem + '_melted').with_suffix('.csv'), index=False)\n        if pivot is not None:\n            pivot.to_csv(save_path_partial.with_stem(save_path_partial.stem + '_pivot').with_suffix('.csv'), index=True)\n            stats.to_csv(save_path_partial.with_stem(save_path_partial.stem + '_stats').with_suffix('.csv'), index=True)\n\n    @classmethod\n    def get_stats_table(\n            cls, \n            df: pd.DataFrame,\n        ):\n        \"\"\"\n        Computes multiple statistics for each column\n\n        Args:\n            df (pd.DataFrame): DataFrame for which the column statistics are to be calculated.\n\n        Returns:\n            (pd.DataFrame): Dataframe having statistics (column headers) for each of the columns\n                of the input `df`.  The columns of `df` will be the row indices of the stats table.\n        \"\"\"\n        stats = {\n            'min': df.min(axis=0),\n            'max': df.max(axis=0),\n            'mean': df.mean(axis=0),\n            'sigma3': df.std(axis=0)*3,\n        }\n        df = pd.DataFrame(stats, index=df.columns)\n        df.index.name = 'Name'\n        return df\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.TableBuilder.get_stats_table","title":"get_stats_table  <code>classmethod</code>","text":"<pre><code>get_stats_table(df: DataFrame)\n</code></pre> <p>Computes multiple statistics for each column</p> <p>Parameters:</p> <ul> <li> <code>df</code>               (<code>DataFrame</code>)           \u2013            <p>DataFrame for which the column statistics are to be calculated.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>Dataframe having statistics (column headers) for each of the columns of the input <code>df</code>.  The columns of <code>df</code> will be the row indices of the stats table.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>@classmethod\ndef get_stats_table(\n        cls, \n        df: pd.DataFrame,\n    ):\n    \"\"\"\n    Computes multiple statistics for each column\n\n    Args:\n        df (pd.DataFrame): DataFrame for which the column statistics are to be calculated.\n\n    Returns:\n        (pd.DataFrame): Dataframe having statistics (column headers) for each of the columns\n            of the input `df`.  The columns of `df` will be the row indices of the stats table.\n    \"\"\"\n    stats = {\n        'min': df.min(axis=0),\n        'max': df.max(axis=0),\n        'mean': df.mean(axis=0),\n        'sigma3': df.std(axis=0)*3,\n    }\n    df = pd.DataFrame(stats, index=df.columns)\n    df.index.name = 'Name'\n    return df\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.TableBuilder.load_table","title":"load_table","text":"<pre><code>load_table(tag: Hashable)\n</code></pre> <p>Collects table entries from JSON files corresponding to given tag and processes them.</p> <p>Saves CSV files for the melted data frame, pivot dataframe, and pivot dataframe stats.</p> <p>File names will all use the tag with different suffixes  <code>'tag_melted.csv'</code>, <code>'tag_pivot.csv'</code>, <code>'name_stats.csv'</code>.</p> <p>Parameters:</p> <ul> <li> <code>tag</code>               (<code>Hashable</code>)           \u2013            <p>product tag for which to collect and process.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def load_table(\n        self,\n        tag: Hashable,\n    ):\n    \"\"\"\n    Collects table entries from JSON files corresponding to given tag and processes them.\n\n    Saves CSV files for the melted data frame, pivot dataframe, and pivot dataframe stats.\n\n    File names will all use the tag with different suffixes \n    `'tag_melted.csv'`, `'tag_pivot.csv'`, `'name_stats.csv'`.\n\n    Args:\n        tag (Hashable): product tag for which to collect and process.\n    \"\"\"\n    print(f'Making table for {tag = }')\n\n    table_entries: List[TableEntry] = []\n    for subdir in self.in_dirs:\n        collection = DataProductCollection.model_validate_json(subdir.joinpath(DATA_PRODUCTS_FNAME).read_text())\n        table_entries.extend(collection.get_products(tag=tag, object_type=TableEntry).elements)\n\n    self.process_table_entries(tag=tag, table_entries=table_entries, out_dir=self.out_dir)\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.TableBuilder.process_table_entries","title":"process_table_entries  <code>classmethod</code>","text":"<pre><code>process_table_entries(\n    tag: Hashable,\n    table_entries: List[TableEntry],\n    out_dir: Path,\n)\n</code></pre> <p>Saves CSV files for the melted data frame, pivot dataframe, and pivot dataframe stats.</p> <p>File names will all use the tag with different suffixes  <code>'tag_melted.csv'</code>, <code>'tag_pivot.csv'</code>, <code>'name_stats.csv'</code>.</p> <p>Parameters:</p> <ul> <li> <code>tag</code>               (<code>Hashable</code>)           \u2013            <p>product tag for which to collect and process.</p> </li> <li> <code>table_entries</code>               (<code>List[TableEntry]</code>)           \u2013            <p>List of table entries</p> </li> <li> <code>out_dir</code>               (<code>Path</code>)           \u2013            <p>Directory to which table CSV files should be saved</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>@classmethod\ndef process_table_entries(\n        cls,\n        tag: Hashable,\n        table_entries: List[TableEntry],\n        out_dir: Path,\n    ):\n    \"\"\"\n\n    Saves CSV files for the melted data frame, pivot dataframe, and pivot dataframe stats.\n\n    File names will all use the tag with different suffixes \n    `'tag_melted.csv'`, `'tag_pivot.csv'`, `'name_stats.csv'`.\n\n    Args:\n        tag (Hashable): product tag for which to collect and process.\n        table_entries (List[TableEntry]): List of table entries\n        out_dir (Path): Directory to which table CSV files should be saved\n    \"\"\"\n    melted = pd.DataFrame([t.get_entry_dict() for t in table_entries])\n    pivot = TableEntry.pivot_table(melted=melted)\n    if pivot is None:\n        print(f'Could not generate pivot table for {tag = }')\n    else:\n        stats = cls.get_stats_table(df=pivot)\n\n    save_path_partial = out_dir.joinpath(*tuple(atleast_1d(tag)))\n    save_path_partial.parent.mkdir(exist_ok=True, parents=True)\n    print(f'Saving to {str(save_path_partial)}_*.csv')\n\n    melted.to_csv(save_path_partial.with_stem(save_path_partial.stem + '_melted').with_suffix('.csv'), index=False)\n    if pivot is not None:\n        pivot.to_csv(save_path_partial.with_stem(save_path_partial.stem + '_pivot').with_suffix('.csv'), index=True)\n        stats.to_csv(save_path_partial.with_stem(save_path_partial.stem + '_stats').with_suffix('.csv'), index=True)\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.TableEntry","title":"TableEntry","text":"<p>               Bases: <code>DataProduct</code></p> <p>Defines an entry to be collected into a table.</p> <p>Collected table entries will be printed in three forms when possible: melted, pivot (when possible), and stats (on pivot columns, when possible).</p> <p>Attributes:</p> <ul> <li> <code>product_type</code>               (<code>Literal['Trace2D']</code>)           \u2013            <p>Name of class type to be used as a constructor.</p> </li> <li> <code>row</code>               (<code>float | str</code>)           \u2013            <p>Value to be binned</p> </li> <li> <code>col</code>               (<code>float | str</code>)           \u2013            <p>Hashable tags used to sort data products</p> </li> <li> <code>value</code>               (<code>float | str</code>)           \u2013            <p>Style of histogram display</p> </li> <li> <code>unit</code>               (<code>str | None</code>)           \u2013            <p>Format to apply to single axis figure</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>class TableEntry(DataProduct):\n    \"\"\"\n    Defines an entry to be collected into a table.\n\n    Collected table entries will be printed in three forms when possible: melted, pivot (when possible), and stats (on pivot columns, when possible).\n\n    Attributes:\n        product_type (Literal['Trace2D']): Name of class type to be used as a constructor.\n        row (float | str): Value to be binned\n        col (float | str): Hashable tags used to sort data products\n        value (float | str): Style of histogram display\n        unit (str | None): Format to apply to single axis figure\n    \"\"\"\n    product_type: Literal['TableEntry'] = 'TableEntry'\n    row: float | str\n    col: float | str\n    value: float | str | bool\n    unit: str | None\n\n    class Config:\n        extra = \"forbid\"\n\n    def get_entry_dict(self):\n        \"\"\"\n        Returns a dictionary of entries to be used in creating a table.\n\n        Returns:\n            (dict[str, str | float]): Dictionary of entries to be used in creating a melted [DataFrame][pandas.DataFrame]\n        \"\"\"\n        return {'row': self.row, 'col': self.col, 'value': self.value, 'unit': self.unit}\n\n    @classmethod\n    def pivot_table(cls, melted: pd.DataFrame):\n        \"\"\"\n        Attempts to pivot melted row, col, value DataFrame into a wide form DataFrame\n\n        Args:\n            melted (pd.DataFrame): Melted data frame having columns named `'row'`, `'col'`, `'value'`.\n\n        Returns:\n            (pd.DataFrame | None): pivoted DataFrame if pivot works else `None`. Pivot operation fails if \n                row or column index pairs are repeated.\n        \"\"\"\n        try:\n            result = melted.pivot(index='row', columns='col', values='value')\n        except ValueError:\n            result = None\n        return result\n\n    @classmethod\n    def load_and_pivot(cls, path: Path):\n        \"\"\"\n        Loads melted table from csv and pivots to wide form.\n        csv should have columns named `'row'`, `'col'`, and `'value'`.\n\n        Args:\n            path (Path): path to CSV file\n\n        Returns:\n            (pd.DataFrame | None): Pivoted data frame or elese `None` if pivot operation fails.\n        \"\"\"\n        return cls.pivot_table(melted=pd.read_csv(path))\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.TableEntry.get_entry_dict","title":"get_entry_dict","text":"<pre><code>get_entry_dict()\n</code></pre> <p>Returns a dictionary of entries to be used in creating a table.</p> <p>Returns:</p> <ul> <li> <code>dict[str, str | float]</code>           \u2013            <p>Dictionary of entries to be used in creating a melted DataFrame</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def get_entry_dict(self):\n    \"\"\"\n    Returns a dictionary of entries to be used in creating a table.\n\n    Returns:\n        (dict[str, str | float]): Dictionary of entries to be used in creating a melted [DataFrame][pandas.DataFrame]\n    \"\"\"\n    return {'row': self.row, 'col': self.col, 'value': self.value, 'unit': self.unit}\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.TableEntry.load_and_pivot","title":"load_and_pivot  <code>classmethod</code>","text":"<pre><code>load_and_pivot(path: Path)\n</code></pre> <p>Loads melted table from csv and pivots to wide form. csv should have columns named <code>'row'</code>, <code>'col'</code>, and <code>'value'</code>.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>Path</code>)           \u2013            <p>path to CSV file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame | None</code>           \u2013            <p>Pivoted data frame or elese <code>None</code> if pivot operation fails.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>@classmethod\ndef load_and_pivot(cls, path: Path):\n    \"\"\"\n    Loads melted table from csv and pivots to wide form.\n    csv should have columns named `'row'`, `'col'`, and `'value'`.\n\n    Args:\n        path (Path): path to CSV file\n\n    Returns:\n        (pd.DataFrame | None): Pivoted data frame or elese `None` if pivot operation fails.\n    \"\"\"\n    return cls.pivot_table(melted=pd.read_csv(path))\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.TableEntry.pivot_table","title":"pivot_table  <code>classmethod</code>","text":"<pre><code>pivot_table(melted: DataFrame)\n</code></pre> <p>Attempts to pivot melted row, col, value DataFrame into a wide form DataFrame</p> <p>Parameters:</p> <ul> <li> <code>melted</code>               (<code>DataFrame</code>)           \u2013            <p>Melted data frame having columns named <code>'row'</code>, <code>'col'</code>, <code>'value'</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame | None</code>           \u2013            <p>pivoted DataFrame if pivot works else <code>None</code>. Pivot operation fails if  row or column index pairs are repeated.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>@classmethod\ndef pivot_table(cls, melted: pd.DataFrame):\n    \"\"\"\n    Attempts to pivot melted row, col, value DataFrame into a wide form DataFrame\n\n    Args:\n        melted (pd.DataFrame): Melted data frame having columns named `'row'`, `'col'`, `'value'`.\n\n    Returns:\n        (pd.DataFrame | None): pivoted DataFrame if pivot works else `None`. Pivot operation fails if \n            row or column index pairs are repeated.\n    \"\"\"\n    try:\n        result = melted.pivot(index='row', columns='col', values='value')\n    except ValueError:\n        result = None\n    return result\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.Trace2D","title":"Trace2D","text":"<p>               Bases: <code>XYData</code></p> <p>A collection of points comprising a trace. Use the Trace2D.from_xy constructor.</p> <p>Attributes:</p> <ul> <li> <code>product_type</code>               (<code>Literal['Trace2D']</code>)           \u2013            <p>Name of class type to be used as a constructor.</p> </li> <li> <code>points</code>               (<code>List[Point2D]</code>)           \u2013            <p>List of points.  Usually the points would have null values  for <code>marker</code> and <code>format2d</code> fields to save space.</p> </li> <li> <code>pen</code>               (<code>Pen</code>)           \u2013            <p>Style and label information for drawing to matplotlib axes. Only the label information is used in Grafana. Eventually style information will be used in grafana.</p> </li> <li> <code>format2d</code>               (<code>Format2D</code>)           \u2013            <p>Formatting information for matplotlib figure.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>class Trace2D(XYData):\n    \"\"\"\n    A collection of points comprising a trace.\n    Use the [Trace2D.from_xy][trendify.products.Trace2D.from_xy] constructor.\n\n    Attributes:\n        product_type (Literal['Trace2D']): Name of class type to be used as a constructor.\n        points (List[Point2D]): List of points.  Usually the points would have null values \n            for `marker` and `format2d` fields to save space.\n        pen (Pen): Style and label information for drawing to matplotlib axes.\n            Only the label information is used in Grafana.\n            Eventually style information will be used in grafana.\n        format2d (Format2D): Formatting information for matplotlib figure.\n    \"\"\"\n    product_type: Literal['Trace2D'] = 'Trace2D'\n    points: List[Point2D]\n    # x: NDArray[Shape[\"*\"], float]\n    # y: NDArray[Shape[\"*\"], float]\n    pen: Pen = Pen()\n    format2d: Format2D = Format2D()\n\n    class Config:\n        \"\"\"\n        Forbids extra attributes\n        \"\"\"\n        extra = \"forbid\"  \n\n    @property\n    def x(self):\n        \"\"\"\n        Returns an array of x values from `self.points`\n\n        Returns:\n            (NDArray[Shape[\"*\"], float]): array of x values from `self.points`\n        '\"\"\"\n        return np.array([p.x for p in self.points])\n\n    @property\n    def y(self):\n        \"\"\"\n        Returns an array of y values from `self.points`\n\n        Returns:\n            (NDArray[Shape[\"*\"], float]): array of y values from `self.points`\n        \"\"\"\n        return np.array([p.y for p in self.points])\n\n    def propagate_format2d_and_pen(self, marker_symbol='.') -&gt; None:\n        \"\"\"\n        Propagates format and style info to all `self.points` (in-place).\n        I thought this would  be useful for grafana before I learned better methods for propagating the data.\n        It still may end up being useful if my plotting method changes.  Keeping for potential future use case.\n\n        Args:\n            marker_symbol (str): Valid matplotlib marker symbol\n        \"\"\"\n        self.points = [\n            p.model_copy(\n                update={\n                    'tags': self.tags,\n                    'format2d': self.format2d,\n                    'marker': Marker.from_pen(self.pen, symbol=marker_symbol)\n                }\n            ) \n            for p \n            in self.points\n        ]\n\n    @classmethod\n    def from_xy(\n            cls,\n            tags: Tags,\n            x: NDArray[Shape[\"*\"], float],\n            y: NDArray[Shape[\"*\"], float],\n            pen: Pen = Pen(),\n            format2d: Format2D = Format2D(),\n        ):\n        \"\"\"\n        Creates a list of [Point2D][trendify.products.Point2D]s from xy data and returns a new [Trace2D][trendify.products.Trace2D] product.\n\n        Args:\n            tags (Tags): Hashable tags used to sort data products\n            x (NDArray[Shape[\"*\"], float]): x values\n            y (NDArray[Shape[\"*\"], float]): y values\n            pen (Pen): Style and label for trace\n            format2d (Format2D): format to apply to matplotlib\n        \"\"\"\n        return cls(\n            tags = tags,\n            points = [\n                Point2D(\n                    tags=[None],\n                    x=x_,\n                    y=y_,\n                    marker=None,\n                    format2d=None,\n                )\n                for x_, y_\n                in zip(x, y)\n            ],\n            pen=pen,\n            format2d=format2d,\n        )\n\n    def plot_to_ax(self, ax: plt.Axes):\n        \"\"\"\n        Plots xy data from trace to a matplotlib axes object.\n\n        Args:\n            ax (plt.Axes): axes to which xy data should be plotted\n        \"\"\"\n        ax.plot(self.x, self.y, **self.pen.as_scatter_plot_kwargs())\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.Trace2D.x","title":"x  <code>property</code>","text":"<pre><code>x\n</code></pre> <p>Returns an array of x values from <code>self.points</code></p> <p>Returns:</p> <ul> <li> <code>NDArray[Shape['*'], float]</code>           \u2013            <p>array of x values from <code>self.points</code></p> </li> </ul> <p>'</p>"},{"location":"reference/trendify/products/#trendify.products.Trace2D.y","title":"y  <code>property</code>","text":"<pre><code>y\n</code></pre> <p>Returns an array of y values from <code>self.points</code></p> <p>Returns:</p> <ul> <li> <code>NDArray[Shape['*'], float]</code>           \u2013            <p>array of y values from <code>self.points</code></p> </li> </ul>"},{"location":"reference/trendify/products/#trendify.products.Trace2D.Config","title":"Config","text":"<p>Forbids extra attributes</p> Source code in <code>src/trendify/products.py</code> <pre><code>class Config:\n    \"\"\"\n    Forbids extra attributes\n    \"\"\"\n    extra = \"forbid\"  \n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.Trace2D.from_xy","title":"from_xy  <code>classmethod</code>","text":"<pre><code>from_xy(\n    tags: Tags,\n    x: NDArray[Shape[\"*\"], float],\n    y: NDArray[Shape[\"*\"], float],\n    pen: Pen = Pen(),\n    format2d: Format2D = Format2D(),\n)\n</code></pre> <p>Creates a list of Point2Ds from xy data and returns a new Trace2D product.</p> <p>Parameters:</p> <ul> <li> <code>tags</code>               (<code>Tags</code>)           \u2013            <p>Hashable tags used to sort data products</p> </li> <li> <code>x</code>               (<code>NDArray[Shape['*'], float]</code>)           \u2013            <p>x values</p> </li> <li> <code>y</code>               (<code>NDArray[Shape['*'], float]</code>)           \u2013            <p>y values</p> </li> <li> <code>pen</code>               (<code>Pen</code>, default:                   <code>Pen()</code> )           \u2013            <p>Style and label for trace</p> </li> <li> <code>format2d</code>               (<code>Format2D</code>, default:                   <code>Format2D()</code> )           \u2013            <p>format to apply to matplotlib</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>@classmethod\ndef from_xy(\n        cls,\n        tags: Tags,\n        x: NDArray[Shape[\"*\"], float],\n        y: NDArray[Shape[\"*\"], float],\n        pen: Pen = Pen(),\n        format2d: Format2D = Format2D(),\n    ):\n    \"\"\"\n    Creates a list of [Point2D][trendify.products.Point2D]s from xy data and returns a new [Trace2D][trendify.products.Trace2D] product.\n\n    Args:\n        tags (Tags): Hashable tags used to sort data products\n        x (NDArray[Shape[\"*\"], float]): x values\n        y (NDArray[Shape[\"*\"], float]): y values\n        pen (Pen): Style and label for trace\n        format2d (Format2D): format to apply to matplotlib\n    \"\"\"\n    return cls(\n        tags = tags,\n        points = [\n            Point2D(\n                tags=[None],\n                x=x_,\n                y=y_,\n                marker=None,\n                format2d=None,\n            )\n            for x_, y_\n            in zip(x, y)\n        ],\n        pen=pen,\n        format2d=format2d,\n    )\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.Trace2D.plot_to_ax","title":"plot_to_ax","text":"<pre><code>plot_to_ax(ax: Axes)\n</code></pre> <p>Plots xy data from trace to a matplotlib axes object.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Axes</code>)           \u2013            <p>axes to which xy data should be plotted</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def plot_to_ax(self, ax: plt.Axes):\n    \"\"\"\n    Plots xy data from trace to a matplotlib axes object.\n\n    Args:\n        ax (plt.Axes): axes to which xy data should be plotted\n    \"\"\"\n    ax.plot(self.x, self.y, **self.pen.as_scatter_plot_kwargs())\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.Trace2D.propagate_format2d_and_pen","title":"propagate_format2d_and_pen","text":"<pre><code>propagate_format2d_and_pen(marker_symbol='.') -&gt; None\n</code></pre> <p>Propagates format and style info to all <code>self.points</code> (in-place). I thought this would  be useful for grafana before I learned better methods for propagating the data. It still may end up being useful if my plotting method changes.  Keeping for potential future use case.</p> <p>Parameters:</p> <ul> <li> <code>marker_symbol</code>               (<code>str</code>, default:                   <code>'.'</code> )           \u2013            <p>Valid matplotlib marker symbol</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def propagate_format2d_and_pen(self, marker_symbol='.') -&gt; None:\n    \"\"\"\n    Propagates format and style info to all `self.points` (in-place).\n    I thought this would  be useful for grafana before I learned better methods for propagating the data.\n    It still may end up being useful if my plotting method changes.  Keeping for potential future use case.\n\n    Args:\n        marker_symbol (str): Valid matplotlib marker symbol\n    \"\"\"\n    self.points = [\n        p.model_copy(\n            update={\n                'tags': self.tags,\n                'format2d': self.format2d,\n                'marker': Marker.from_pen(self.pen, symbol=marker_symbol)\n            }\n        ) \n        for p \n        in self.points\n    ]\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.XYData","title":"XYData","text":"<p>               Bases: <code>DataProduct</code></p> <p>Base class for children of DataProduct to be plotted ax xy data on a 2D plot</p> Source code in <code>src/trendify/products.py</code> <pre><code>class XYData(DataProduct):\n    \"\"\"\n    Base class for children of DataProduct to be plotted ax xy data on a 2D plot\n    \"\"\"\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.XYDataPlotter","title":"XYDataPlotter","text":"<p>Plots xy data from user-specified directories to a single axis figure</p> <p>Parameters:</p> <ul> <li> <code>in_dirs</code>               (<code>List[Path]</code>)           \u2013            <p>Directories in which to search for data products from JSON files</p> </li> <li> <code>out_dir</code>               (<code>Path</code>)           \u2013            <p>directory to which figure will be output</p> </li> <li> <code>dpi</code>               (<code>int</code>, default:                   <code>500</code> )           \u2013            <p>Saved image resolution</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>class XYDataPlotter:\n    \"\"\"\n    Plots xy data from user-specified directories to a single axis figure\n\n    Args:\n        in_dirs (List[Path]): Directories in which to search for data products from JSON files\n        out_dir (Path): directory to which figure will be output\n        dpi (int): Saved image resolution\n    \"\"\"\n    def __init__(\n            self,\n            in_dirs: List[Path],\n            out_dir: Path,\n            dpi: int = 500,\n        ):\n        self.in_dirs = in_dirs\n        self.out_dir = out_dir\n        self.dpi = dpi\n\n    def plot(\n            self,  \n            tag: Hashable, \n        ):\n        \"\"\"\n        - Collects data from json files in stored `self.in_dirs`, \n        - plots the relevant products,\n        - applies labels and formatting, \n        - saves the figure\n        - closes matplotlib figure\n\n        Args:\n            tag (Hashable): data tag for which products are to be collected and plotted.\n        \"\"\"\n        print(f'Making xy plot for {tag = }')\n        saf = SingleAxisFigure.new(tag=tag)\n\n        for subdir in self.in_dirs:\n            collection = DataProductCollection.model_validate_json(subdir.joinpath(DATA_PRODUCTS_FNAME).read_text())\n            traces: List[Trace2D] = collection.get_products(tag=tag, object_type=Trace2D).elements\n            points: List[Point2D] = collection.get_products(tag=tag, object_type=Point2D).elements\n\n            if points or traces:\n                if points:\n                    markers = set([p.marker for p in points])\n                    for marker in markers:\n                        matching_points = [p for p in points if p.marker == marker]\n                        x = [p.x for p in matching_points]\n                        y = [p.y for p in matching_points]\n                        if x and y:\n                            if marker is not None:\n                                saf.ax.scatter(x, y, **marker.as_scatter_plot_kwargs())\n                            else:\n                                saf.ax.scatter(x, y)\n\n                for trace in traces:\n                    trace.plot_to_ax(saf.ax)\n\n                formats = list(set([p.format2d for p in points if p.format2d] + [t.format2d for t in traces]) - {None})\n                format2d = Format2D.union_from_iterable(formats)\n                saf.apply_format(format2d)\n                # saf.ax.autoscale(enable=True, axis='both', tight=True)\n\n        save_path = self.out_dir.joinpath(*tuple(atleast_1d(tag))).with_suffix('.jpg')\n        save_path.parent.mkdir(exist_ok=True, parents=True)\n        print(f'Saving to {save_path = }')\n        saf.savefig(path=save_path, dpi=self.dpi)\n        del saf\n\n    @classmethod\n    def handle_points_and_traces(\n            cls,\n            tag: Hashable,\n            points: List[Point2D],\n            traces: List[Trace2D],\n            dir_out: Path,\n            dpi: int,\n        ):\n        \"\"\"\n        Plots points and traces, formats figure, saves figure, and closes matplotlinb figure.\n\n        Args:\n            tag (Hashable): Tag  corresponding to the provided points and traces\n            points (List[Point2D]): Points to be scattered\n            traces (List[Trace2D]): List of traces to be plotted\n            dir_out (Path): directory to output the plot\n            dpi (int): resolution of plot\n        \"\"\"\n\n        saf = SingleAxisFigure.new(tag=tag)\n\n        if points:\n            markers = set([p.marker for p in points])\n            for marker in markers:\n                matching_points = [p for p in points if p.marker == marker]\n                x = [p.x for p in matching_points]\n                y = [p.y for p in matching_points]\n                if x and y:\n                    saf.ax.scatter(x, y, **marker.as_scatter_plot_kwargs())\n\n        for trace in traces:\n            trace.plot_to_ax(saf.ax)\n\n        formats = list(set([p.format2d for p in points] + [t.format2d for t in traces]))\n        format2d = Format2D.union_from_iterable(formats)\n        saf.apply_format(format2d)\n        # saf.ax.autoscale(enable=True, axis='both', tight=True)\n\n        save_path = dir_out.joinpath(*tuple(atleast_1d(tag))).with_suffix('.jpg')\n        save_path.parent.mkdir(exist_ok=True, parents=True)\n        print(f'Saving to {save_path = }')\n        saf.savefig(path=save_path, dpi=dpi)\n        del saf\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.XYDataPlotter.handle_points_and_traces","title":"handle_points_and_traces  <code>classmethod</code>","text":"<pre><code>handle_points_and_traces(\n    tag: Hashable,\n    points: List[Point2D],\n    traces: List[Trace2D],\n    dir_out: Path,\n    dpi: int,\n)\n</code></pre> <p>Plots points and traces, formats figure, saves figure, and closes matplotlinb figure.</p> <p>Parameters:</p> <ul> <li> <code>tag</code>               (<code>Hashable</code>)           \u2013            <p>Tag  corresponding to the provided points and traces</p> </li> <li> <code>points</code>               (<code>List[Point2D]</code>)           \u2013            <p>Points to be scattered</p> </li> <li> <code>traces</code>               (<code>List[Trace2D]</code>)           \u2013            <p>List of traces to be plotted</p> </li> <li> <code>dir_out</code>               (<code>Path</code>)           \u2013            <p>directory to output the plot</p> </li> <li> <code>dpi</code>               (<code>int</code>)           \u2013            <p>resolution of plot</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>@classmethod\ndef handle_points_and_traces(\n        cls,\n        tag: Hashable,\n        points: List[Point2D],\n        traces: List[Trace2D],\n        dir_out: Path,\n        dpi: int,\n    ):\n    \"\"\"\n    Plots points and traces, formats figure, saves figure, and closes matplotlinb figure.\n\n    Args:\n        tag (Hashable): Tag  corresponding to the provided points and traces\n        points (List[Point2D]): Points to be scattered\n        traces (List[Trace2D]): List of traces to be plotted\n        dir_out (Path): directory to output the plot\n        dpi (int): resolution of plot\n    \"\"\"\n\n    saf = SingleAxisFigure.new(tag=tag)\n\n    if points:\n        markers = set([p.marker for p in points])\n        for marker in markers:\n            matching_points = [p for p in points if p.marker == marker]\n            x = [p.x for p in matching_points]\n            y = [p.y for p in matching_points]\n            if x and y:\n                saf.ax.scatter(x, y, **marker.as_scatter_plot_kwargs())\n\n    for trace in traces:\n        trace.plot_to_ax(saf.ax)\n\n    formats = list(set([p.format2d for p in points] + [t.format2d for t in traces]))\n    format2d = Format2D.union_from_iterable(formats)\n    saf.apply_format(format2d)\n    # saf.ax.autoscale(enable=True, axis='both', tight=True)\n\n    save_path = dir_out.joinpath(*tuple(atleast_1d(tag))).with_suffix('.jpg')\n    save_path.parent.mkdir(exist_ok=True, parents=True)\n    print(f'Saving to {save_path = }')\n    saf.savefig(path=save_path, dpi=dpi)\n    del saf\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.XYDataPlotter.plot","title":"plot","text":"<pre><code>plot(tag: Hashable)\n</code></pre> <ul> <li>Collects data from json files in stored <code>self.in_dirs</code>, </li> <li>plots the relevant products,</li> <li>applies labels and formatting, </li> <li>saves the figure</li> <li>closes matplotlib figure</li> </ul> <p>Parameters:</p> <ul> <li> <code>tag</code>               (<code>Hashable</code>)           \u2013            <p>data tag for which products are to be collected and plotted.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def plot(\n        self,  \n        tag: Hashable, \n    ):\n    \"\"\"\n    - Collects data from json files in stored `self.in_dirs`, \n    - plots the relevant products,\n    - applies labels and formatting, \n    - saves the figure\n    - closes matplotlib figure\n\n    Args:\n        tag (Hashable): data tag for which products are to be collected and plotted.\n    \"\"\"\n    print(f'Making xy plot for {tag = }')\n    saf = SingleAxisFigure.new(tag=tag)\n\n    for subdir in self.in_dirs:\n        collection = DataProductCollection.model_validate_json(subdir.joinpath(DATA_PRODUCTS_FNAME).read_text())\n        traces: List[Trace2D] = collection.get_products(tag=tag, object_type=Trace2D).elements\n        points: List[Point2D] = collection.get_products(tag=tag, object_type=Point2D).elements\n\n        if points or traces:\n            if points:\n                markers = set([p.marker for p in points])\n                for marker in markers:\n                    matching_points = [p for p in points if p.marker == marker]\n                    x = [p.x for p in matching_points]\n                    y = [p.y for p in matching_points]\n                    if x and y:\n                        if marker is not None:\n                            saf.ax.scatter(x, y, **marker.as_scatter_plot_kwargs())\n                        else:\n                            saf.ax.scatter(x, y)\n\n            for trace in traces:\n                trace.plot_to_ax(saf.ax)\n\n            formats = list(set([p.format2d for p in points if p.format2d] + [t.format2d for t in traces]) - {None})\n            format2d = Format2D.union_from_iterable(formats)\n            saf.apply_format(format2d)\n            # saf.ax.autoscale(enable=True, axis='both', tight=True)\n\n    save_path = self.out_dir.joinpath(*tuple(atleast_1d(tag))).with_suffix('.jpg')\n    save_path.parent.mkdir(exist_ok=True, parents=True)\n    print(f'Saving to {save_path = }')\n    saf.savefig(path=save_path, dpi=self.dpi)\n    del saf\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.atleast_1d","title":"atleast_1d","text":"<pre><code>atleast_1d(obj: Any) -&gt; Iterable\n</code></pre> <p>Converts scalar objec to a list of length 1 or leaves an iterable object unchanged.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>               (<code>Any</code>)           \u2013            <p>Object that needs to be at least 1d</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterable</code>           \u2013            <p>Returns an iterable</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def atleast_1d(obj: Any) -&gt; Iterable:\n    \"\"\"\n    Converts scalar objec to a list of length 1 or leaves an iterable object unchanged.\n\n    Args:\n        obj (Any): Object that needs to be at least 1d\n\n    Returns:\n        (Iterable): Returns an iterable\n    \"\"\"\n    if not should_be_flattened(obj):\n        return [obj]\n    else:\n        return obj\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.flatten","title":"flatten","text":"<pre><code>flatten(obj: Iterable)\n</code></pre> <p>Recursively flattens iterable up to a point (leaves <code>str</code>, <code>bytes</code>, and <code>DataProduct</code> unflattened)</p> <p>Parameters:</p> <ul> <li> <code>obj</code>               (<code>Iterable</code>)           \u2013            <p>Object to be flattened</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterable</code>           \u2013            <p>Flattned iterable</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def flatten(obj: Iterable):\n    \"\"\"\n    Recursively flattens iterable up to a point (leaves `str`, `bytes`, and `DataProduct` unflattened)\n\n    Args:\n        obj (Iterable): Object to be flattened\n\n    Returns:\n        (Iterable): Flattned iterable\n    \"\"\"\n    if not should_be_flattened(obj):\n        yield obj\n    else:\n        for sublist in obj:\n            yield from flatten(sublist)\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.get_sorted_dirs","title":"get_sorted_dirs","text":"<pre><code>get_sorted_dirs(dirs: List[Path])\n</code></pre> <p>Sorts dirs numerically if possible, else alphabetically</p> <p>Parameters:</p> <ul> <li> <code>dirs</code>               (<code>List[Path]</code>)           \u2013            <p>Directories to sort</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[Path]</code>           \u2013            <p>Sorted list of directories</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def get_sorted_dirs(dirs: List[Path]):\n    \"\"\"\n    Sorts dirs numerically if possible, else alphabetically\n\n    Args:\n        dirs (List[Path]): Directories to sort\n\n    Returns:\n        (List[Path]): Sorted list of directories\n    \"\"\"\n    dirs = list(dirs)\n    try:\n        dirs.sort(key=lambda p: int(p.name))\n    except ValueError:\n        dirs.sort()\n    return dirs\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.main","title":"main","text":"<pre><code>main()\n</code></pre> <p>Makes sample data, processes it, and serves it for importing into Grafana</p> Source code in <code>src/trendify/products.py</code> <pre><code>def main():\n    \"\"\"\n    Makes sample data, processes it, and serves it for importing into Grafana\n    \"\"\"\n    here = Path(__file__).parent\n    workdir = here.joinpath('workdir')\n\n    make_sample_data(workdir=workdir, n_folders=100)\n\n    process_dirs = list(workdir.joinpath('models').glob('*/'))\n    products_dir = workdir.joinpath('products')\n    outputs_dir = workdir.joinpath('outputs')\n    grafana_dir = workdir.joinpath('grafana')\n    n_procs = 1\n\n    make_products(\n        product_generator=sample_processor,\n        dirs=process_dirs,\n        n_procs=n_procs,\n    )\n    sort_products(\n        data_dirs=process_dirs,\n        output_dir=products_dir,\n    )\n    make_grafana_dashboard(\n        sorted_products_dir=products_dir,\n        output_dir=grafana_dir,\n        n_procs=n_procs,\n    )\n    make_tables_and_figures(\n        products_dir=products_dir,\n        output_dir=outputs_dir,\n        dpi=500,\n        n_procs=n_procs,\n    )\n    make_include_files(\n        root_dir=outputs_dir,\n        heading_level=2,\n    )\n    process_batch(\n        product_generator=sample_processor, \n        data_dirs=process_dirs, \n        products_dir=products_dir,\n        outputs_dir=outputs_dir, \n        grafana_dir=grafana_dir,\n        n_procs=1,\n        dpi=300,\n        make_tables=True,\n        make_histograms=True,\n        make_xy_plots=True,\n    )\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.make_grafana_dashboard","title":"make_grafana_dashboard","text":"<pre><code>make_grafana_dashboard(\n    sorted_products_dir: Path,\n    output_dir: Path,\n    n_procs: int = 1,\n)\n</code></pre> <p>Makes a JSON file to import to Grafana for displaying tagged data tables, histograms and XY plots.</p> <p>Parameters:</p> <ul> <li> <code>sorted_products_dir</code>               (<code>Path</code>)           \u2013            <p>Root directory into which products have been sorted by tag</p> </li> <li> <code>output_dir</code>               (<code>Path</code>)           \u2013            <p>Root directory into which Grafana dashboard and panal definitions will be written</p> </li> <li> <code>n_procs</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Number of parallel tasks used for processing data product tags</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def make_grafana_dashboard(\n        sorted_products_dir: Path,\n        output_dir: Path,\n        n_procs: int = 1,\n    ):\n    \"\"\"\n    Makes a JSON file to import to Grafana for displaying tagged data tables, histograms and XY plots.\n\n    Args:\n        sorted_products_dir (Path): Root directory into which products have been sorted by tag\n        output_dir (Path): Root directory into which Grafana dashboard and panal definitions will be written\n        n_procs (int): Number of parallel tasks used for processing data product tags\n    \"\"\"\n    print(f'\\n\\n\\nGenerating Grafana Dashboard JSON Spec in {output_dir} based on products in {sorted_products_dir}')\n    output_dir.mkdir(parents=True, exist_ok=True)\n\n    product_dirs = list(sorted_products_dir.glob('**/*/'))\n    panel_dir = output_dir.joinpath('panels')\n    map_callable(\n        DataProductCollection.make_grafana_panels,\n        product_dirs,\n        [panel_dir] * len(product_dirs),\n        n_procs=n_procs,\n    )\n    panels = [gapi.Panel.model_validate_json(p.read_text()) for p in panel_dir.glob('*.json')]\n    dashboard = gapi.Dashboard(panels=panels)\n    output_dir.joinpath('dashboard.json').write_text(dashboard.model_dump_json())\n    print('\\nFinished Generating Grafana Dashboard JSON Spec')\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.make_include_files","title":"make_include_files","text":"<pre><code>make_include_files(\n    root_dir: Path,\n    local_server_path: str | Path = None,\n    mkdocs_include_dir: str | Path = None,\n    heading_level: int | None = None,\n)\n</code></pre> <p>Makes nested include files for inclusion into an MkDocs site.</p> Note <p>I recommend to create a Grafana panel and link to that from the MkDocs site instead.</p> <p>Parameters:</p> <ul> <li> <code>root_dir</code>               (<code>Path</code>)           \u2013            <p>Directory for which the include files should be recursively generated</p> </li> <li> <code>local_server_path</code>               (<code>str | Path | None</code>, default:                   <code>None</code> )           \u2013            <p>What should the beginning of the path look like? Use <code>//localhost:8001/...</code> something like that to work with <code>python -m mkdocs serve</code> while running <code>python -m http.server 8001</code> in order to have interactive updates. Use my python <code>convert_links.py</code> script to update after running <code>python -m mkdocs build</code> in order to fix the links for the MkDocs site.  See this repo for an example.</p> </li> <li> <code>mkdocs_include_dir</code>               (<code>str | Path | None</code>, default:                   <code>None</code> )           \u2013            <p>Path to be used for mkdocs includes. This path should correspond to includ dir in <code>mkdocs.yml</code> file.  (See <code>vulcan_srb_sep</code> repo for example).</p> </li> </ul> <p>Note:</p> <pre><code>Here is how to setup `mkdocs.yml` file to have an `include_dir` that can be used to \ninclude generated markdown files (and the images/CSVs that they reference).\n\n```\nplugins:\n  - macros:\n    include_dir: run_for_record\n```\n</code></pre> Source code in <code>src/trendify/products.py</code> <pre><code>def make_include_files(\n        root_dir: Path,\n        local_server_path: str | Path = None,\n        mkdocs_include_dir: str | Path = None,\n        # products_dir_replacement_path: str | Path = None,\n        heading_level: int | None = None,\n    ):\n    \"\"\"\n    Makes nested include files for inclusion into an MkDocs site.\n\n    Note:\n        I recommend to create a Grafana panel and link to that from the MkDocs site instead.\n\n    Args:\n        root_dir (Path): Directory for which the include files should be recursively generated\n        local_server_path (str|Path|None): What should the beginning of the path look like?\n            Use `//localhost:8001/...` something like that to work with `python -m mkdocs serve`\n            while running `python -m http.server 8001` in order to have interactive updates.\n            Use my python `convert_links.py` script to update after running `python -m mkdocs build`\n            in order to fix the links for the MkDocs site.  See this repo for an example.\n        mkdocs_include_dir (str|Path|None): Path to be used for mkdocs includes.\n            This path should correspond to includ dir in `mkdocs.yml` file.  (See `vulcan_srb_sep` repo for example).\n\n    Note:\n\n        Here is how to setup `mkdocs.yml` file to have an `include_dir` that can be used to \n        include generated markdown files (and the images/CSVs that they reference).\n\n        ```\n        plugins:\n          - macros:\n            include_dir: run_for_record\n        ```\n\n    \"\"\"\n\n    INCLUDE = 'include.md'\n    dirs = list(root_dir.glob('**/'))\n    dirs.sort()\n    if dirs:\n        min_len = np.min([len(list(p.parents)) for p in dirs])\n        for s in dirs:\n            child_dirs = list(s.glob('*/'))\n            child_dirs.sort()\n            tables_to_include: List[Path] = [x for x in flatten([list(s.glob(p, case_sensitive=False)) for p in ['*pivot.csv', '*stats.csv']])]\n            figures_to_include: List[Path] = [x for x in flatten([list(s.glob(p, case_sensitive=False)) for p in ['*.jpg', '*.png']])]\n            children_to_include: List[Path] = [\n                c.resolve().joinpath(INCLUDE)\n                for c in child_dirs\n            ]\n            if local_server_path is not None:\n                figures_to_include = [\n                    Path(local_server_path).joinpath(x.relative_to(root_dir))\n                    for x in figures_to_include\n                ]\n            if mkdocs_include_dir is not None:\n                tables_to_include = [\n                    x.relative_to(mkdocs_include_dir.parent)\n                    for x in tables_to_include\n                ]\n                children_to_include = [\n                    x.relative_to(mkdocs_include_dir)\n                    for x in children_to_include\n                ]\n\n            bb_open = r'{{'\n            bb_close = r'}}'\n            fig_inclusion_statements = [\n                f'![]({x})' \n                for x in figures_to_include\n            ]\n            table_inclusion_statements = [\n                f\"{bb_open} read_csv('{x}', disable_numparse=True) {bb_close}\"\n                for x in tables_to_include\n            ]\n            child_inclusion_statments = [\n                \"{% include '\" + str(x) + \"' %}\"\n                for x in children_to_include\n            ]\n            fig_inclusion_statements.sort()\n            table_inclusion_statements.sort()\n            child_inclusion_statments.sort()\n            inclusions = table_inclusion_statements + fig_inclusion_statements + child_inclusion_statments\n\n            header = (\n                ''.join(['#']*((len(list(s.parents))-min_len)+heading_level)) + s.name \n                if heading_level is not None and len(inclusions) &gt; 1\n                else ''\n            )\n            text = '\\n\\n'.join([header] + inclusions)\n\n            s.joinpath(INCLUDE).write_text(text)\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.make_products","title":"make_products","text":"<pre><code>make_products(\n    product_generator: (\n        Callable[[Path], DataProductCollection] | None\n    ),\n    dirs: List[Path],\n    n_procs: int = 1,\n)\n</code></pre> <p>Maps <code>product_generator</code> over <code>dirs_in</code> to produce data product JSON files in those directories. Sorts the generated data products into a nested file structure starting from <code>dir_products</code>. Nested folders are generated for tags that are Tuples.  Sorted data files are named according to the directory from which they were loaded.</p> <p>Parameters:</p> <ul> <li> <code>product_generator</code>               (<code>Callable[[Path], ProductList] | None</code>)           \u2013            <p>A callable function that returns a list of data products given a working directory.</p> </li> <li> <code>dirs</code>               (<code>List[Path]</code>)           \u2013            <p>Directories over which to map the <code>product_generator</code></p> </li> <li> <code>n_procs</code>               (<code>int = 1</code>, default:                   <code>1</code> )           \u2013            <p>Number of processes to run in parallel.  If <code>n_procs==1</code>, directories will be processed sequentially (easier for debugging since the full traceback will be provided). If <code>n_procs &gt; 1</code>, a ProcessPoolExecutor will be used to load and process directories and/or tags in parallel.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def make_products(\n        product_generator: Callable[[Path], DataProductCollection] | None,\n        dirs: List[Path],\n        n_procs: int = 1,\n    ):\n    \"\"\"\n    Maps `product_generator` over `dirs_in` to produce data product JSON files in those directories.\n    Sorts the generated data products into a nested file structure starting from `dir_products`.\n    Nested folders are generated for tags that are Tuples.  Sorted data files are named according to the\n    directory from which they were loaded.\n\n    Args:\n        product_generator (Callable[[Path], ProductList] | None): A callable function that returns\n            a list of data products given a working directory.\n        dirs (List[Path]): Directories over which to map the `product_generator`\n        n_procs (int = 1): Number of processes to run in parallel.  If `n_procs==1`, directories will be\n            processed sequentially (easier for debugging since the full traceback will be provided).\n            If `n_procs &gt; 1`, a [ProcessPoolExecutor][concurrent.futures.ProcessPoolExecutor] will\n            be used to load and process directories and/or tags in parallel.\n    \"\"\"\n    sorted_dirs = get_sorted_dirs(dirs=dirs)\n\n    if product_generator is None:\n        print('No data product generator provided')\n    else:\n        print('\\n\\n\\nGenerating tagged DataProducts and writing to JSON files...\\n')\n        map_callable(\n            DataProductGenerator(processor=product_generator).process_and_save,\n            sorted_dirs,\n            n_procs=n_procs,\n        )\n        print('\\nFinished generating tagged DataProducts and writing to JSON files')\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.make_sample_data","title":"make_sample_data","text":"<pre><code>make_sample_data(workdir: Path, n_folders: int = 10)\n</code></pre> <p>Makes some sample data from which to generate products</p> <p>Parameters:</p> <ul> <li> <code>workdir</code>               (<code>Path</code>)           \u2013            <p>Directory in which the sample data is to be generated</p> </li> <li> <code>n_folders</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Number of sample data files to generate (in separate subfolders).</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def make_sample_data(workdir: Path, n_folders: int = 10):\n    \"\"\"\n    Makes some sample data from which to generate products\n\n    Args:\n        workdir (Path): Directory in which the sample data is to be generated\n        n_folders (int): Number of sample data files to generate (in separate subfolders).\n    \"\"\"\n    models_dir = workdir.joinpath('models')\n    models_dir.mkdir(parents=True, exist_ok=True)\n\n    for n in range(n_folders):\n        subdir = models_dir.joinpath(str(n))\n        subdir.mkdir(exist_ok=True, parents=True)\n\n        n_samples = np.random.randint(low=40, high=50)\n        t = np.linspace(0, 1, n_samples)\n        periods = np.random.uniform(low=0.9, high=1.1, size=5)\n        amplitudes = np.random.uniform(low=0.9, high=1.1, size=5)\n\n        n_inputs = {'n_samples': n_samples}\n        p_inputs = {f'p{n}': p for n, p in enumerate(periods)}\n        a_inputs = {f'a{n}': a for n, a in enumerate(amplitudes)}\n        inputs = {}\n        inputs.update(n_inputs)\n        inputs.update(p_inputs)\n        inputs.update(a_inputs)\n        pd.Series(inputs).to_csv(subdir.joinpath('stdin.csv'), header=False)\n\n        d = [t] + [a*np.sin(t*(2*np.pi/p)) for p, a in zip(periods, amplitudes)]\n        df = pd.DataFrame(np.array(d).transpose(), columns=['a', 'c0', 'c1', 'c2', 'c3', 'c4'])\n        df.to_csv(subdir.joinpath('results.csv'), index=False)\n\n    csv_files = list(models_dir.glob('**/stdin.csv'))\n    csv_files.sort()\n    input_series = []\n    for csv in csv_files:\n        series: pd.Series = pd.read_csv(csv, index_col=0, header=None).squeeze() \n        series.name = int(csv.parent.stem)\n        input_series.append(series)\n\n    aggregate_dir = workdir.joinpath('aggregate')\n    aggregate_dir.mkdir(parents=True, exist_ok=True)\n    aggregate_df = pd.concat(input_series, axis=1).transpose()\n    aggregate_df.index.name = 'Directory'\n    aggregate_df.to_csv(aggregate_dir.joinpath('stdin.csv'))\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.make_tables_and_figures","title":"make_tables_and_figures","text":"<pre><code>make_tables_and_figures(\n    products_dir: Path,\n    output_dir: Path,\n    dpi: int = 500,\n    n_procs: int = 1,\n    make_tables: bool = True,\n    make_xy_plots: bool = True,\n    make_histograms: bool = True,\n)\n</code></pre> <p>Makes CSV tables and creates plots (using matplotlib).</p> <p>Tags will be processed in parallel and output in nested directory structure under <code>output_dir</code>.</p> <p>Parameters:</p> <ul> <li> <code>products_dir</code>               (<code>Path</code>)           \u2013            <p>Directory to which the sorted data products will be written</p> </li> <li> <code>output_dir</code>               (<code>Path</code>)           \u2013            <p>Directory to which tables and matplotlib histograms and plots will be written if the appropriate boolean variables <code>make_tables</code>, <code>make_xy_plots</code>, <code>make_histograms</code> are true.</p> </li> <li> <code>n_procs</code>               (<code>int = 1</code>, default:                   <code>1</code> )           \u2013            <p>Number of processes to run in parallel.  If <code>n_procs==1</code>, directories will be processed sequentially (easier for debugging since the full traceback will be provided). If <code>n_procs &gt; 1</code>, a ProcessPoolExecutor will be used to load and process directories and/or tags in parallel.</p> </li> <li> <code>dpi</code>               (<code>int = 500</code>, default:                   <code>500</code> )           \u2013            <p>Resolution of output plots when using matplotlib  (for <code>make_xy_plots==True</code> and/or <code>make_histograms==True</code>)</p> </li> <li> <code>make_tables</code>               (<code>bool = True</code>, default:                   <code>True</code> )           \u2013            <p>Whether or not to collect the  <code>TableEntry</code> products and write them to CSV files (<code>&lt;tag&gt;_melted.csv</code> with <code>&lt;tag&gt;_pivot.csv</code> and <code>&lt;tag&gt;_stats.csv</code> when possible).</p> </li> <li> <code>make_xy_plots</code>               (<code>bool = True</code>, default:                   <code>True</code> )           \u2013            <p>Whether or not to plot the <code>XYData</code> products using matplotlib</p> </li> <li> <code>make_histograms</code>               (<code>bool = True</code>, default:                   <code>True</code> )           \u2013            <p>Whether or not to generate histograms of the  <code>HistogramEntry</code> products using matplotlib.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def make_tables_and_figures(\n        products_dir: Path,\n        output_dir: Path,\n        dpi: int = 500,\n        n_procs: int = 1,\n        make_tables: bool = True,\n        make_xy_plots: bool = True,\n        make_histograms: bool = True,\n    ):\n    \"\"\"\n    Makes CSV tables and creates plots (using matplotlib).\n\n    Tags will be processed in parallel and output in nested directory structure under `output_dir`.\n\n    Args:\n        products_dir (Path): Directory to which the sorted data products will be written\n        output_dir (Path): Directory to which tables and matplotlib histograms and plots will be written if\n            the appropriate boolean variables `make_tables`, `make_xy_plots`, `make_histograms` are true.\n        n_procs (int = 1): Number of processes to run in parallel.  If `n_procs==1`, directories will be\n            processed sequentially (easier for debugging since the full traceback will be provided).\n            If `n_procs &gt; 1`, a [ProcessPoolExecutor][concurrent.futures.ProcessPoolExecutor] will\n            be used to load and process directories and/or tags in parallel.\n        dpi (int = 500): Resolution of output plots when using matplotlib \n            (for `make_xy_plots==True` and/or `make_histograms==True`)\n        make_tables (bool = True): Whether or not to collect the \n            [`TableEntry`][trendify.products.TableEntry] products and write them\n            to CSV files (`&lt;tag&gt;_melted.csv` with `&lt;tag&gt;_pivot.csv` and `&lt;tag&gt;_stats.csv` when possible).\n        make_xy_plots (bool = True): Whether or not to plot the [`XYData`][trendify.products.XYData] products using matplotlib\n        make_histograms (bool = True): Whether or not to generate histograms of the \n            [`HistogramEntry`][trendify.products.HistogramEntry] products\n            using matplotlib.\n    \"\"\"\n    if make_tables or make_xy_plots or make_histograms:\n        product_dirs = list(products_dir.glob('**/*/'))\n        out_dirs = [output_dir]*len(product_dirs)\n        table_makes = [make_tables]*len(product_dirs)\n        xy_plot_makes = [make_xy_plots]*len(product_dirs)\n        histogram_makes = [make_histograms]*len(product_dirs)\n        dpis = [dpi]*len(product_dirs)\n        map_callable(\n            DataProductCollection.process_single_tag_collection,\n            product_dirs,\n            out_dirs,\n            table_makes,\n            xy_plot_makes,\n            histogram_makes,\n            dpis,\n            n_procs=n_procs,\n        )\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.map_callable","title":"map_callable","text":"<pre><code>map_callable(\n    f: Callable[[Path], DataProductCollection],\n    *iterables,\n    n_procs: int = 1,\n    mp_context=None\n)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>f</code>               (<code>Callable[[Path], DataProductCollection]</code>)           \u2013            <p>Function to be mapped</p> </li> <li> <code>iterables</code>               (<code>Tuple[Iterable, ...]</code>, default:                   <code>()</code> )           \u2013            <p>iterables of arguments for mapped function <code>f</code></p> </li> <li> <code>n_procs</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Number of parallel processes to run</p> </li> <li> <code>mp_context</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Context to use for creating new processes (see <code>multiprocessing</code> package documentation)</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def map_callable(\n        f: Callable[[Path], DataProductCollection], \n        *iterables, \n        n_procs: int=1, \n        mp_context=None,\n    ):\n    \"\"\"\n    Args:\n        f (Callable[[Path], DataProductCollection]): Function to be mapped\n        iterables (Tuple[Iterable, ...]): iterables of arguments for mapped function `f`\n        n_procs (int): Number of parallel processes to run\n        mp_context (str): Context to use for creating new processes (see `multiprocessing` package documentation)\n    \"\"\"\n    if n_procs &gt; 1:\n        with ProcessPoolExecutor(max_workers=n_procs, mp_context=mp_context) as executor:\n            result = list(executor.map(f, *iterables))\n    else:\n        result = [f(*arg_tuple) for arg_tuple in zip(*iterables)]\n\n    return result\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.process_batch","title":"process_batch","text":"<pre><code>process_batch(\n    product_generator: (\n        Callable[[Path], DataProductCollection] | None\n    ),\n    data_dirs: List[Path],\n    products_dir: Path,\n    outputs_dir: Path,\n    grafana_dir: Path | None = None,\n    n_procs: int = 1,\n    dpi: int = 500,\n    make_tables: bool = True,\n    make_xy_plots: bool = True,\n    make_histograms: bool = True,\n)\n</code></pre> <p>Maps <code>product_generator</code> over <code>dirs_in</code> to produce data product JSON files in those directories. Sorts the generated data products into a nested file structure starting from <code>dir_products</code>. Nested folders are generated for tags that are Tuples.  Sorted data files are named according to the directory from which they were loaded.</p> <p>Parameters:</p> <ul> <li> <code>product_generator</code>               (<code>Callable[[Path], ProductList] | None</code>)           \u2013            <p>A callable function that returns a list of data products given a working directory.</p> </li> <li> <code>data_dirs</code>               (<code>List[Path]</code>)           \u2013            <p>Directories over which to map the <code>product_generator</code></p> </li> <li> <code>products_dir</code>               (<code>Path</code>)           \u2013            <p>Directory to which the sorted data products will be written</p> </li> <li> <code>outputs_dir</code>               (<code>Path</code>)           \u2013            <p>Directory to which tables and matplotlib histograms and plots will be written if the appropriate boolean variables <code>make_tables</code>, <code>make_xy_plots</code>, <code>make_histograms</code> are true.</p> </li> <li> <code>grafana_dir</code>               (<code>Path</code>, default:                   <code>None</code> )           \u2013            <p>Directory to which generated grafana panels and dashboard will be written.</p> </li> <li> <code>n_procs</code>               (<code>int = 1</code>, default:                   <code>1</code> )           \u2013            <p>Number of processes to run in parallel.  If <code>n_procs==1</code>, directories will be processed sequentially (easier for debugging since the full traceback will be provided). If <code>n_procs &gt; 1</code>, a ProcessPoolExecutor will be used to load and process directories and/or tags in parallel.</p> </li> <li> <code>dpi</code>               (<code>int = 500</code>, default:                   <code>500</code> )           \u2013            <p>Resolution of output plots when using matplotlib  (for <code>make_xy_plots==True</code> and/or <code>make_histograms==True</code>)</p> </li> <li> <code>make_tables</code>               (<code>bool = True</code>, default:                   <code>True</code> )           \u2013            <p>Whether or not to collect the  <code>TableEntry</code> products and write them to CSV files (<code>&lt;tag&gt;_melted.csv</code> with <code>&lt;tag&gt;_pivot.csv</code> and <code>&lt;tag&gt;_stats.csv</code> when possible).</p> </li> <li> <code>make_xy_plots</code>               (<code>bool = True</code>, default:                   <code>True</code> )           \u2013            <p>Whether or not to plot the <code>XYData</code> products using matplotlib</p> </li> <li> <code>make_histograms</code>               (<code>bool = True</code>, default:                   <code>True</code> )           \u2013            <p>Whether or not to generate histograms of the  <code>HistogramEntry</code> products using matplotlib.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def process_batch(\n        product_generator: Callable[[Path], DataProductCollection] | None,\n        data_dirs: List[Path],\n        products_dir: Path,\n        outputs_dir: Path,\n        grafana_dir: Path | None = None,\n        n_procs: int = 1,\n        dpi: int = 500,\n        make_tables: bool = True,\n        make_xy_plots: bool = True,\n        make_histograms: bool = True,\n    ):\n    \"\"\"\n    Maps `product_generator` over `dirs_in` to produce data product JSON files in those directories.\n    Sorts the generated data products into a nested file structure starting from `dir_products`.\n    Nested folders are generated for tags that are Tuples.  Sorted data files are named according to the\n    directory from which they were loaded.\n\n    Args:\n        product_generator (Callable[[Path], ProductList] | None): A callable function that returns\n            a list of data products given a working directory.\n        data_dirs (List[Path]): Directories over which to map the `product_generator`\n        products_dir (Path): Directory to which the sorted data products will be written\n        outputs_dir (Path): Directory to which tables and matplotlib histograms and plots will be written if\n            the appropriate boolean variables `make_tables`, `make_xy_plots`, `make_histograms` are true.\n        grafana_dir (Path): Directory to which generated grafana panels and dashboard will be written.\n        n_procs (int = 1): Number of processes to run in parallel.  If `n_procs==1`, directories will be\n            processed sequentially (easier for debugging since the full traceback will be provided).\n            If `n_procs &gt; 1`, a [ProcessPoolExecutor][concurrent.futures.ProcessPoolExecutor] will\n            be used to load and process directories and/or tags in parallel.\n        dpi (int = 500): Resolution of output plots when using matplotlib \n            (for `make_xy_plots==True` and/or `make_histograms==True`)\n        make_tables (bool = True): Whether or not to collect the \n            [`TableEntry`][trendify.products.TableEntry] products and write them\n            to CSV files (`&lt;tag&gt;_melted.csv` with `&lt;tag&gt;_pivot.csv` and `&lt;tag&gt;_stats.csv` when possible).\n        make_xy_plots (bool = True): Whether or not to plot the [`XYData`][trendify.products.XYData] products using matplotlib\n        make_histograms (bool = True): Whether or not to generate histograms of the \n            [`HistogramEntry`][trendify.products.HistogramEntry] products\n            using matplotlib.\n    \"\"\"\n    make_products(\n        product_generator=product_generator,\n        dirs=data_dirs,\n        n_procs=n_procs,\n    )\n    sort_products(\n        data_dirs=data_dirs,\n        output_dir=products_dir,\n    )\n    make_grafana_dashboard(\n        sorted_products_dir=products_dir,\n        output_dir=grafana_dir,\n        n_procs=n_procs,\n    )\n    make_tables_and_figures(\n        products_dir=products_dir,\n        output_dir=outputs_dir,\n        dpi=dpi,\n        n_procs=n_procs,\n        make_tables=make_tables,\n        make_xy_plots=make_xy_plots,\n        make_histograms=make_histograms,\n    )\n    make_include_files(\n        root_dir=outputs_dir,\n        heading_level=2,\n    )\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.sample_processor","title":"sample_processor","text":"<pre><code>sample_processor(workdir: Path) -&gt; List[DataProduct]\n</code></pre> <p>Processes the generated sample data in given workdir returning several types of data products.</p> <p>Parameters:</p> <ul> <li> <code>workdir</code>               (<code>Path</code>)           \u2013            <p>Directory containing sample data.</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def sample_processor(workdir: Path) -&gt; List[DataProduct]:\n    \"\"\"\n    Processes the generated sample data in given workdir returning several types of data products.\n\n    Args:\n        workdir (Path): Directory containing sample data.\n    \"\"\"\n    df = pd.read_csv(workdir.joinpath('results.csv'))\n    df = df.set_index('a', drop=True)\n    traces = [\n        Trace2D.from_xy(\n            x=df.index,\n            y=df[col].values,\n            tags=['trace_plots'],\n            pen=Pen(label=f'{col} {int(workdir.name)}'),\n            format2d=Format2D(title_legend='Column'),\n        )\n        for col in df.columns\n    ]\n    points = [\n        Point2D(\n            x=workdir.name,\n            y=len(trace.y),\n            marker=Marker(\n                size=10,\n                label=trace.pen.label,\n            ),\n            format2d=Format2D(title_fig='N Points'),\n            tags=['scatter_plots'],\n        )\n        for trace\n        in traces\n    ]\n    table_entries = [\n        TableEntry(\n            row=workdir.name,\n            col=name,\n            value=len(series),\n            tags=['tables'],\n            unit=None,\n        )\n        for name, series in df.items()\n    ]\n\n    return traces + points + table_entries\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.should_be_flattened","title":"should_be_flattened","text":"<pre><code>should_be_flattened(obj: Any)\n</code></pre> <p>Checks if object is an iterable container that should be flattened. <code>DataProduct</code>s will not be flattened.  Strings will not be flattened. Everything else will be flattened.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>               (<code>Any</code>)           \u2013            <p>Object to be tested</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Whether or not to flatten object</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def should_be_flattened(obj: Any):\n    \"\"\"\n    Checks if object is an iterable container that should be flattened.\n    `DataProduct`s will not be flattened.  Strings will not be flattened.\n    Everything else will be flattened.\n\n    Args:\n        obj (Any): Object to be tested\n\n    Returns:\n        (bool): Whether or not to flatten object\n    \"\"\"\n    return isinstance(obj, Iterable) and not isinstance(obj, (str, bytes, DataProduct))\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.sort_products","title":"sort_products","text":"<pre><code>sort_products(data_dirs: List[Path], output_dir: Path)\n</code></pre> <p>Loads the tagged data products from <code>data_dirs</code> and sorts them (by tag) into a nested folder structure rooted at <code>output_dir</code>.</p> <p>Parameters:</p> <ul> <li> <code>data_dirs</code>               (<code>List[Path]</code>)           \u2013            <p>Directories containing JSON data product files</p> </li> <li> <code>output_dir</code>               (<code>Path</code>)           \u2013            <p>Directory to which sorted products will be written</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def sort_products(\n        data_dirs: List[Path],\n        output_dir: Path,\n    ):\n    \"\"\"\n    Loads the tagged data products from `data_dirs` and sorts them (by tag) into a nested folder structure rooted at `output_dir`.\n\n    Args:\n        data_dirs (List[Path]): Directories containing JSON data product files\n        output_dir (Path): Directory to which sorted products will be written\n    \"\"\"\n    sorted_data_dirs = get_sorted_dirs(dirs=data_dirs)\n\n    print('\\n\\n\\nSorting data by tags')\n    output_dir.mkdir(parents=True, exist_ok=True)\n\n    DataProductCollection.sort_by_tags(\n        dirs_in=sorted_data_dirs,\n        dir_out=output_dir,\n    )\n    print('\\nFinished sorting by tags')\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.squeeze","title":"squeeze","text":"<pre><code>squeeze(obj: Union[Iterable, Any])\n</code></pre> <p>Returns a scalar if object is iterable of length 1 else returns object.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>               (<code>Union[Iterable, Any]</code>)           \u2013            <p>An object to be squeezed if possible</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>Either iterable or scalar if possible</p> </li> </ul> Source code in <code>src/trendify/products.py</code> <pre><code>def squeeze(obj: Union[Iterable, Any]):\n    \"\"\"\n    Returns a scalar if object is iterable of length 1 else returns object.\n\n    Args:\n        obj (Union[Iterable, Any]): An object to be squeezed if possible\n\n    Returns:\n        (Any): Either iterable or scalar if possible\n    \"\"\"\n    if should_be_flattened(obj) and len(obj) == 1:\n        return obj[0]\n    else:\n        return obj\n</code></pre>"},{"location":"reference/trendify/server/","title":"server","text":""},{"location":"reference/trendify/server/#trendify.server","title":"trendify.server","text":"<p>Defines database server for DataProductCollection from analyses</p>"},{"location":"reference/trendify/server/#trendify.server.get_data_products","title":"get_data_products","text":"<pre><code>get_data_products(\n    analysis: str = \"workdir.products\",\n    tag: str = \"trace_plots\",\n    product_type: str = \"DataProduct\",\n)\n</code></pre> Traces <p>parse-json | project \"elements\" | extend \"label\"=\"pen.label\" | mv-expand \"points\" | extend \"x\"=\"points.x\", \"y\"=\"points.y\" | project \"label\", \"x\", \"y\" | pivot sum(\"y\"), \"x\", \"label\" | project \"label\", \"x\", \"y\"</p> Source code in <code>src/trendify/server.py</code> <pre><code>@app.route('/data_products/&lt;analysis&gt;/&lt;tag&gt;')\n@app.route('/data_products/&lt;analysis&gt;/&lt;tag&gt;/')\n@app.route('/data_products/&lt;analysis&gt;/&lt;tag&gt;/&lt;product_type&gt;')\n@app.route('/data_products/&lt;analysis&gt;/&lt;tag&gt;/&lt;product_type&gt;/')\ndef get_data_products(\n        analysis: str = 'workdir.products',\n        tag: str = 'trace_plots',\n        product_type: str = 'DataProduct',\n    ):\n    \"\"\"\n    Example: Traces\n        parse-json\n        | project \"elements\"\n        | extend \"label\"=\"pen.label\"\n        | mv-expand \"points\"\n        | extend \"x\"=\"points.x\", \"y\"=\"points.y\"\n        | project \"label\", \"x\", \"y\"\n        | pivot sum(\"y\"), \"x\", \"label\"\n        | project \"label\", \"x\", \"y\"\n    \"\"\"\n    FAILED_RETURN_VALUE = None\n    query_return = FAILED_RETURN_VALUE\n    product_type = str(product_type)\n\n    match product_type:\n        case DataProduct.__name__:\n            filter_type = DataProduct\n        case XYData.__name__:\n            filter_type = XYData\n        case Trace2D.__name__:\n            filter_type = Trace2D,\n        case Point2D.__name__:\n            filter_type = Point2D\n        case TableEntry.__name__:\n            filter_type = TableEntry\n        case HistogramEntry.__name__:\n            filter_type = HistogramEntry\n        case _:\n            query_return = f'{product_type = } should be in {valid_types_names_list}'\n            return query_return\n\n    try:\n        analysis = str(analysis)\n        analysis_path_components = analysis.split('.') if '.' in analysis else [analysis]\n        tag = str(tag)\n        tag_path_components = tag.split('.') if '.' in tag else [tag]\n        collection_path_components = analysis_path_components + tag_path_components\n        data_dir = DATABASE_ROOT.joinpath(*tuple(analysis_path_components))\n        collection_dir = data_dir.joinpath(*tuple(tag_path_components))\n        assert not any(('.' in x) for x in collection_path_components)\n        assert collection_dir.is_relative_to(data_dir)\n    except AssertionError:\n        query_return = f'Do not try to access stuff outside of {data_dir = }'\n        print(f'Do not try to access stuff outside of {data_dir = }')\n        return query_return\n\n    data: DataProductCollection = DataProductCollection.collect_from_all_jsons(collection_dir)\n    if data is None:\n        return f'Did not find data product jsons in {collection_dir}'\n    formatted_tag = (\n        tag_path_components[0] \n        if len(tag_path_components) == 1 \n        else tuple(tag_path_components)\n    )\n    filtered_data = data.get_products(\n        tag=formatted_tag,\n        object_type=filter_type,\n    )\n    query_return = filtered_data.model_dump_json()\n    return query_return\n</code></pre>"}]}