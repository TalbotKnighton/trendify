{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Trendify","text":"<p>Trendify is a python package for visualizing data by generating tagged data products to be sorted and saved to static asset files or displayed interactively.  This greatly simplify the writing of post-processors for many kinds of data.</p>"},{"location":"#functionality-overview","title":"Functionality Overview","text":"<p>The <code>trendify</code> API </p> <ul> <li>Maps a user-defined function over given directories to produce JSON serialized Data Products.</li> <li>Sorts Data Products according to user-specified Tags</li> <li>Writes collected products to CSV files or static images (via matplotlib backend)</li> <li>Generates nested <code>include.md</code> files for importing generated assets into markdown reports (or MkDocs web page)</li> <li>In Progress: Generates a Grafana dashboard with panels for each data Tag</li> <li>Future Work: Generates nested <code>include.tex</code> files for nested assets</li> </ul>"},{"location":"#recipe","title":"Recipe","text":"<p>Use the <code>make_it_trendy</code> to map a user-define executable over multiple batch directories to produce tagged data products and output static/interactive assets:</p> <pre><code>from pathlib import Path\nfrom trendify import make_it_trendy, ProductList\n\ndef user_defined_data_product_generator(workdir: Path) -&gt; List[DataProduct]\n    \"\"\"\n    Define a function to be mapped over multiple batch directories\n    - Load results from workdir\n    - Process results from workdir\n    - Return a list of data products from the given workdir results\n    \"\"\"\n    inputs = ... # load inputs from workdir\n    results = ... # load results from workdir\n    products: List[DataProduct] = []\n\n    # Append products to list.  E.g.\n    products.append(Trace2D(...))\n    products.append(Point2D(...))\n    products.append(TableEntry(...))\n    products.append(HistogramEntry(...))\n    ...\n\n    return products\n\nmake_it_trendy(\n    data_product_generator=user_defined_data_product_generator,  # Callable\n    data_dirs=...,      # List[Path]    Directories over which user-provided data product generator will be mapped\n    products_dir=...,   # Path          Directory for outputting sorted data products (sorted into nested directories by tag)\n    assets_dir=...,     # Path          Directory for outputting generated CSV and image files (via matplotlib)\n    grafana_dir=...,    # Path          Directory for outputting generated Grafana dashboard and panel JSON definiion files\n    n_procs=n_procs,    # int           Number of parallel processes for each step\n    dpi: int = 500,     # int           Image quality of matplotlib output\n    make_tables: bool = True,       # bool  Whether or not static CSV files should be generated from TableEntry products\n    make_xy_plots: bool = True,     # bool  Whether or not static JPG files should be generated from Trace2D and Point2D products\n    make_histograms: bool = True,   # bool  Whether or not static JPG files should be generated from HistogramEntry products\n)\n</code></pre> <p>Trendify sorts products and outputs them as CSV and JPG files to an assets directory or prepares them for display in Grafana via the make_it_trendy method.  This method is a convenient wrapper on multiple individual steps:</p> <ul> <li>make_products</li> <li>sort_products</li> <li>make_grafana_dashboard</li> <li>make_tables_and_figures</li> <li>make_include_files</li> </ul> <p>Each step can be mapped in parallel as part of a process pool by providing an integer argument <code>n_procs</code> greater than 1.  Parllel excecution greatly speeds up processing times for computationally expensive data product generators or for plotting large numbers data products.</p>"},{"location":"#framework-overview","title":"Framework Overview","text":"<p>The user specifies a function that takes in a <code>Path</code> and returns a list holding instances of the following children of DataProduct: </p> <ul> <li><code>Trace2D</code></li> <li><code>Point2D</code></li> <li><code>TableEntry</code></li> <li><code>HistogramEntry</code></li> </ul> <p>All Data Products inherit type checking and JSON serialization from PyDantic BaseModel.  </p> <p>XYData product inputs include:</p> <ul> <li>Tags used to sort and collect the products</li> <li>Pen defines the line style and legend label for <code>Trace2D</code></li> <li>Marker defines the symbol style and legend label for <code>Point2D</code></li> </ul> <p><code>TableEntry</code> inputs include </p> <ul> <li><code>row</code> and <code>column</code> used to generate a pivot table if possible (so long as the <code>row</code>,<code>col</code> index pair is not repeated in a collected set)</li> <li><code>value</code></li> <li><code>units</code></li> </ul> <p>Labels and figure formats are assignable.  Trendify will automatically collapse matplotlib legend labels down to a unique set.  Use unique pen label, marker label, histogram style label, or row/col pair as unique identifiers.  Make sure that the formatting specified for like-tagged <code>DataProduct</code> istances to be the same.</p>"},{"location":"usage/","title":"Tutorials","text":""},{"location":"usage/#scripting","title":"Scripting","text":""},{"location":"usage/#generalized-scheme","title":"Generalized Scheme","text":"<p>The key is to define a function that takes in a <code>Path</code> and returns a list of <code>DataProduct</code>s</p> <pre><code>import pandas as pd\nfrom pathlib import Path\nfrom typing import List\nimport trendify as tdfy\n\ndef process_results(workdir: Path) -&gt; List[tdfy.DataProduct]:\n    inputs = pd.read_csv(workdir.joinpath('inputs.csv')).squeeze()\n    results = pd.read_csv(workdir.joinpath('results.csv'))\n\n    products = []\n\n    # \n    products.append(\n        tdfy.Trace2D( # to be collected with identically tagged data and displayed or plotted to a matplotlib figure\n            tags = [...], # hashable tags for sorting, collecting, and printing/ploting data products\n            x = ..., # x data\n            y = ..., # y data\n            pen = ..., # line color, width, and legend label\n            format2d = ..., # figure and axes titles\n        )\n    )\n\n    products.append(\n        tdfy.Point2D( # to be collected with identically tagged data and displayed or plotted to a matplotlib figure\n            tags = [...], # hashable tags for sorting, collecting, and printing/ploting data products\n            x = ..., # x data\n            y = ..., # y data\n            marker = ..., # color, size, symbol, and legend label\n            format2d = ..., # figure and axes titles\n        )\n    )\n\n    products.append(\n        tdfy.TableEntry(  # to be collected with identically tagged data and displayed or output to csv files\n            tags = [...], # hashable tags for sorting, collecting, and printing/ploting data products\n            row = ..., # row index\n            col = ..., # col index\n            value = ..., # value\n            units = ..., # units\n        )\n    )\n\n    products.append(\n        tdfy.HistogramEntry( # to be collected with identically tagged data, histogrammed, and displayed or plotted to a matplotlib figure\n            tags = [...], # hashable tags for sorting, collecting, and printing/ploting data products\n            value = ..., # value\n        )\n    )\n\n    return products\n\ndef main():\n    \"\"\"\n    Makes sample data, processes it, and serves it for importing into Grafana\n    \"\"\"\n\n    here = Path(__file__).parent\n    workdir = here.joinpath('workdir')\n\n    make_sample_data(workdir=workdir, n_folders=100)\n\n    process_dirs = list(workdir.joinpath('models').glob('*/'))\n    products_dir = workdir.joinpath('products')\n    outputs_dir = workdir.joinpath('outputs')\n    grafana_dir = workdir.joinpath('grafana')\n    n_procs = 1\n\n    make_products(\n        product_generator=sample_processor,\n        dirs=process_dirs,\n        n_procs=n_procs,\n    )\n    sort_products(\n        data_dirs=process_dirs,\n        output_dir=products_dir,\n    )\n    make_grafana_dashboard(\n        sorted_products_dir=products_dir,\n        output_dir=grafana_dir,\n        n_procs=n_procs,\n    )\n    make_tables_and_figures(\n        products_dir=products_dir,\n        output_dir=outputs_dir,\n        dpi=500,\n        n_procs=n_procs,\n    )\n    make_include_files(\n        root_dir=outputs_dir,\n        heading_level=2,\n    )\n</code></pre>"},{"location":"usage/#minimum-working-example","title":"Minimum Working Example","text":""},{"location":"usage/#define-sample-data-generator","title":"Define Sample Data Generator","text":"<pre><code>def make_sample_data(workdir: Path, n_folders: int = 10):\n    \"\"\"\n    Makes some sample data from which to generate products\n\n    Args:\n        workdir (Path): Directory in which the sample data is to be generated\n        n_folders (int): Number of sample data files to generate (in separate subfolders).\n    \"\"\"\n    models_dir = workdir.joinpath('models')\n    models_dir.mkdir(parents=True, exist_ok=True)\n\n    for n in range(n_folders):\n        subdir = models_dir.joinpath(str(n))\n        subdir.mkdir(exist_ok=True, parents=True)\n\n        n_samples = np.random.randint(low=40, high=50)\n        t = np.linspace(0, 1, n_samples)\n        periods = np.random.uniform(low=0.9, high=1.1, size=5)\n        amplitudes = np.random.uniform(low=0.9, high=1.1, size=5)\n\n        n_inputs = {'n_samples': n_samples}\n        p_inputs = {f'p{n}': p for n, p in enumerate(periods)}\n        a_inputs = {f'a{n}': a for n, a in enumerate(amplitudes)}\n        inputs = {}\n        inputs.update(n_inputs)\n        inputs.update(p_inputs)\n        inputs.update(a_inputs)\n        pd.Series(inputs).to_csv(subdir.joinpath('stdin.csv'), header=False)\n\n        d = [t] + [a*np.sin(t*(2*np.pi/p)) for p, a in zip(periods, amplitudes)]\n        df = pd.DataFrame(np.array(d).transpose(), columns=['a', 'c0', 'c1', 'c2', 'c3', 'c4'])\n        df.to_csv(subdir.joinpath('results.csv'), index=False)\n\n    csv_files = list(models_dir.glob('**/stdin.csv'))\n    csv_files.sort()\n    input_series = []\n    for csv in csv_files:\n        series: pd.Series = pd.read_csv(csv, index_col=0, header=None).squeeze() \n        series.name = int(csv.parent.stem)\n        input_series.append(series)\n\n    aggregate_dir = workdir.joinpath('aggregate')\n    aggregate_dir.mkdir(parents=True, exist_ok=True)\n    aggregate_df = pd.concat(input_series, axis=1).transpose()\n    aggregate_df.index.name = 'Directory'\n    aggregate_df.to_csv(aggregate_dir.joinpath('stdin.csv'))\n</code></pre>"},{"location":"usage/#define-sample-data-processor","title":"Define sample data processor","text":"<pre><code>def sample_processor(workdir: Path) -&gt; List[DataProduct]:\n    \"\"\"\n    Processes the generated sample data in given workdir returning several types of data products.\n\n    Args:\n        workdir (Path): Directory containing sample data.\n    \"\"\"\n    df = pd.read_csv(workdir.joinpath('results.csv'))\n    df = df.set_index('a', drop=True)\n    traces = [\n        Trace2D.from_xy(\n            x=df.index,\n            y=df[col].values,\n            tags=['trace_plots'],\n            pen=Pen(label=f'{col} {int(workdir.name)}'),\n            format2d=Format2D(title_legend='Column'),\n        )\n        for col in df.columns\n    ]\n    points = [\n        Point2D(\n            x=workdir.name,\n            y=len(trace.y),\n            marker=Marker(\n                size=10,\n                label=trace.pen.label,\n            ),\n            format2d=Format2D(title_fig='N Points'),\n            tags=['scatter_plots'],\n        )\n        for trace\n        in traces\n    ]\n    table_entries = [\n        TableEntry(\n            row=workdir.name,\n            col=name,\n            value=len(series),\n            tags=['tables'],\n            unit=None,\n        )\n        for name, series in df.items()\n    ]\n\n    return traces + points + table_entries\n</code></pre>"},{"location":"usage/#define-main-function","title":"Define Main Function","text":"<pre><code>def main():\n    \"\"\"\n    Makes sample data, processes it, and serves it for importing into Grafana\n    \"\"\"\n    here = Path(__file__).parent\n    workdir = here.joinpath('workdir')\n\n    make_sample_data(workdir=workdir, n_folders=100)\n\n    process_dirs = list(workdir.joinpath('models').glob('*/'))\n    products_dir = workdir.joinpath('products')\n    outputs_dir = workdir.joinpath('outputs')\n    grafana_dir = workdir.joinpath('grafana')\n    n_procs = 1\n\n    make_products(\n        product_generator=sample_processor,\n        dirs=process_dirs,\n        n_procs=n_procs,\n    )\n    sort_products(\n        data_dirs=process_dirs,\n        output_dir=products_dir,\n    )\n    make_grafana_dashboard(\n        sorted_products_dir=products_dir,\n        output_dir=grafana_dir,\n        n_procs=n_procs,\n    )\n    make_tables_and_figures(\n        products_dir=products_dir,\n        output_dir=outputs_dir,\n        dpi=500,\n        n_procs=n_procs,\n    )\n    make_include_files(\n        root_dir=outputs_dir,\n        heading_level=2,\n    )\n\nif __name__ == '__main__':\n    main()\n</code></pre>"},{"location":"usage/#command-line-interface","title":"Command Line Interface","text":"<p>Document usage here after writing the code</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>grafana_api<ul> <li>dashboard</li> <li>panels<ul> <li>xy_chart</li> </ul> </li> <li>transformations<ul> <li>transformations</li> </ul> </li> </ul> </li> <li>trendify<ul> <li>command_line_interface</li> <li>products</li> <li>server</li> </ul> </li> </ul>"},{"location":"reference/grafana_api/","title":"grafana_api","text":""},{"location":"reference/grafana_api/#grafana_api","title":"grafana_api","text":""},{"location":"reference/grafana_api/#grafana_api.Annotation","title":"Annotation","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/grafana_api/#grafana_api.Annotations","title":"Annotations","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/grafana_api/#grafana_api.Dashboard","title":"Dashboard","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/grafana_api/#grafana_api.DataSource","title":"DataSource","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/grafana_api/#grafana_api.DefaultDataSource","title":"DefaultDataSource","text":"<p>               Bases: <code>DataSource</code></p>"},{"location":"reference/grafana_api/#grafana_api.FieldConfig","title":"FieldConfig","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code> \"fieldConfig\": {\n    \"defaults\": {\n\n        \"fieldMinMax\": false,\n        \"mappings\": [],\n\n    },\n    \"overrides\": []\n},\n</code></pre>"},{"location":"reference/grafana_api/#grafana_api.GridPosition","title":"GridPosition","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>\"gridPos\": {\n    \"h\": 8,\n    \"w\": 12,\n    \"x\": 12,\n    \"y\": 16\n}\n</code></pre>"},{"location":"reference/grafana_api/#grafana_api.HideFrom","title":"HideFrom","text":"<p>               Bases: <code>BaseModel</code></p> <p>{     \"legend\": false,     \"tooltip\": false,     \"viz\": false }</p>"},{"location":"reference/grafana_api/#grafana_api.Legend","title":"Legend","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/grafana_api/#grafana_api.LineStyle","title":"LineStyle","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>{\n    \"fill\": \"solid\"\n}\n</code></pre>"},{"location":"reference/grafana_api/#grafana_api.Options","title":"Options","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/grafana_api/#grafana_api.Panel","title":"Panel","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/grafana_api/#grafana_api.PointSize","title":"PointSize","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>{\n    \"fixed\": 3\n}\n</code></pre>"},{"location":"reference/grafana_api/#grafana_api.ScaleDistribution","title":"ScaleDistribution","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>{\n    \"type\": \"linear\"\n}\n</code></pre>"},{"location":"reference/grafana_api/#grafana_api.Series","title":"Series","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/grafana_api/#grafana_api.Target","title":"Target","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/grafana_api/#grafana_api.Threshold","title":"Threshold","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>{\n    \"color\": \"green\",\n    \"value\": null\n}\n</code></pre>"},{"location":"reference/grafana_api/#grafana_api.Thresholds","title":"Thresholds","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>\"thresholds\": {\n    \"mode\": \"absolute\",\n    \"steps\": [\n\n    ]\n}\n</code></pre>"},{"location":"reference/grafana_api/#grafana_api.ToolTip","title":"ToolTip","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/grafana_api/#grafana_api.Transformation","title":"Transformation","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/grafana_api/#grafana_api.URLOptions","title":"URLOptions","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/grafana_api/dashboard/","title":"dashboard","text":""},{"location":"reference/grafana_api/dashboard/#grafana_api.dashboard","title":"dashboard","text":"<p>Dashboard definition</p>"},{"location":"reference/grafana_api/dashboard/#grafana_api.dashboard.Annotation","title":"Annotation","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/grafana_api/dashboard/#grafana_api.dashboard.Annotations","title":"Annotations","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/grafana_api/dashboard/#grafana_api.dashboard.Dashboard","title":"Dashboard","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/grafana_api/panels/","title":"panels","text":""},{"location":"reference/grafana_api/panels/#grafana_api.panels","title":"panels","text":""},{"location":"reference/grafana_api/panels/#grafana_api.panels.DataSource","title":"DataSource","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/grafana_api/panels/#grafana_api.panels.DefaultDataSource","title":"DefaultDataSource","text":"<p>               Bases: <code>DataSource</code></p>"},{"location":"reference/grafana_api/panels/#grafana_api.panels.FieldConfig","title":"FieldConfig","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code> \"fieldConfig\": {\n    \"defaults\": {\n\n        \"fieldMinMax\": false,\n        \"mappings\": [],\n\n    },\n    \"overrides\": []\n},\n</code></pre>"},{"location":"reference/grafana_api/panels/#grafana_api.panels.GridPosition","title":"GridPosition","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>\"gridPos\": {\n    \"h\": 8,\n    \"w\": 12,\n    \"x\": 12,\n    \"y\": 16\n}\n</code></pre>"},{"location":"reference/grafana_api/panels/#grafana_api.panels.HideFrom","title":"HideFrom","text":"<p>               Bases: <code>BaseModel</code></p> <p>{     \"legend\": false,     \"tooltip\": false,     \"viz\": false }</p>"},{"location":"reference/grafana_api/panels/#grafana_api.panels.Legend","title":"Legend","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/grafana_api/panels/#grafana_api.panels.LineStyle","title":"LineStyle","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>{\n    \"fill\": \"solid\"\n}\n</code></pre>"},{"location":"reference/grafana_api/panels/#grafana_api.panels.Options","title":"Options","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/grafana_api/panels/#grafana_api.panels.Panel","title":"Panel","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/grafana_api/panels/#grafana_api.panels.PointSize","title":"PointSize","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>{\n    \"fixed\": 3\n}\n</code></pre>"},{"location":"reference/grafana_api/panels/#grafana_api.panels.ScaleDistribution","title":"ScaleDistribution","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>{\n    \"type\": \"linear\"\n}\n</code></pre>"},{"location":"reference/grafana_api/panels/#grafana_api.panels.Series","title":"Series","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/grafana_api/panels/#grafana_api.panels.Target","title":"Target","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/grafana_api/panels/#grafana_api.panels.Threshold","title":"Threshold","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>{\n    \"color\": \"green\",\n    \"value\": null\n}\n</code></pre>"},{"location":"reference/grafana_api/panels/#grafana_api.panels.Thresholds","title":"Thresholds","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>\"thresholds\": {\n    \"mode\": \"absolute\",\n    \"steps\": [\n\n    ]\n}\n</code></pre>"},{"location":"reference/grafana_api/panels/#grafana_api.panels.ToolTip","title":"ToolTip","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/grafana_api/panels/#grafana_api.panels.URLOptions","title":"URLOptions","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/grafana_api/panels/xy_chart/","title":"xy_chart","text":""},{"location":"reference/grafana_api/panels/xy_chart/#grafana_api.panels.xy_chart","title":"xy_chart","text":"<p>Need to produce a Dashboard ```</p>"},{"location":"reference/grafana_api/panels/xy_chart/#grafana_api.panels.xy_chart.DataSource","title":"DataSource","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/grafana_api/panels/xy_chart/#grafana_api.panels.xy_chart.DefaultDataSource","title":"DefaultDataSource","text":"<p>               Bases: <code>DataSource</code></p>"},{"location":"reference/grafana_api/panels/xy_chart/#grafana_api.panels.xy_chart.FieldConfig","title":"FieldConfig","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code> \"fieldConfig\": {\n    \"defaults\": {\n\n        \"fieldMinMax\": false,\n        \"mappings\": [],\n\n    },\n    \"overrides\": []\n},\n</code></pre>"},{"location":"reference/grafana_api/panels/xy_chart/#grafana_api.panels.xy_chart.GridPosition","title":"GridPosition","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>\"gridPos\": {\n    \"h\": 8,\n    \"w\": 12,\n    \"x\": 12,\n    \"y\": 16\n}\n</code></pre>"},{"location":"reference/grafana_api/panels/xy_chart/#grafana_api.panels.xy_chart.HideFrom","title":"HideFrom","text":"<p>               Bases: <code>BaseModel</code></p> <p>{     \"legend\": false,     \"tooltip\": false,     \"viz\": false }</p>"},{"location":"reference/grafana_api/panels/xy_chart/#grafana_api.panels.xy_chart.Legend","title":"Legend","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/grafana_api/panels/xy_chart/#grafana_api.panels.xy_chart.LineStyle","title":"LineStyle","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>{\n    \"fill\": \"solid\"\n}\n</code></pre>"},{"location":"reference/grafana_api/panels/xy_chart/#grafana_api.panels.xy_chart.MatcherOptions","title":"MatcherOptions","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/grafana_api/panels/xy_chart/#grafana_api.panels.xy_chart.Options","title":"Options","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/grafana_api/panels/xy_chart/#grafana_api.panels.xy_chart.Panel","title":"Panel","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/grafana_api/panels/xy_chart/#grafana_api.panels.xy_chart.PointSize","title":"PointSize","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>{\n    \"fixed\": 3\n}\n</code></pre>"},{"location":"reference/grafana_api/panels/xy_chart/#grafana_api.panels.xy_chart.ScaleDistribution","title":"ScaleDistribution","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>{\n    \"type\": \"linear\"\n}\n</code></pre>"},{"location":"reference/grafana_api/panels/xy_chart/#grafana_api.panels.xy_chart.Series","title":"Series","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/grafana_api/panels/xy_chart/#grafana_api.panels.xy_chart.Target","title":"Target","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/grafana_api/panels/xy_chart/#grafana_api.panels.xy_chart.Threshold","title":"Threshold","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>{\n    \"color\": \"green\",\n    \"value\": null\n}\n</code></pre>"},{"location":"reference/grafana_api/panels/xy_chart/#grafana_api.panels.xy_chart.Thresholds","title":"Thresholds","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>\"thresholds\": {\n    \"mode\": \"absolute\",\n    \"steps\": [\n\n    ]\n}\n</code></pre>"},{"location":"reference/grafana_api/panels/xy_chart/#grafana_api.panels.xy_chart.ToolTip","title":"ToolTip","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/grafana_api/panels/xy_chart/#grafana_api.panels.xy_chart.URLOptions","title":"URLOptions","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/grafana_api/transformations/","title":"transformations","text":""},{"location":"reference/grafana_api/transformations/#grafana_api.transformations","title":"transformations","text":""},{"location":"reference/grafana_api/transformations/#grafana_api.transformations.Transformation","title":"Transformation","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/grafana_api/transformations/transformations/","title":"transformations","text":""},{"location":"reference/grafana_api/transformations/transformations/#grafana_api.transformations.transformations","title":"transformations","text":"<pre><code>{\n    \"id\": \"merge\",\n    \"options\": {}\n},\n{\n    \"id\": \"partitionByValues\",\n    \"options\": {\n        \"fields\": [\n            \"label\"\n        ],\n        \"keepFields\": false,\n        \"naming\": {\n            \"asLabels\": false\n        }\n    }\n}\n</code></pre>"},{"location":"reference/grafana_api/transformations/transformations/#grafana_api.transformations.transformations.Transformation","title":"Transformation","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/trendify/","title":"trendify","text":""},{"location":"reference/trendify/#trendify","title":"trendify","text":"<p>Provides top-level imports</p>"},{"location":"reference/trendify/#trendify.DataProduct","title":"DataProduct","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for data products to be generated and handled.</p> <p>Attributes:</p> Name Type Description <code>product_type</code> <code>Hashable</code> <p>Product type should be the same as the class name. The product type is used to search for products from a DataProductCollection.</p> <code>tags</code> <code>Tags</code> <p>Tags to be used for sorting data.</p> <code>metadata</code> <code>dict[str, str]</code> <p>A dictionary of metadata to be used as a tool tip for mousover in grafana</p>"},{"location":"reference/trendify/#trendify.DataProduct.Config","title":"Config","text":"<p>Disallows additional attributes</p>"},{"location":"reference/trendify/#trendify.DataProduct.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(**kwargs: Any) -&gt; None\n</code></pre> <p>Registers child subclasses to be able to parse them from JSON file using the  deserialize_child_classes method</p>"},{"location":"reference/trendify/#trendify.DataProduct.append_to_list","title":"append_to_list","text":"<pre><code>append_to_list(l: List)\n</code></pre> <p>Appends self to list.</p> <p>Parameters:</p> Name Type Description Default <code>l</code> <code>List</code> <p>list to which <code>self</code> will be appended</p> required <p>Returns:</p> Type Description <code>Self</code> <p>returns instance of <code>self</code></p>"},{"location":"reference/trendify/#trendify.DataProduct.deserialize_child_classes","title":"deserialize_child_classes  <code>classmethod</code>","text":"<pre><code>deserialize_child_classes(key: str, **kwargs)\n</code></pre> <p>Loads json data to pydandic dataclass of whatever DataProduct child time is appropriate</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>json key</p> required <code>kwargs</code> <code>dict</code> <p>json entries stored under given key</p> <code>{}</code>"},{"location":"reference/trendify/#trendify.DataProductCollection","title":"DataProductCollection","text":"<pre><code>DataProductCollection(**kwargs: Any)\n</code></pre> <p>               Bases: <code>BaseModel</code></p> <p>A collection of data products.</p> <p>Use this class to serialize data products to JSON, de-serialized them from JSON, filter the products, etc.</p> <p>Attributes:</p> Name Type Description <code>elements</code> <code>ProductList</code> <p>A list of data products.</p>"},{"location":"reference/trendify/#trendify.DataProductCollection.add_products","title":"add_products","text":"<pre><code>add_products(*products: DataProduct)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>products</code> <code>Tuple[DataProduct | ProductList, ...]</code> <p>Products or lists of products to be appended to collection elements.</p> <code>()</code>"},{"location":"reference/trendify/#trendify.DataProductCollection.collect_from_all_jsons","title":"collect_from_all_jsons  <code>classmethod</code>","text":"<pre><code>collect_from_all_jsons(*dirs: Path, recursive: bool = False)\n</code></pre> <p>Loads all products from JSONs in the given list of directories. If recursive is set to <code>True</code>, the directories will be searched recursively  (this could lead to double counting if you pass in subdirectories of a parent).</p> <p>Parameters:</p> Name Type Description Default <code>dirs</code> <code>Tuple[Path, ...]</code> <p>Directories from which to load data product JSON files.</p> <code>()</code> <code>recursive</code> <code>bool</code> <p>whether or not to search each of the provided directories recursively for  data product json files.</p> <code>False</code> <p>Returns:</p> Type Description <code>Type[Self] | None</code> <p>Data product collection if JSON files are found. Otherwise, returns None if no product JSON files were found.</p>"},{"location":"reference/trendify/#trendify.DataProductCollection.drop_products","title":"drop_products","text":"<pre><code>drop_products(tag: Hashable | None = None, object_type: Type[R] | None = None) -&gt; Self[R]\n</code></pre> <p>Removes products matching <code>tag</code> and/or <code>object_type</code> from collection elements.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>Tag | None</code> <p>Tag for which data products should be dropped</p> <code>None</code> <code>object_type</code> <code>Type | None</code> <p>Type of data product to drop</p> <code>None</code> <p>Returns:</p> Type Description <code>DataProductCollection</code> <p>A new collection from which matching elements have been dropped.</p>"},{"location":"reference/trendify/#trendify.DataProductCollection.from_iterable","title":"from_iterable  <code>classmethod</code>","text":"<pre><code>from_iterable(*products: Tuple[ProductList, ...])\n</code></pre> <p>Returns a new instance containing all of the products provided in the <code>*products</code> argument.</p> <p>Parameters:</p> Name Type Description Default <code>products</code> <code>Tuple[ProductList, ...]</code> <p>Lists of data products to combine into a collection</p> <code>()</code> <p>Returns:</p> Type Description <code>cls</code> <p>A data product collection containing all of the provided products in the <code>*products</code> argument.</p>"},{"location":"reference/trendify/#trendify.DataProductCollection.get_products","title":"get_products","text":"<pre><code>get_products(tag: Hashable | None = None, object_type: Type[R] | None = None) -&gt; Self[R]\n</code></pre> <p>Returns a new collection containing products matching <code>tag</code> and/or <code>object_type</code>. Both <code>tag</code> and <code>object_type</code> default to <code>None</code> which matches all products.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>Tag | None</code> <p>Tag of data products to be kept.  <code>None</code> matches all products.</p> <code>None</code> <code>object_type</code> <code>Type | None</code> <p>Type of data product to keep.  <code>None</code> matches all products.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataProductCollection</code> <p>A new collection containing matching elements.</p>"},{"location":"reference/trendify/#trendify.DataProductCollection.get_tags","title":"get_tags","text":"<pre><code>get_tags(data_product_type: Type[DataProduct] | None = None) -&gt; set\n</code></pre> <p>Gets the tags related to a given type of <code>DataProduct</code>.  Parent classes will match all child class types.</p> <p>Parameters:</p> Name Type Description Default <code>data_product_type</code> <code>Type[DataProduct] | None</code> <p>type for which you want to get the list of tags</p> <code>None</code> <p>Returns:</p> Type Description <code>set</code> <p>set of tags applying to the given <code>data_product_type</code>.</p>"},{"location":"reference/trendify/#trendify.DataProductCollection.make_grafana_panels","title":"make_grafana_panels  <code>classmethod</code>","text":"<pre><code>make_grafana_panels(dir_in: Path, panel_dir: Path)\n</code></pre> <p>Processes collection of elements corresponding to a single tag. This method should be called on a directory containing jsons for which the products have been sorted.</p> <p>Parameters:</p> Name Type Description Default <code>dir_in</code> <code>Path</code> <p>Directory from which to read data products (should be sorted first)</p> required <code>panel_dir</code> <code>Path</code> <p>Where to put the panel information</p> required"},{"location":"reference/trendify/#trendify.DataProductCollection.process_single_tag_collection","title":"process_single_tag_collection  <code>classmethod</code>","text":"<pre><code>process_single_tag_collection(\n    dir_in: Path,\n    dir_out: Path,\n    make_tables: bool,\n    make_xy_plots: bool,\n    make_histograms: bool,\n    dpi: int,\n)\n</code></pre> <p>Processes collection of elements corresponding to a single tag. This method should be called on a directory containing jsons for which the products have been sorted.</p> <p>Parameters:</p> Name Type Description Default <code>dir_in</code> <code>Path</code> required <code>dir_out</code> <code>Path</code> required <code>make_tables</code> <code>bool</code> required <code>make_xy_plots</code> <code>bool</code> required <code>make_histograms</code> <code>bool</code> required <code>dpi</code> <code>int</code> required"},{"location":"reference/trendify/#trendify.DataProductCollection.sort_by_tags","title":"sort_by_tags  <code>classmethod</code>","text":"<pre><code>sort_by_tags(dirs_in: List[Path], dir_out: Path)\n</code></pre> <p>Loads the data product JSON files from <code>dirs_in</code> sorts the products. Sorted products are written to smaller files in a nested directory structure under <code>dir_out</code>. The nested directory structure is generated accordint to the data tags. Resulting product files are named according to the directory from which they were originally loaded.</p> <p>Parameters:</p> Name Type Description Default <code>dirs_in</code> <code>List[Path]</code> <p>Directories from which the data product JSON files are to be loaded.</p> required <code>dir_out</code> <code>Path</code> <p>Directory to which the sorted data products will be written into a  nested folder structure generated according to the data tags.</p> required"},{"location":"reference/trendify/#trendify.DataProductCollection.union","title":"union  <code>classmethod</code>","text":"<pre><code>union(*collections: DataProductCollection)\n</code></pre> <p>Aggregates all of the products from multiple collections into a new larger collection.</p> <p>Parameters:</p> Name Type Description Default <code>collections</code> <code>Tuple[DataProductCollection, ...]</code> <p>Data product collections for which the products should be combined into a new collection.</p> <code>()</code> <p>Returns:</p> Type Description <code>Type[Self]</code> <p>A new data product collection containing all products from the provided <code>*collections</code>.</p>"},{"location":"reference/trendify/#trendify.Format2D","title":"Format2D","text":"<p>               Bases: <code>HashableBase</code></p> <p>Formatting data for matplotlib figure and axes</p>"},{"location":"reference/trendify/#trendify.Format2D.Config","title":"Config","text":"<p>Forbids extra arguments</p>"},{"location":"reference/trendify/#trendify.Format2D.union_from_iterable","title":"union_from_iterable  <code>classmethod</code>","text":"<pre><code>union_from_iterable(format2ds: Iterable[Format2D])\n</code></pre> <p>Gets the most inclusive format object (in terms of limits) from a list of <code>Format2D</code> objects. Requires that the label and title fields are identical for all format objects in the list.</p> <p>Parameters:</p> Name Type Description Default <code>format2ds</code> <code>Iterable[Format2D]</code> <p>Iterable of <code>Format2D</code> objects.</p> required <p>Returns:</p> Type Description <code>Format2D</code> <p>Single format object from list of objects.</p>"},{"location":"reference/trendify/#trendify.HistogramEntry","title":"HistogramEntry","text":"<p>               Bases: <code>DataProduct</code></p> <p>Use this class to specify a value to be collected into a matplotlib histogram.</p> <p>Attributes:</p> Name Type Description <code>product_type</code> <code>Literal['Trace2D']</code> <p>Name of class type to be used as a constructor.</p> <code>value</code> <code>float | str</code> <p>Value to be binned</p> <code>tags</code> <code>Tags</code> <p>Hashable tags used to sort data products</p> <code>style</code> <code>HistogramStyle</code> <p>Style of histogram display</p> <code>format2d</code> <code>Format2D</code> <p>Format to apply to single axis figure</p>"},{"location":"reference/trendify/#trendify.HistogramEntry.Config","title":"Config","text":"<p>Forbids extra attributes</p>"},{"location":"reference/trendify/#trendify.HistogramStyle","title":"HistogramStyle","text":"<p>               Bases: <code>HashableBase</code></p> <p>Label and style data for generating histogram bars</p> <p>Attributes:</p> Name Type Description <code>color</code> <code>str</code> <p>Color of bars</p> <code>label</code> <code>str | None</code> <p>Legend entry</p> <code>histtype</code> <code>str</code> <p>Histogram type corresponding to matplotlib argument of same name</p> <code>alpha_edge</code> <code>float</code> <p>Opacity of bar edge</p> <code>alpha_face</code> <code>float</code> <p>Opacity of bar face</p> <code>linewidth</code> <code>float</code> <p>Line width of bar outline</p>"},{"location":"reference/trendify/#trendify.HistogramStyle.as_plot_kwargs","title":"as_plot_kwargs","text":"<pre><code>as_plot_kwargs()\n</code></pre> <p>Returns:</p> Type Description <code>dict</code> <p>kwargs for matplotlib <code>hist</code> method</p>"},{"location":"reference/trendify/#trendify.Marker","title":"Marker","text":"<p>               Bases: <code>HashableBase</code></p> <p>Defines marker for scattering to matplotlib</p> <p>Attributes:</p> Name Type Description <code>color</code> <code>str</code> <p>Color of line</p> <code>size</code> <code>float</code> <p>Line width</p> <code>alpha</code> <code>float</code> <p>Opacity from 0 to 1 (inclusive)</p> <code>zorder</code> <code>float</code> <p>Prioritization </p> <code>label</code> <code>Union[str, None]</code> <p>Legend label</p> <code>symbol</code> <code>str</code> <p>Matplotlib symbol string</p>"},{"location":"reference/trendify/#trendify.Marker.Config","title":"Config","text":"<p>Forbids extra attributes</p>"},{"location":"reference/trendify/#trendify.Marker.as_scatter_plot_kwargs","title":"as_scatter_plot_kwargs","text":"<pre><code>as_scatter_plot_kwargs()\n</code></pre> <p>Returns:</p> Type Description <code>dict</code> <p>dictionary of <code>kwargs</code> for matplotlib scatter</p>"},{"location":"reference/trendify/#trendify.Marker.from_pen","title":"from_pen  <code>classmethod</code>","text":"<pre><code>from_pen(pen: Pen, symbol: str = '.')\n</code></pre> <p>Converts Pen to marker with the option to specify a symbol</p>"},{"location":"reference/trendify/#trendify.Pen","title":"Pen","text":"<p>               Bases: <code>HashableBase</code></p> <p>Defines the pen drawing to matplotlib.</p> <p>Attributes:</p> Name Type Description <code>color</code> <code>str</code> <p>Color of line</p> <code>size</code> <code>float</code> <p>Line width</p> <code>alpha</code> <code>float</code> <p>Opacity from 0 to 1 (inclusive)</p> <code>zorder</code> <code>float</code> <p>Prioritization </p> <code>label</code> <code>Union[str, None]</code> <p>Legend label</p>"},{"location":"reference/trendify/#trendify.Pen.Config","title":"Config","text":"<p>Forbids extra attributes</p>"},{"location":"reference/trendify/#trendify.Pen.as_scatter_plot_kwargs","title":"as_scatter_plot_kwargs","text":"<pre><code>as_scatter_plot_kwargs()\n</code></pre> <p>Returns kwargs dictionary for passing to matplotlib plot method</p>"},{"location":"reference/trendify/#trendify.Point2D","title":"Point2D","text":"<p>               Bases: <code>XYData</code></p> <p>Defines a point to be scattered onto xy plot.</p> <p>Attributes:</p> Name Type Description <code>product_type</code> <code>Literal['Trace2D']</code> <p>Name of class type to be used as a constructor.</p> <code>points</code> <code>List[Point2D]</code> <p>List of points.  Usually the points would have null values  for <code>marker</code> and <code>format2d</code> fields to save space.</p> <code>marker</code> <code>Marker</code> <p>Style and label information for scattering points to matplotlib axes. Only the label information is used in Grafana. Eventually style information will be used in grafana.</p> <code>format2d</code> <code>Format2D</code> <p>Formatting information for matplotlib figure.</p>"},{"location":"reference/trendify/#trendify.Point2D.Config","title":"Config","text":"<p>Forbids extra attributes</p>"},{"location":"reference/trendify/#trendify.TableEntry","title":"TableEntry","text":"<p>               Bases: <code>DataProduct</code></p> <p>Defines an entry to be collected into a table.</p> <p>Collected table entries will be printed in three forms when possible: melted, pivot (when possible), and stats (on pivot columns, when possible).</p> <p>Attributes:</p> Name Type Description <code>product_type</code> <code>Literal['Trace2D']</code> <p>Name of class type to be used as a constructor.</p> <code>row</code> <code>float | str</code> <p>Value to be binned</p> <code>col</code> <code>float | str</code> <p>Hashable tags used to sort data products</p> <code>value</code> <code>float | str</code> <p>Style of histogram display</p> <code>unit</code> <code>str | None</code> <p>Format to apply to single axis figure</p>"},{"location":"reference/trendify/#trendify.TableEntry.get_entry_dict","title":"get_entry_dict","text":"<pre><code>get_entry_dict()\n</code></pre> <p>Returns a dictionary of entries to be used in creating a table.</p> <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>Dictionary of entries to be used in creating a melted DataFrame</p>"},{"location":"reference/trendify/#trendify.TableEntry.load_and_pivot","title":"load_and_pivot  <code>classmethod</code>","text":"<pre><code>load_and_pivot(path: Path)\n</code></pre> <p>Loads melted table from csv and pivots to wide form. csv should have columns named <code>'row'</code>, <code>'col'</code>, and <code>'value'</code>.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>path to CSV file</p> required <p>Returns:</p> Type Description <code>DataFrame | None</code> <p>Pivoted data frame or elese <code>None</code> if pivot operation fails.</p>"},{"location":"reference/trendify/#trendify.TableEntry.pivot_table","title":"pivot_table  <code>classmethod</code>","text":"<pre><code>pivot_table(melted: DataFrame)\n</code></pre> <p>Attempts to pivot melted row, col, value DataFrame into a wide form DataFrame</p> <p>Parameters:</p> Name Type Description Default <code>melted</code> <code>DataFrame</code> <p>Melted data frame having columns named <code>'row'</code>, <code>'col'</code>, <code>'value'</code>.</p> required <p>Returns:</p> Type Description <code>DataFrame | None</code> <p>pivoted DataFrame if pivot works else <code>None</code>. Pivot operation fails if  row or column index pairs are repeated.</p>"},{"location":"reference/trendify/#trendify.Trace2D","title":"Trace2D","text":"<p>               Bases: <code>XYData</code></p> <p>A collection of points comprising a trace. Use the Trace2D.from_xy constructor.</p> <p>Attributes:</p> Name Type Description <code>product_type</code> <code>Literal['Trace2D']</code> <p>Name of class type to be used as a constructor.</p> <code>points</code> <code>List[Point2D]</code> <p>List of points.  Usually the points would have null values  for <code>marker</code> and <code>format2d</code> fields to save space.</p> <code>pen</code> <code>Pen</code> <p>Style and label information for drawing to matplotlib axes. Only the label information is used in Grafana. Eventually style information will be used in grafana.</p> <code>format2d</code> <code>Format2D</code> <p>Formatting information for matplotlib figure.</p>"},{"location":"reference/trendify/#trendify.Trace2D.x","title":"x  <code>property</code>","text":"<pre><code>x\n</code></pre> <p>Returns an array of x values from <code>self.points</code></p> <p>Returns:</p> Type Description <code>NDArray[Shape['*'], float]</code> <p>array of x values from <code>self.points</code></p> <p>'</p>"},{"location":"reference/trendify/#trendify.Trace2D.y","title":"y  <code>property</code>","text":"<pre><code>y\n</code></pre> <p>Returns an array of y values from <code>self.points</code></p> <p>Returns:</p> Type Description <code>NDArray[Shape['*'], float]</code> <p>array of y values from <code>self.points</code></p>"},{"location":"reference/trendify/#trendify.Trace2D.Config","title":"Config","text":"<p>Forbids extra attributes</p>"},{"location":"reference/trendify/#trendify.Trace2D.from_xy","title":"from_xy  <code>classmethod</code>","text":"<pre><code>from_xy(\n    tags: Tags,\n    x: NDArray[Shape[\"*\"], float],\n    y: NDArray[Shape[\"*\"], float],\n    pen: Pen = Pen(),\n    format2d: Format2D = Format2D(),\n)\n</code></pre> <p>Creates a list of Point2Ds from xy data and returns a new Trace2D product.</p> <p>Parameters:</p> Name Type Description Default <code>tags</code> <code>Tags</code> <p>Hashable tags used to sort data products</p> required <code>x</code> <code>NDArray[Shape['*'], float]</code> <p>x values</p> required <code>y</code> <code>NDArray[Shape['*'], float]</code> <p>y values</p> required <code>pen</code> <code>Pen</code> <p>Style and label for trace</p> <code>Pen()</code> <code>format2d</code> <code>Format2D</code> <p>format to apply to matplotlib</p> <code>Format2D()</code>"},{"location":"reference/trendify/#trendify.Trace2D.plot_to_ax","title":"plot_to_ax","text":"<pre><code>plot_to_ax(ax: Axes)\n</code></pre> <p>Plots xy data from trace to a matplotlib axes object.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>axes to which xy data should be plotted</p> required"},{"location":"reference/trendify/#trendify.Trace2D.propagate_format2d_and_pen","title":"propagate_format2d_and_pen","text":"<pre><code>propagate_format2d_and_pen(marker_symbol: str = '.') -&gt; None\n</code></pre> <p>Propagates format and style info to all <code>self.points</code> (in-place). I thought this would  be useful for grafana before I learned better methods for propagating the data. It still may end up being useful if my plotting method changes.  Keeping for potential future use case.</p> <p>Parameters:</p> Name Type Description Default <code>marker_symbol</code> <code>str</code> <p>Valid matplotlib marker symbol</p> <code>'.'</code>"},{"location":"reference/trendify/#trendify.XYData","title":"XYData","text":"<p>               Bases: <code>DataProduct</code></p> <p>Base class for children of DataProduct to be plotted ax xy data on a 2D plot</p>"},{"location":"reference/trendify/#trendify.get_data_products","title":"get_data_products","text":"<pre><code>get_data_products(\n    analysis: str = \"workdir.products\", tag: str = \"trace_plots\", product_type: str = \"DataProduct\"\n)\n</code></pre> Traces <p>parse-json | project \"elements\" | extend \"label\"=\"pen.label\" | mv-expand \"points\" | extend \"x\"=\"points.x\", \"y\"=\"points.y\" | project \"label\", \"x\", \"y\" | pivot sum(\"y\"), \"x\", \"label\" | project \"label\", \"x\", \"y\"</p>"},{"location":"reference/trendify/#trendify.make_grafana_dashboard","title":"make_grafana_dashboard","text":"<pre><code>make_grafana_dashboard(sorted_products_dir: Path, output_dir: Path, n_procs: int = 1)\n</code></pre> <p>Makes a JSON file to import to Grafana for displaying tagged data tables, histograms and XY plots.</p> <p>Parameters:</p> Name Type Description Default <code>sorted_products_dir</code> <code>Path</code> <p>Root directory into which products have been sorted by tag</p> required <code>output_dir</code> <code>Path</code> <p>Root directory into which Grafana dashboard and panal definitions will be written</p> required <code>n_procs</code> <code>int</code> <p>Number of parallel tasks used for processing data product tags</p> <code>1</code>"},{"location":"reference/trendify/#trendify.make_include_files","title":"make_include_files","text":"<pre><code>make_include_files(\n    root_dir: Path,\n    local_server_path: str | Path = None,\n    mkdocs_include_dir: str | Path = None,\n    heading_level: int | None = None,\n)\n</code></pre> <p>Makes nested include files for inclusion into an MkDocs site.</p> Note <p>I recommend to create a Grafana panel and link to that from the MkDocs site instead.</p> <p>Parameters:</p> Name Type Description Default <code>root_dir</code> <code>Path</code> <p>Directory for which the include files should be recursively generated</p> required <code>local_server_path</code> <code>str | Path | None</code> <p>What should the beginning of the path look like? Use <code>//localhost:8001/...</code> something like that to work with <code>python -m mkdocs serve</code> while running <code>python -m http.server 8001</code> in order to have interactive updates. Use my python <code>convert_links.py</code> script to update after running <code>python -m mkdocs build</code> in order to fix the links for the MkDocs site.  See this repo for an example.</p> <code>None</code> <code>mkdocs_include_dir</code> <code>str | Path | None</code> <p>Path to be used for mkdocs includes. This path should correspond to includ dir in <code>mkdocs.yml</code> file.  (See <code>vulcan_srb_sep</code> repo for example).</p> <code>None</code> <p>Note:</p> <pre><code>Here is how to setup `mkdocs.yml` file to have an `include_dir` that can be used to \ninclude generated markdown files (and the images/CSVs that they reference).\n\n```\nplugins:\n  - macros:\n    include_dir: run_for_record\n```\n</code></pre>"},{"location":"reference/trendify/#trendify.make_it_trendy","title":"make_it_trendy","text":"<pre><code>make_it_trendy(\n    data_product_generator: Callable[[Path], ProductList] | None,\n    data_dirs: List[Path],\n    products_dir: Path,\n    assets_dir: Path,\n    grafana_dir: Path | None = None,\n    n_procs: int = 1,\n    dpi: int = 500,\n    make_tables: bool = True,\n    make_xy_plots: bool = True,\n    make_histograms: bool = True,\n)\n</code></pre> <p>Maps <code>data_product_generator</code> over <code>dirs_in</code> to produce data product JSON files in those directories. Sorts the generated data products into a nested file structure starting from <code>dir_products</code>. Nested folders are generated for tags that are Tuples.  Sorted data files are named according to the directory from which they were loaded.</p> <p>Parameters:</p> Name Type Description Default <code>data_product_generator</code> <code>Callable[[Path], ProductList] | None</code> <p>A callable function that returns a list of data products given a working directory.</p> required <code>data_dirs</code> <code>List[Path]</code> <p>Directories over which to map the <code>product_generator</code></p> required <code>products_dir</code> <code>Path</code> <p>Directory to which the sorted data products will be written</p> required <code>assets_dir</code> <code>Path</code> <p>Directory to which tables and matplotlib histograms and plots will be written if the appropriate boolean variables <code>make_tables</code>, <code>make_xy_plots</code>, <code>make_histograms</code> are true.</p> required <code>grafana_dir</code> <code>Path</code> <p>Directory to which generated grafana panels and dashboard will be written.</p> <code>None</code> <code>n_procs</code> <code>int = 1</code> <p>Number of processes to run in parallel.  If <code>n_procs==1</code>, directories will be processed sequentially (easier for debugging since the full traceback will be provided). If <code>n_procs &gt; 1</code>, a ProcessPoolExecutor will be used to load and process directories and/or tags in parallel.</p> <code>1</code> <code>dpi</code> <code>int = 500</code> <p>Resolution of output plots when using matplotlib  (for <code>make_xy_plots==True</code> and/or <code>make_histograms==True</code>)</p> <code>500</code> <code>make_tables</code> <code>bool = True</code> <p>Whether or not to collect the  <code>TableEntry</code> products and write them to CSV files (<code>&lt;tag&gt;_melted.csv</code> with <code>&lt;tag&gt;_pivot.csv</code> and <code>&lt;tag&gt;_stats.csv</code> when possible).</p> <code>True</code> <code>make_xy_plots</code> <code>bool = True</code> <p>Whether or not to plot the <code>XYData</code> products using matplotlib</p> <code>True</code> <code>make_histograms</code> <code>bool = True</code> <p>Whether or not to generate histograms of the  <code>HistogramEntry</code> products using matplotlib.</p> <code>True</code>"},{"location":"reference/trendify/#trendify.make_products","title":"make_products","text":"<pre><code>make_products(\n    product_generator: Callable[[Path], DataProductCollection] | None,\n    dirs: List[Path],\n    n_procs: int = 1,\n)\n</code></pre> <p>Maps <code>product_generator</code> over <code>dirs_in</code> to produce data product JSON files in those directories. Sorts the generated data products into a nested file structure starting from <code>dir_products</code>. Nested folders are generated for tags that are Tuples.  Sorted data files are named according to the directory from which they were loaded.</p> <p>Parameters:</p> Name Type Description Default <code>product_generator</code> <code>Callable[[Path], ProductList] | None</code> <p>A callable function that returns a list of data products given a working directory.</p> required <code>dirs</code> <code>List[Path]</code> <p>Directories over which to map the <code>product_generator</code></p> required <code>n_procs</code> <code>int = 1</code> <p>Number of processes to run in parallel.  If <code>n_procs==1</code>, directories will be processed sequentially (easier for debugging since the full traceback will be provided). If <code>n_procs &gt; 1</code>, a ProcessPoolExecutor will be used to load and process directories and/or tags in parallel.</p> <code>1</code>"},{"location":"reference/trendify/#trendify.make_tables_and_figures","title":"make_tables_and_figures","text":"<pre><code>make_tables_and_figures(\n    products_dir: Path,\n    output_dir: Path,\n    dpi: int = 500,\n    n_procs: int = 1,\n    make_tables: bool = True,\n    make_xy_plots: bool = True,\n    make_histograms: bool = True,\n)\n</code></pre> <p>Makes CSV tables and creates plots (using matplotlib).</p> <p>Tags will be processed in parallel and output in nested directory structure under <code>output_dir</code>.</p> <p>Parameters:</p> Name Type Description Default <code>products_dir</code> <code>Path</code> <p>Directory to which the sorted data products will be written</p> required <code>output_dir</code> <code>Path</code> <p>Directory to which tables and matplotlib histograms and plots will be written if the appropriate boolean variables <code>make_tables</code>, <code>make_xy_plots</code>, <code>make_histograms</code> are true.</p> required <code>n_procs</code> <code>int = 1</code> <p>Number of processes to run in parallel.  If <code>n_procs==1</code>, directories will be processed sequentially (easier for debugging since the full traceback will be provided). If <code>n_procs &gt; 1</code>, a ProcessPoolExecutor will be used to load and process directories and/or tags in parallel.</p> <code>1</code> <code>dpi</code> <code>int = 500</code> <p>Resolution of output plots when using matplotlib  (for <code>make_xy_plots==True</code> and/or <code>make_histograms==True</code>)</p> <code>500</code> <code>make_tables</code> <code>bool = True</code> <p>Whether or not to collect the  <code>TableEntry</code> products and write them to CSV files (<code>&lt;tag&gt;_melted.csv</code> with <code>&lt;tag&gt;_pivot.csv</code> and <code>&lt;tag&gt;_stats.csv</code> when possible).</p> <code>True</code> <code>make_xy_plots</code> <code>bool = True</code> <p>Whether or not to plot the <code>XYData</code> products using matplotlib</p> <code>True</code> <code>make_histograms</code> <code>bool = True</code> <p>Whether or not to generate histograms of the  <code>HistogramEntry</code> products using matplotlib.</p> <code>True</code>"},{"location":"reference/trendify/#trendify.sort_products","title":"sort_products","text":"<pre><code>sort_products(data_dirs: List[Path], output_dir: Path)\n</code></pre> <p>Loads the tagged data products from <code>data_dirs</code> and sorts them (by tag) into a nested folder structure rooted at <code>output_dir</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data_dirs</code> <code>List[Path]</code> <p>Directories containing JSON data product files</p> required <code>output_dir</code> <code>Path</code> <p>Directory to which sorted products will be written</p> required"},{"location":"reference/trendify/command_line_interface/","title":"command_line_interface","text":""},{"location":"reference/trendify/command_line_interface/#trendify.command_line_interface","title":"command_line_interface","text":""},{"location":"reference/trendify/products/","title":"products","text":""},{"location":"reference/trendify/products/#trendify.products","title":"products","text":"<p>Module for generating, sorting, and plotting data products. This uses pydantic dataclasses for JSON serialization to avoid overloading system memory.</p> <p>Some important learning material for pydantic classes and JSON (de)serialization:</p> <ul> <li>Nested Pydantic Models</li> <li>Deserializing Child Classes</li> </ul> <p>Attributes:</p> Name Type Description <code>DATA_PRODUCTS_FNAME</code> <code>str</code> <p>Hard-coded json file name 'data_products.json'</p>"},{"location":"reference/trendify/products/#trendify.products.DATA_PRODUCTS_FNAME","title":"DATA_PRODUCTS_FNAME  <code>module-attribute</code>","text":"<pre><code>DATA_PRODUCTS_FNAME = 'data_products.json'\n</code></pre> <p>Hard-coded file name for storing data products in batch-processed input directories.</p>"},{"location":"reference/trendify/products/#trendify.products.ProductList","title":"ProductList  <code>module-attribute</code>","text":"<pre><code>ProductList = List[SerializeAsAny[InstanceOf[DataProduct]]]\n</code></pre> <p>List of serializable DataProduct or child classes thereof</p>"},{"location":"reference/trendify/products/#trendify.products.Tag","title":"Tag  <code>module-attribute</code>","text":"<pre><code>Tag = Union[Tuple[Hashable, ...], Hashable]\n</code></pre> <p>Determines what types can be used to define a tag</p>"},{"location":"reference/trendify/products/#trendify.products.Tags","title":"Tags  <code>module-attribute</code>","text":"<pre><code>Tags = List[Tag]\n</code></pre> <p>List of tags</p>"},{"location":"reference/trendify/products/#trendify.products.DataProduct","title":"DataProduct","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for data products to be generated and handled.</p> <p>Attributes:</p> Name Type Description <code>product_type</code> <code>Hashable</code> <p>Product type should be the same as the class name. The product type is used to search for products from a DataProductCollection.</p> <code>tags</code> <code>Tags</code> <p>Tags to be used for sorting data.</p> <code>metadata</code> <code>dict[str, str]</code> <p>A dictionary of metadata to be used as a tool tip for mousover in grafana</p>"},{"location":"reference/trendify/products/#trendify.products.DataProduct.Config","title":"Config","text":"<p>Disallows additional attributes</p>"},{"location":"reference/trendify/products/#trendify.products.DataProduct.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(**kwargs: Any) -&gt; None\n</code></pre> <p>Registers child subclasses to be able to parse them from JSON file using the  deserialize_child_classes method</p>"},{"location":"reference/trendify/products/#trendify.products.DataProduct.append_to_list","title":"append_to_list","text":"<pre><code>append_to_list(l: List)\n</code></pre> <p>Appends self to list.</p> <p>Parameters:</p> Name Type Description Default <code>l</code> <code>List</code> <p>list to which <code>self</code> will be appended</p> required <p>Returns:</p> Type Description <code>Self</code> <p>returns instance of <code>self</code></p>"},{"location":"reference/trendify/products/#trendify.products.DataProduct.deserialize_child_classes","title":"deserialize_child_classes  <code>classmethod</code>","text":"<pre><code>deserialize_child_classes(key: str, **kwargs)\n</code></pre> <p>Loads json data to pydandic dataclass of whatever DataProduct child time is appropriate</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>json key</p> required <code>kwargs</code> <code>dict</code> <p>json entries stored under given key</p> <code>{}</code>"},{"location":"reference/trendify/products/#trendify.products.DataProductCollection","title":"DataProductCollection","text":"<pre><code>DataProductCollection(**kwargs: Any)\n</code></pre> <p>               Bases: <code>BaseModel</code></p> <p>A collection of data products.</p> <p>Use this class to serialize data products to JSON, de-serialized them from JSON, filter the products, etc.</p> <p>Attributes:</p> Name Type Description <code>elements</code> <code>ProductList</code> <p>A list of data products.</p>"},{"location":"reference/trendify/products/#trendify.products.DataProductCollection.add_products","title":"add_products","text":"<pre><code>add_products(*products: DataProduct)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>products</code> <code>Tuple[DataProduct | ProductList, ...]</code> <p>Products or lists of products to be appended to collection elements.</p> <code>()</code>"},{"location":"reference/trendify/products/#trendify.products.DataProductCollection.collect_from_all_jsons","title":"collect_from_all_jsons  <code>classmethod</code>","text":"<pre><code>collect_from_all_jsons(*dirs: Path, recursive: bool = False)\n</code></pre> <p>Loads all products from JSONs in the given list of directories. If recursive is set to <code>True</code>, the directories will be searched recursively  (this could lead to double counting if you pass in subdirectories of a parent).</p> <p>Parameters:</p> Name Type Description Default <code>dirs</code> <code>Tuple[Path, ...]</code> <p>Directories from which to load data product JSON files.</p> <code>()</code> <code>recursive</code> <code>bool</code> <p>whether or not to search each of the provided directories recursively for  data product json files.</p> <code>False</code> <p>Returns:</p> Type Description <code>Type[Self] | None</code> <p>Data product collection if JSON files are found. Otherwise, returns None if no product JSON files were found.</p>"},{"location":"reference/trendify/products/#trendify.products.DataProductCollection.drop_products","title":"drop_products","text":"<pre><code>drop_products(tag: Hashable | None = None, object_type: Type[R] | None = None) -&gt; Self[R]\n</code></pre> <p>Removes products matching <code>tag</code> and/or <code>object_type</code> from collection elements.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>Tag | None</code> <p>Tag for which data products should be dropped</p> <code>None</code> <code>object_type</code> <code>Type | None</code> <p>Type of data product to drop</p> <code>None</code> <p>Returns:</p> Type Description <code>DataProductCollection</code> <p>A new collection from which matching elements have been dropped.</p>"},{"location":"reference/trendify/products/#trendify.products.DataProductCollection.from_iterable","title":"from_iterable  <code>classmethod</code>","text":"<pre><code>from_iterable(*products: Tuple[ProductList, ...])\n</code></pre> <p>Returns a new instance containing all of the products provided in the <code>*products</code> argument.</p> <p>Parameters:</p> Name Type Description Default <code>products</code> <code>Tuple[ProductList, ...]</code> <p>Lists of data products to combine into a collection</p> <code>()</code> <p>Returns:</p> Type Description <code>cls</code> <p>A data product collection containing all of the provided products in the <code>*products</code> argument.</p>"},{"location":"reference/trendify/products/#trendify.products.DataProductCollection.get_products","title":"get_products","text":"<pre><code>get_products(tag: Hashable | None = None, object_type: Type[R] | None = None) -&gt; Self[R]\n</code></pre> <p>Returns a new collection containing products matching <code>tag</code> and/or <code>object_type</code>. Both <code>tag</code> and <code>object_type</code> default to <code>None</code> which matches all products.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>Tag | None</code> <p>Tag of data products to be kept.  <code>None</code> matches all products.</p> <code>None</code> <code>object_type</code> <code>Type | None</code> <p>Type of data product to keep.  <code>None</code> matches all products.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataProductCollection</code> <p>A new collection containing matching elements.</p>"},{"location":"reference/trendify/products/#trendify.products.DataProductCollection.get_tags","title":"get_tags","text":"<pre><code>get_tags(data_product_type: Type[DataProduct] | None = None) -&gt; set\n</code></pre> <p>Gets the tags related to a given type of <code>DataProduct</code>.  Parent classes will match all child class types.</p> <p>Parameters:</p> Name Type Description Default <code>data_product_type</code> <code>Type[DataProduct] | None</code> <p>type for which you want to get the list of tags</p> <code>None</code> <p>Returns:</p> Type Description <code>set</code> <p>set of tags applying to the given <code>data_product_type</code>.</p>"},{"location":"reference/trendify/products/#trendify.products.DataProductCollection.make_grafana_panels","title":"make_grafana_panels  <code>classmethod</code>","text":"<pre><code>make_grafana_panels(dir_in: Path, panel_dir: Path)\n</code></pre> <p>Processes collection of elements corresponding to a single tag. This method should be called on a directory containing jsons for which the products have been sorted.</p> <p>Parameters:</p> Name Type Description Default <code>dir_in</code> <code>Path</code> <p>Directory from which to read data products (should be sorted first)</p> required <code>panel_dir</code> <code>Path</code> <p>Where to put the panel information</p> required"},{"location":"reference/trendify/products/#trendify.products.DataProductCollection.process_single_tag_collection","title":"process_single_tag_collection  <code>classmethod</code>","text":"<pre><code>process_single_tag_collection(\n    dir_in: Path,\n    dir_out: Path,\n    make_tables: bool,\n    make_xy_plots: bool,\n    make_histograms: bool,\n    dpi: int,\n)\n</code></pre> <p>Processes collection of elements corresponding to a single tag. This method should be called on a directory containing jsons for which the products have been sorted.</p> <p>Parameters:</p> Name Type Description Default <code>dir_in</code> <code>Path</code> required <code>dir_out</code> <code>Path</code> required <code>make_tables</code> <code>bool</code> required <code>make_xy_plots</code> <code>bool</code> required <code>make_histograms</code> <code>bool</code> required <code>dpi</code> <code>int</code> required"},{"location":"reference/trendify/products/#trendify.products.DataProductCollection.sort_by_tags","title":"sort_by_tags  <code>classmethod</code>","text":"<pre><code>sort_by_tags(dirs_in: List[Path], dir_out: Path)\n</code></pre> <p>Loads the data product JSON files from <code>dirs_in</code> sorts the products. Sorted products are written to smaller files in a nested directory structure under <code>dir_out</code>. The nested directory structure is generated accordint to the data tags. Resulting product files are named according to the directory from which they were originally loaded.</p> <p>Parameters:</p> Name Type Description Default <code>dirs_in</code> <code>List[Path]</code> <p>Directories from which the data product JSON files are to be loaded.</p> required <code>dir_out</code> <code>Path</code> <p>Directory to which the sorted data products will be written into a  nested folder structure generated according to the data tags.</p> required"},{"location":"reference/trendify/products/#trendify.products.DataProductCollection.union","title":"union  <code>classmethod</code>","text":"<pre><code>union(*collections: DataProductCollection)\n</code></pre> <p>Aggregates all of the products from multiple collections into a new larger collection.</p> <p>Parameters:</p> Name Type Description Default <code>collections</code> <code>Tuple[DataProductCollection, ...]</code> <p>Data product collections for which the products should be combined into a new collection.</p> <code>()</code> <p>Returns:</p> Type Description <code>Type[Self]</code> <p>A new data product collection containing all products from the provided <code>*collections</code>.</p>"},{"location":"reference/trendify/products/#trendify.products.DataProductGenerator","title":"DataProductGenerator","text":"<pre><code>DataProductGenerator(processor: Callable[[Path], ProductList])\n</code></pre> <p>A wrapper for saving the data products generated by a user defined function</p> <p>Parameters:</p> Name Type Description Default <code>processor</code> <code>Callable[[Path], ProductList]</code> <p>A callable that receives a working directory and returns a list of data products.</p> required"},{"location":"reference/trendify/products/#trendify.products.DataProductGenerator.process_and_save","title":"process_and_save","text":"<pre><code>process_and_save(workdir: Path)\n</code></pre> <p>Runs the user-defined processor method stored at instantiation.</p> <p>Saves the returned products to a JSON file in the same directory.</p> <p>Parameters:</p> Name Type Description Default <code>workdir</code> <code>Path</code> <p>working directory on which to run the processor method.</p> required"},{"location":"reference/trendify/products/#trendify.products.Format2D","title":"Format2D","text":"<p>               Bases: <code>HashableBase</code></p> <p>Formatting data for matplotlib figure and axes</p>"},{"location":"reference/trendify/products/#trendify.products.Format2D.Config","title":"Config","text":"<p>Forbids extra arguments</p>"},{"location":"reference/trendify/products/#trendify.products.Format2D.union_from_iterable","title":"union_from_iterable  <code>classmethod</code>","text":"<pre><code>union_from_iterable(format2ds: Iterable[Format2D])\n</code></pre> <p>Gets the most inclusive format object (in terms of limits) from a list of <code>Format2D</code> objects. Requires that the label and title fields are identical for all format objects in the list.</p> <p>Parameters:</p> Name Type Description Default <code>format2ds</code> <code>Iterable[Format2D]</code> <p>Iterable of <code>Format2D</code> objects.</p> required <p>Returns:</p> Type Description <code>Format2D</code> <p>Single format object from list of objects.</p>"},{"location":"reference/trendify/products/#trendify.products.HashableBase","title":"HashableBase","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines a base for hashable pydantic data classes so that they can be reduced to a minimal set through type-casting.</p>"},{"location":"reference/trendify/products/#trendify.products.HashableBase.__hash__","title":"__hash__","text":"<pre><code>__hash__()\n</code></pre> <p>Defines hash function</p>"},{"location":"reference/trendify/products/#trendify.products.HistogramEntry","title":"HistogramEntry","text":"<p>               Bases: <code>DataProduct</code></p> <p>Use this class to specify a value to be collected into a matplotlib histogram.</p> <p>Attributes:</p> Name Type Description <code>product_type</code> <code>Literal['Trace2D']</code> <p>Name of class type to be used as a constructor.</p> <code>value</code> <code>float | str</code> <p>Value to be binned</p> <code>tags</code> <code>Tags</code> <p>Hashable tags used to sort data products</p> <code>style</code> <code>HistogramStyle</code> <p>Style of histogram display</p> <code>format2d</code> <code>Format2D</code> <p>Format to apply to single axis figure</p>"},{"location":"reference/trendify/products/#trendify.products.HistogramEntry.Config","title":"Config","text":"<p>Forbids extra attributes</p>"},{"location":"reference/trendify/products/#trendify.products.HistogramStyle","title":"HistogramStyle","text":"<p>               Bases: <code>HashableBase</code></p> <p>Label and style data for generating histogram bars</p> <p>Attributes:</p> Name Type Description <code>color</code> <code>str</code> <p>Color of bars</p> <code>label</code> <code>str | None</code> <p>Legend entry</p> <code>histtype</code> <code>str</code> <p>Histogram type corresponding to matplotlib argument of same name</p> <code>alpha_edge</code> <code>float</code> <p>Opacity of bar edge</p> <code>alpha_face</code> <code>float</code> <p>Opacity of bar face</p> <code>linewidth</code> <code>float</code> <p>Line width of bar outline</p>"},{"location":"reference/trendify/products/#trendify.products.HistogramStyle.as_plot_kwargs","title":"as_plot_kwargs","text":"<pre><code>as_plot_kwargs()\n</code></pre> <p>Returns:</p> Type Description <code>dict</code> <p>kwargs for matplotlib <code>hist</code> method</p>"},{"location":"reference/trendify/products/#trendify.products.Histogrammer","title":"Histogrammer","text":"<pre><code>Histogrammer(in_dirs: List[Path], out_dir: Path, dpi: int)\n</code></pre> <p>Class for loading data products and histogramming the <code>HistogramEntry</code>s</p> <p>Parameters:</p> Name Type Description Default <code>in_dirs</code> <code>List[Path]</code> <p>Directories from which the data products are to be loaded.</p> required <code>out_dir</code> <code>Path</code> <p>Directory to which the generated histogram will be stored</p> required <code>dpi</code> <code>int</code> <p>resolution of plot</p> required"},{"location":"reference/trendify/products/#trendify.products.Histogrammer.handle_histogram_entries","title":"handle_histogram_entries  <code>classmethod</code>","text":"<pre><code>handle_histogram_entries(\n    tag: Hashable, histogram_entries: List[HistogramEntry], dir_out: Path, dpi: int\n)\n</code></pre> <p>Histograms the provided entries. Formats and saves the figure.  Closes the figure.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>Hashable</code> <p>Tag used to filter the loaded data products</p> required <code>histogram_entries</code> <code>List[HistogramEntry]</code> <p>A list of <code>HistogramEntry</code>s</p> required <code>dir_out</code> <code>Path</code> <p>Directory to which the generated histogram will be stored</p> required <code>dpi</code> <code>int</code> <p>resolution of plot</p> required"},{"location":"reference/trendify/products/#trendify.products.Histogrammer.plot","title":"plot","text":"<pre><code>plot(tag: Hashable)\n</code></pre> <p>Generates a histogram by loading data from stored <code>in_dirs</code> and saves the plot to <code>out_dir</code> directory. A nested folder structure will be created if the provided <code>tag</code> is a tuple. In that case, the last tag item (with an appropriate suffix) will be used for the file name.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>Hashable</code> <p>Tag used to filter the loaded data products</p> required"},{"location":"reference/trendify/products/#trendify.products.Marker","title":"Marker","text":"<p>               Bases: <code>HashableBase</code></p> <p>Defines marker for scattering to matplotlib</p> <p>Attributes:</p> Name Type Description <code>color</code> <code>str</code> <p>Color of line</p> <code>size</code> <code>float</code> <p>Line width</p> <code>alpha</code> <code>float</code> <p>Opacity from 0 to 1 (inclusive)</p> <code>zorder</code> <code>float</code> <p>Prioritization </p> <code>label</code> <code>Union[str, None]</code> <p>Legend label</p> <code>symbol</code> <code>str</code> <p>Matplotlib symbol string</p>"},{"location":"reference/trendify/products/#trendify.products.Marker.Config","title":"Config","text":"<p>Forbids extra attributes</p>"},{"location":"reference/trendify/products/#trendify.products.Marker.as_scatter_plot_kwargs","title":"as_scatter_plot_kwargs","text":"<pre><code>as_scatter_plot_kwargs()\n</code></pre> <p>Returns:</p> Type Description <code>dict</code> <p>dictionary of <code>kwargs</code> for matplotlib scatter</p>"},{"location":"reference/trendify/products/#trendify.products.Marker.from_pen","title":"from_pen  <code>classmethod</code>","text":"<pre><code>from_pen(pen: Pen, symbol: str = '.')\n</code></pre> <p>Converts Pen to marker with the option to specify a symbol</p>"},{"location":"reference/trendify/products/#trendify.products.Pen","title":"Pen","text":"<p>               Bases: <code>HashableBase</code></p> <p>Defines the pen drawing to matplotlib.</p> <p>Attributes:</p> Name Type Description <code>color</code> <code>str</code> <p>Color of line</p> <code>size</code> <code>float</code> <p>Line width</p> <code>alpha</code> <code>float</code> <p>Opacity from 0 to 1 (inclusive)</p> <code>zorder</code> <code>float</code> <p>Prioritization </p> <code>label</code> <code>Union[str, None]</code> <p>Legend label</p>"},{"location":"reference/trendify/products/#trendify.products.Pen.Config","title":"Config","text":"<p>Forbids extra attributes</p>"},{"location":"reference/trendify/products/#trendify.products.Pen.as_scatter_plot_kwargs","title":"as_scatter_plot_kwargs","text":"<pre><code>as_scatter_plot_kwargs()\n</code></pre> <p>Returns kwargs dictionary for passing to matplotlib plot method</p>"},{"location":"reference/trendify/products/#trendify.products.Point2D","title":"Point2D","text":"<p>               Bases: <code>XYData</code></p> <p>Defines a point to be scattered onto xy plot.</p> <p>Attributes:</p> Name Type Description <code>product_type</code> <code>Literal['Trace2D']</code> <p>Name of class type to be used as a constructor.</p> <code>points</code> <code>List[Point2D]</code> <p>List of points.  Usually the points would have null values  for <code>marker</code> and <code>format2d</code> fields to save space.</p> <code>marker</code> <code>Marker</code> <p>Style and label information for scattering points to matplotlib axes. Only the label information is used in Grafana. Eventually style information will be used in grafana.</p> <code>format2d</code> <code>Format2D</code> <p>Formatting information for matplotlib figure.</p>"},{"location":"reference/trendify/products/#trendify.products.Point2D.Config","title":"Config","text":"<p>Forbids extra attributes</p>"},{"location":"reference/trendify/products/#trendify.products.SingleAxisFigure","title":"SingleAxisFigure","text":"<p>               Bases: <code>BaseModel</code></p> <p>Data class storing a matlab figure and axis.  The stored tag data in this class is so-far unused.</p> <p>Attributes:</p> Name Type Description <code>ax</code> <code>Axes</code> <p>Matplotlib axis to which data will be plotted</p> <code>fig</code> <code>Figure</code> <p>Matplotlib figure.</p> <code>tag</code> <code>Hashable</code> <p>Figure tag.  Not yet used.</p>"},{"location":"reference/trendify/products/#trendify.products.SingleAxisFigure.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Closes stored matplotlib figure before deleting reference to object.</p>"},{"location":"reference/trendify/products/#trendify.products.SingleAxisFigure.apply_format","title":"apply_format","text":"<pre><code>apply_format(format2d: Format2D)\n</code></pre> <p>Applies format to figure and axes labels and limits</p> <p>Parameters:</p> Name Type Description Default <code>format2d</code> <code>Format2D</code> <p>format information to apply to the single axis figure</p> required"},{"location":"reference/trendify/products/#trendify.products.SingleAxisFigure.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(tag: Hashable)\n</code></pre> <p>Creates new figure and axis.  Returns new instance of this class.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>Hashable</code> <p>tag (not yet used)</p> required <p>Returns:</p> Type Description <code>Type[Self]</code> <p>New single axis figure</p>"},{"location":"reference/trendify/products/#trendify.products.SingleAxisFigure.savefig","title":"savefig","text":"<pre><code>savefig(path: Path, dpi: int = 500)\n</code></pre> <p>Wrapper on matplotlib savefig method.  Saves figure to given path with given dpi resolution.</p> <p>Returns:</p> Type Description <code>Self</code> <p>Returns self</p>"},{"location":"reference/trendify/products/#trendify.products.TableBuilder","title":"TableBuilder","text":"<pre><code>TableBuilder(in_dirs: List[Path], out_dir: Path)\n</code></pre> <p>Builds tables (melted, pivot, and stats) for histogramming and including in a report or Grafana dashboard.</p> <p>Parameters:</p> Name Type Description Default <code>in_dirs</code> <code>List[Path]</code> <p>directories from which to load data products</p> required <code>out_dir</code> <code>Path</code> <p>directory in which tables should be saved</p> required"},{"location":"reference/trendify/products/#trendify.products.TableBuilder.get_stats_table","title":"get_stats_table  <code>classmethod</code>","text":"<pre><code>get_stats_table(df: DataFrame)\n</code></pre> <p>Computes multiple statistics for each column</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame for which the column statistics are to be calculated.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataframe having statistics (column headers) for each of the columns of the input <code>df</code>.  The columns of <code>df</code> will be the row indices of the stats table.</p>"},{"location":"reference/trendify/products/#trendify.products.TableBuilder.load_table","title":"load_table","text":"<pre><code>load_table(tag: Hashable)\n</code></pre> <p>Collects table entries from JSON files corresponding to given tag and processes them.</p> <p>Saves CSV files for the melted data frame, pivot dataframe, and pivot dataframe stats.</p> <p>File names will all use the tag with different suffixes  <code>'tag_melted.csv'</code>, <code>'tag_pivot.csv'</code>, <code>'name_stats.csv'</code>.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>Hashable</code> <p>product tag for which to collect and process.</p> required"},{"location":"reference/trendify/products/#trendify.products.TableBuilder.process_table_entries","title":"process_table_entries  <code>classmethod</code>","text":"<pre><code>process_table_entries(tag: Hashable, table_entries: List[TableEntry], out_dir: Path)\n</code></pre> <p>Saves CSV files for the melted data frame, pivot dataframe, and pivot dataframe stats.</p> <p>File names will all use the tag with different suffixes  <code>'tag_melted.csv'</code>, <code>'tag_pivot.csv'</code>, <code>'name_stats.csv'</code>.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>Hashable</code> <p>product tag for which to collect and process.</p> required <code>table_entries</code> <code>List[TableEntry]</code> <p>List of table entries</p> required <code>out_dir</code> <code>Path</code> <p>Directory to which table CSV files should be saved</p> required"},{"location":"reference/trendify/products/#trendify.products.TableEntry","title":"TableEntry","text":"<p>               Bases: <code>DataProduct</code></p> <p>Defines an entry to be collected into a table.</p> <p>Collected table entries will be printed in three forms when possible: melted, pivot (when possible), and stats (on pivot columns, when possible).</p> <p>Attributes:</p> Name Type Description <code>product_type</code> <code>Literal['Trace2D']</code> <p>Name of class type to be used as a constructor.</p> <code>row</code> <code>float | str</code> <p>Value to be binned</p> <code>col</code> <code>float | str</code> <p>Hashable tags used to sort data products</p> <code>value</code> <code>float | str</code> <p>Style of histogram display</p> <code>unit</code> <code>str | None</code> <p>Format to apply to single axis figure</p>"},{"location":"reference/trendify/products/#trendify.products.TableEntry.get_entry_dict","title":"get_entry_dict","text":"<pre><code>get_entry_dict()\n</code></pre> <p>Returns a dictionary of entries to be used in creating a table.</p> <p>Returns:</p> Type Description <code>dict[str, str | float]</code> <p>Dictionary of entries to be used in creating a melted DataFrame</p>"},{"location":"reference/trendify/products/#trendify.products.TableEntry.load_and_pivot","title":"load_and_pivot  <code>classmethod</code>","text":"<pre><code>load_and_pivot(path: Path)\n</code></pre> <p>Loads melted table from csv and pivots to wide form. csv should have columns named <code>'row'</code>, <code>'col'</code>, and <code>'value'</code>.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>path to CSV file</p> required <p>Returns:</p> Type Description <code>DataFrame | None</code> <p>Pivoted data frame or elese <code>None</code> if pivot operation fails.</p>"},{"location":"reference/trendify/products/#trendify.products.TableEntry.pivot_table","title":"pivot_table  <code>classmethod</code>","text":"<pre><code>pivot_table(melted: DataFrame)\n</code></pre> <p>Attempts to pivot melted row, col, value DataFrame into a wide form DataFrame</p> <p>Parameters:</p> Name Type Description Default <code>melted</code> <code>DataFrame</code> <p>Melted data frame having columns named <code>'row'</code>, <code>'col'</code>, <code>'value'</code>.</p> required <p>Returns:</p> Type Description <code>DataFrame | None</code> <p>pivoted DataFrame if pivot works else <code>None</code>. Pivot operation fails if  row or column index pairs are repeated.</p>"},{"location":"reference/trendify/products/#trendify.products.Trace2D","title":"Trace2D","text":"<p>               Bases: <code>XYData</code></p> <p>A collection of points comprising a trace. Use the Trace2D.from_xy constructor.</p> <p>Attributes:</p> Name Type Description <code>product_type</code> <code>Literal['Trace2D']</code> <p>Name of class type to be used as a constructor.</p> <code>points</code> <code>List[Point2D]</code> <p>List of points.  Usually the points would have null values  for <code>marker</code> and <code>format2d</code> fields to save space.</p> <code>pen</code> <code>Pen</code> <p>Style and label information for drawing to matplotlib axes. Only the label information is used in Grafana. Eventually style information will be used in grafana.</p> <code>format2d</code> <code>Format2D</code> <p>Formatting information for matplotlib figure.</p>"},{"location":"reference/trendify/products/#trendify.products.Trace2D.x","title":"x  <code>property</code>","text":"<pre><code>x\n</code></pre> <p>Returns an array of x values from <code>self.points</code></p> <p>Returns:</p> Type Description <code>NDArray[Shape['*'], float]</code> <p>array of x values from <code>self.points</code></p> <p>'</p>"},{"location":"reference/trendify/products/#trendify.products.Trace2D.y","title":"y  <code>property</code>","text":"<pre><code>y\n</code></pre> <p>Returns an array of y values from <code>self.points</code></p> <p>Returns:</p> Type Description <code>NDArray[Shape['*'], float]</code> <p>array of y values from <code>self.points</code></p>"},{"location":"reference/trendify/products/#trendify.products.Trace2D.Config","title":"Config","text":"<p>Forbids extra attributes</p>"},{"location":"reference/trendify/products/#trendify.products.Trace2D.from_xy","title":"from_xy  <code>classmethod</code>","text":"<pre><code>from_xy(\n    tags: Tags,\n    x: NDArray[Shape[\"*\"], float],\n    y: NDArray[Shape[\"*\"], float],\n    pen: Pen = Pen(),\n    format2d: Format2D = Format2D(),\n)\n</code></pre> <p>Creates a list of Point2Ds from xy data and returns a new Trace2D product.</p> <p>Parameters:</p> Name Type Description Default <code>tags</code> <code>Tags</code> <p>Hashable tags used to sort data products</p> required <code>x</code> <code>NDArray[Shape['*'], float]</code> <p>x values</p> required <code>y</code> <code>NDArray[Shape['*'], float]</code> <p>y values</p> required <code>pen</code> <code>Pen</code> <p>Style and label for trace</p> <code>Pen()</code> <code>format2d</code> <code>Format2D</code> <p>format to apply to matplotlib</p> <code>Format2D()</code>"},{"location":"reference/trendify/products/#trendify.products.Trace2D.plot_to_ax","title":"plot_to_ax","text":"<pre><code>plot_to_ax(ax: Axes)\n</code></pre> <p>Plots xy data from trace to a matplotlib axes object.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>axes to which xy data should be plotted</p> required"},{"location":"reference/trendify/products/#trendify.products.Trace2D.propagate_format2d_and_pen","title":"propagate_format2d_and_pen","text":"<pre><code>propagate_format2d_and_pen(marker_symbol: str = '.') -&gt; None\n</code></pre> <p>Propagates format and style info to all <code>self.points</code> (in-place). I thought this would  be useful for grafana before I learned better methods for propagating the data. It still may end up being useful if my plotting method changes.  Keeping for potential future use case.</p> <p>Parameters:</p> Name Type Description Default <code>marker_symbol</code> <code>str</code> <p>Valid matplotlib marker symbol</p> <code>'.'</code>"},{"location":"reference/trendify/products/#trendify.products.XYData","title":"XYData","text":"<p>               Bases: <code>DataProduct</code></p> <p>Base class for children of DataProduct to be plotted ax xy data on a 2D plot</p>"},{"location":"reference/trendify/products/#trendify.products.XYDataPlotter","title":"XYDataPlotter","text":"<pre><code>XYDataPlotter(in_dirs: List[Path], out_dir: Path, dpi: int = 500)\n</code></pre> <p>Plots xy data from user-specified directories to a single axis figure</p> <p>Parameters:</p> Name Type Description Default <code>in_dirs</code> <code>List[Path]</code> <p>Directories in which to search for data products from JSON files</p> required <code>out_dir</code> <code>Path</code> <p>directory to which figure will be output</p> required <code>dpi</code> <code>int</code> <p>Saved image resolution</p> <code>500</code>"},{"location":"reference/trendify/products/#trendify.products.XYDataPlotter.handle_points_and_traces","title":"handle_points_and_traces  <code>classmethod</code>","text":"<pre><code>handle_points_and_traces(\n    tag: Hashable, points: List[Point2D], traces: List[Trace2D], dir_out: Path, dpi: int\n)\n</code></pre> <p>Plots points and traces, formats figure, saves figure, and closes matplotlinb figure.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>Hashable</code> <p>Tag  corresponding to the provided points and traces</p> required <code>points</code> <code>List[Point2D]</code> <p>Points to be scattered</p> required <code>traces</code> <code>List[Trace2D]</code> <p>List of traces to be plotted</p> required <code>dir_out</code> <code>Path</code> <p>directory to output the plot</p> required <code>dpi</code> <code>int</code> <p>resolution of plot</p> required"},{"location":"reference/trendify/products/#trendify.products.XYDataPlotter.plot","title":"plot","text":"<pre><code>plot(tag: Hashable)\n</code></pre> <ul> <li>Collects data from json files in stored <code>self.in_dirs</code>, </li> <li>plots the relevant products,</li> <li>applies labels and formatting, </li> <li>saves the figure</li> <li>closes matplotlib figure</li> </ul> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>Hashable</code> <p>data tag for which products are to be collected and plotted.</p> required"},{"location":"reference/trendify/products/#trendify.products.atleast_1d","title":"atleast_1d","text":"<pre><code>atleast_1d(obj: Any) -&gt; Iterable\n</code></pre> <p>Converts scalar objec to a list of length 1 or leaves an iterable object unchanged.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>Object that needs to be at least 1d</p> required <p>Returns:</p> Type Description <code>Iterable</code> <p>Returns an iterable</p>"},{"location":"reference/trendify/products/#trendify.products.flatten","title":"flatten","text":"<pre><code>flatten(obj: Iterable)\n</code></pre> <p>Recursively flattens iterable up to a point (leaves <code>str</code>, <code>bytes</code>, and <code>DataProduct</code> unflattened)</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Iterable</code> <p>Object to be flattened</p> required <p>Returns:</p> Type Description <code>Iterable</code> <p>Flattned iterable</p>"},{"location":"reference/trendify/products/#trendify.products.get_sorted_dirs","title":"get_sorted_dirs","text":"<pre><code>get_sorted_dirs(dirs: List[Path])\n</code></pre> <p>Sorts dirs numerically if possible, else alphabetically</p> <p>Parameters:</p> Name Type Description Default <code>dirs</code> <code>List[Path]</code> <p>Directories to sort</p> required <p>Returns:</p> Type Description <code>List[Path]</code> <p>Sorted list of directories</p>"},{"location":"reference/trendify/products/#trendify.products.main","title":"main","text":"<pre><code>main()\n</code></pre> <p>Makes sample data, processes it, and serves it for importing into Grafana</p>"},{"location":"reference/trendify/products/#trendify.products.make_grafana_dashboard","title":"make_grafana_dashboard","text":"<pre><code>make_grafana_dashboard(sorted_products_dir: Path, output_dir: Path, n_procs: int = 1)\n</code></pre> <p>Makes a JSON file to import to Grafana for displaying tagged data tables, histograms and XY plots.</p> <p>Parameters:</p> Name Type Description Default <code>sorted_products_dir</code> <code>Path</code> <p>Root directory into which products have been sorted by tag</p> required <code>output_dir</code> <code>Path</code> <p>Root directory into which Grafana dashboard and panal definitions will be written</p> required <code>n_procs</code> <code>int</code> <p>Number of parallel tasks used for processing data product tags</p> <code>1</code>"},{"location":"reference/trendify/products/#trendify.products.make_include_files","title":"make_include_files","text":"<pre><code>make_include_files(\n    root_dir: Path,\n    local_server_path: str | Path = None,\n    mkdocs_include_dir: str | Path = None,\n    heading_level: int | None = None,\n)\n</code></pre> <p>Makes nested include files for inclusion into an MkDocs site.</p> Note <p>I recommend to create a Grafana panel and link to that from the MkDocs site instead.</p> <p>Parameters:</p> Name Type Description Default <code>root_dir</code> <code>Path</code> <p>Directory for which the include files should be recursively generated</p> required <code>local_server_path</code> <code>str | Path | None</code> <p>What should the beginning of the path look like? Use <code>//localhost:8001/...</code> something like that to work with <code>python -m mkdocs serve</code> while running <code>python -m http.server 8001</code> in order to have interactive updates. Use my python <code>convert_links.py</code> script to update after running <code>python -m mkdocs build</code> in order to fix the links for the MkDocs site.  See this repo for an example.</p> <code>None</code> <code>mkdocs_include_dir</code> <code>str | Path | None</code> <p>Path to be used for mkdocs includes. This path should correspond to includ dir in <code>mkdocs.yml</code> file.  (See <code>vulcan_srb_sep</code> repo for example).</p> <code>None</code> <p>Note:</p> <pre><code>Here is how to setup `mkdocs.yml` file to have an `include_dir` that can be used to \ninclude generated markdown files (and the images/CSVs that they reference).\n\n```\nplugins:\n  - macros:\n    include_dir: run_for_record\n```\n</code></pre>"},{"location":"reference/trendify/products/#trendify.products.make_it_trendy","title":"make_it_trendy","text":"<pre><code>make_it_trendy(\n    data_product_generator: Callable[[Path], ProductList] | None,\n    data_dirs: List[Path],\n    products_dir: Path,\n    assets_dir: Path,\n    grafana_dir: Path | None = None,\n    n_procs: int = 1,\n    dpi: int = 500,\n    make_tables: bool = True,\n    make_xy_plots: bool = True,\n    make_histograms: bool = True,\n)\n</code></pre> <p>Maps <code>data_product_generator</code> over <code>dirs_in</code> to produce data product JSON files in those directories. Sorts the generated data products into a nested file structure starting from <code>dir_products</code>. Nested folders are generated for tags that are Tuples.  Sorted data files are named according to the directory from which they were loaded.</p> <p>Parameters:</p> Name Type Description Default <code>data_product_generator</code> <code>Callable[[Path], ProductList] | None</code> <p>A callable function that returns a list of data products given a working directory.</p> required <code>data_dirs</code> <code>List[Path]</code> <p>Directories over which to map the <code>product_generator</code></p> required <code>products_dir</code> <code>Path</code> <p>Directory to which the sorted data products will be written</p> required <code>assets_dir</code> <code>Path</code> <p>Directory to which tables and matplotlib histograms and plots will be written if the appropriate boolean variables <code>make_tables</code>, <code>make_xy_plots</code>, <code>make_histograms</code> are true.</p> required <code>grafana_dir</code> <code>Path</code> <p>Directory to which generated grafana panels and dashboard will be written.</p> <code>None</code> <code>n_procs</code> <code>int = 1</code> <p>Number of processes to run in parallel.  If <code>n_procs==1</code>, directories will be processed sequentially (easier for debugging since the full traceback will be provided). If <code>n_procs &gt; 1</code>, a ProcessPoolExecutor will be used to load and process directories and/or tags in parallel.</p> <code>1</code> <code>dpi</code> <code>int = 500</code> <p>Resolution of output plots when using matplotlib  (for <code>make_xy_plots==True</code> and/or <code>make_histograms==True</code>)</p> <code>500</code> <code>make_tables</code> <code>bool = True</code> <p>Whether or not to collect the  <code>TableEntry</code> products and write them to CSV files (<code>&lt;tag&gt;_melted.csv</code> with <code>&lt;tag&gt;_pivot.csv</code> and <code>&lt;tag&gt;_stats.csv</code> when possible).</p> <code>True</code> <code>make_xy_plots</code> <code>bool = True</code> <p>Whether or not to plot the <code>XYData</code> products using matplotlib</p> <code>True</code> <code>make_histograms</code> <code>bool = True</code> <p>Whether or not to generate histograms of the  <code>HistogramEntry</code> products using matplotlib.</p> <code>True</code>"},{"location":"reference/trendify/products/#trendify.products.make_products","title":"make_products","text":"<pre><code>make_products(\n    product_generator: Callable[[Path], DataProductCollection] | None,\n    dirs: List[Path],\n    n_procs: int = 1,\n)\n</code></pre> <p>Maps <code>product_generator</code> over <code>dirs_in</code> to produce data product JSON files in those directories. Sorts the generated data products into a nested file structure starting from <code>dir_products</code>. Nested folders are generated for tags that are Tuples.  Sorted data files are named according to the directory from which they were loaded.</p> <p>Parameters:</p> Name Type Description Default <code>product_generator</code> <code>Callable[[Path], ProductList] | None</code> <p>A callable function that returns a list of data products given a working directory.</p> required <code>dirs</code> <code>List[Path]</code> <p>Directories over which to map the <code>product_generator</code></p> required <code>n_procs</code> <code>int = 1</code> <p>Number of processes to run in parallel.  If <code>n_procs==1</code>, directories will be processed sequentially (easier for debugging since the full traceback will be provided). If <code>n_procs &gt; 1</code>, a ProcessPoolExecutor will be used to load and process directories and/or tags in parallel.</p> <code>1</code>"},{"location":"reference/trendify/products/#trendify.products.make_sample_data","title":"make_sample_data","text":"<pre><code>make_sample_data(workdir: Path, n_folders: int = 10)\n</code></pre> <p>Makes some sample data from which to generate products</p> <p>Parameters:</p> Name Type Description Default <code>workdir</code> <code>Path</code> <p>Directory in which the sample data is to be generated</p> required <code>n_folders</code> <code>int</code> <p>Number of sample data files to generate (in separate subfolders).</p> <code>10</code>"},{"location":"reference/trendify/products/#trendify.products.make_tables_and_figures","title":"make_tables_and_figures","text":"<pre><code>make_tables_and_figures(\n    products_dir: Path,\n    output_dir: Path,\n    dpi: int = 500,\n    n_procs: int = 1,\n    make_tables: bool = True,\n    make_xy_plots: bool = True,\n    make_histograms: bool = True,\n)\n</code></pre> <p>Makes CSV tables and creates plots (using matplotlib).</p> <p>Tags will be processed in parallel and output in nested directory structure under <code>output_dir</code>.</p> <p>Parameters:</p> Name Type Description Default <code>products_dir</code> <code>Path</code> <p>Directory to which the sorted data products will be written</p> required <code>output_dir</code> <code>Path</code> <p>Directory to which tables and matplotlib histograms and plots will be written if the appropriate boolean variables <code>make_tables</code>, <code>make_xy_plots</code>, <code>make_histograms</code> are true.</p> required <code>n_procs</code> <code>int = 1</code> <p>Number of processes to run in parallel.  If <code>n_procs==1</code>, directories will be processed sequentially (easier for debugging since the full traceback will be provided). If <code>n_procs &gt; 1</code>, a ProcessPoolExecutor will be used to load and process directories and/or tags in parallel.</p> <code>1</code> <code>dpi</code> <code>int = 500</code> <p>Resolution of output plots when using matplotlib  (for <code>make_xy_plots==True</code> and/or <code>make_histograms==True</code>)</p> <code>500</code> <code>make_tables</code> <code>bool = True</code> <p>Whether or not to collect the  <code>TableEntry</code> products and write them to CSV files (<code>&lt;tag&gt;_melted.csv</code> with <code>&lt;tag&gt;_pivot.csv</code> and <code>&lt;tag&gt;_stats.csv</code> when possible).</p> <code>True</code> <code>make_xy_plots</code> <code>bool = True</code> <p>Whether or not to plot the <code>XYData</code> products using matplotlib</p> <code>True</code> <code>make_histograms</code> <code>bool = True</code> <p>Whether or not to generate histograms of the  <code>HistogramEntry</code> products using matplotlib.</p> <code>True</code>"},{"location":"reference/trendify/products/#trendify.products.map_callable","title":"map_callable","text":"<pre><code>map_callable(\n    f: Callable[[Path], DataProductCollection], *iterables, n_procs: int = 1, mp_context=None\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[Path], DataProductCollection]</code> <p>Function to be mapped</p> required <code>iterables</code> <code>Tuple[Iterable, ...]</code> <p>iterables of arguments for mapped function <code>f</code></p> <code>()</code> <code>n_procs</code> <code>int</code> <p>Number of parallel processes to run</p> <code>1</code> <code>mp_context</code> <code>str</code> <p>Context to use for creating new processes (see <code>multiprocessing</code> package documentation)</p> <code>None</code>"},{"location":"reference/trendify/products/#trendify.products.sample_processor","title":"sample_processor","text":"<pre><code>sample_processor(workdir: Path) -&gt; ProductList\n</code></pre> <p>Processes the generated sample data in given workdir returning several types of data products.</p> <p>Parameters:</p> Name Type Description Default <code>workdir</code> <code>Path</code> <p>Directory containing sample data.</p> required"},{"location":"reference/trendify/products/#trendify.products.should_be_flattened","title":"should_be_flattened","text":"<pre><code>should_be_flattened(obj: Any)\n</code></pre> <p>Checks if object is an iterable container that should be flattened. <code>DataProduct</code>s will not be flattened.  Strings will not be flattened. Everything else will be flattened.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>Object to be tested</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether or not to flatten object</p>"},{"location":"reference/trendify/products/#trendify.products.sort_products","title":"sort_products","text":"<pre><code>sort_products(data_dirs: List[Path], output_dir: Path)\n</code></pre> <p>Loads the tagged data products from <code>data_dirs</code> and sorts them (by tag) into a nested folder structure rooted at <code>output_dir</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data_dirs</code> <code>List[Path]</code> <p>Directories containing JSON data product files</p> required <code>output_dir</code> <code>Path</code> <p>Directory to which sorted products will be written</p> required"},{"location":"reference/trendify/products/#trendify.products.squeeze","title":"squeeze","text":"<pre><code>squeeze(obj: Union[Iterable, Any])\n</code></pre> <p>Returns a scalar if object is iterable of length 1 else returns object.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Union[Iterable, Any]</code> <p>An object to be squeezed if possible</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Either iterable or scalar if possible</p>"},{"location":"reference/trendify/server/","title":"server","text":""},{"location":"reference/trendify/server/#trendify.server","title":"server","text":"<p>Defines database server for DataProductCollection from analyses</p>"},{"location":"reference/trendify/server/#trendify.server.get_data_products","title":"get_data_products","text":"<pre><code>get_data_products(\n    analysis: str = \"workdir.products\", tag: str = \"trace_plots\", product_type: str = \"DataProduct\"\n)\n</code></pre> Traces <p>parse-json | project \"elements\" | extend \"label\"=\"pen.label\" | mv-expand \"points\" | extend \"x\"=\"points.x\", \"y\"=\"points.y\" | project \"label\", \"x\", \"y\" | pivot sum(\"y\"), \"x\", \"label\" | project \"label\", \"x\", \"y\"</p>"}]}